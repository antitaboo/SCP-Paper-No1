\documentclass[preprint,3p,number]{elsarticle}

\usepackage{lineno,hyperref}
\modulolinenumbers[5]

\journal{Science of Computer Programming}

%%%%%%%%%%%%%%%%%%%%%%%
%% Elsevier bibliography styles
%%%%%%%%%%%%%%%%%%%%%%%
%% To change the style, put a % in front of the second line of the current style and
%% remove the % from the second line of the style you would like to use.
%%%%%%%%%%%%%%%%%%%%%%%

%% Numbered
%\bibliographystyle{model1-num-names}

%% Numbered without titles
%\bibliographystyle{model1a-num-names}

%% Harvard
%\bibliographystyle{model2-names.bst}\biboptions{authoryear}

%% Vancouver numbered
%\usepackage{numcompress}\bibliographystyle{model3-num-names}

%% Vancouver name/year
%\usepackage{numcompress}\bibliographystyle{model4-names}\biboptions{authoryear}

%% APA style
%\bibliographystyle{model5-names}\biboptions{authoryear}

%% AMA style
%\usepackage{numcompress}\bibliographystyle{model6-num-names}

%% `Elsevier LaTeX' style
\bibliographystyle{elsarticle-num}
%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \usepackage{etex}%use this package to avoid errors when including package `tikz-timing'.
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

    \usepackage{graphicx}
    %
    % \usepackage{mathptmx}      % use Times fonts if available on your TeX system
    %
    % insert here the call for the packages your document requires
    %\usepackage{latexsym}
    % etc.
    %
    % please place your own definitions here and don't use \def but
    % \newcommand{}{}
    %
    % Insert the name of "your journal" with
    % \journalname{myjournal}
    %
    \usepackage{epstopdf}

        %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    \usepackage{amssymb}
    \usepackage{amsmath}
    \usepackage{amsthm} %for theorem proof
    \allowdisplaybreaks %allowing page breaks
        \usepackage{cases}
        \usepackage{stmaryrd}
        \usepackage{pgf}

        \usepackage{tikz}

    \usetikzlibrary{automata}
    \usetikzlibrary{shapes}
    \usetikzlibrary{arrows,calc,fit}
    \usetikzlibrary{snakes}
    \tikzset{line/.style={draw, thick, -latex'}}

    % Two Colored Circle Split
    \makeatletter
    \tikzset{circle split part fill/.style  args={#1,#2}{%
     alias=tmp@name,
      postaction={%
        insert path={
         \pgfextra{%
         \pgfpointdiff{\pgfpointanchor{\pgf@node@name}{center}}%
                      {\pgfpointanchor{\pgf@node@name}{east}}%
         \pgfmathsetmacro\insiderad{\pgf@x}
          \fill[#1] (\pgf@node@name.base) ([xshift=-\pgflinewidth]\pgf@node@name.east) arc
                              (0:180:\insiderad-\pgflinewidth)--cycle;
          \fill[#2] (\pgf@node@name.base) ([xshift=\pgflinewidth]\pgf@node@name.west)  arc
                               (180:360:\insiderad-\pgflinewidth)--cycle;
             }}}}}
     \makeatother


     \usepackage[justification=centering]{caption}
        %alread have \usepackage{amssymb}
        %\usepackage{amsthm}
        \usepackage{framed,multicol}
        \usepackage{enumerate}
        \usepackage{makecell}
        \usepackage{listings} %for adding source code
        %\usepackage{multicol}
        %\usepackage{wrapfig}
        %\usepackage{subcaption}
        %\usepackage{hyperref}
        %for table
        \usepackage{enumitem}
        \usepackage{booktabs}
        %\usepackage{multirow}
        \usepackage{pbox}

        \usepackage{extarrows}

        \usepackage{float}

        %algorithm
        \usepackage{algorithm}
        %\usepackage{algorithm2e}
        %\usepackage{algorithmic}
        \usepackage[noend]{algpseudocode}
        \makeatletter
        \renewcommand{\ALG@beginalgorithmic}{\footnotesize}
        \makeatother

        %wideparen
        \usepackage{yhmath}
        %\usepackage{makecell}
        %tikzpicture
        %package for proof
        \usepackage{proof}
        %package for tables:
        \usepackage{multirow}

        \usetikzlibrary{arrows,automata,positioning}


        %for mathematics definition, theorem and proof
        \newtheorem{definition}{Definition}[section]
        \newtheorem{theorem}{Theorem}[section]
        \newtheorem{lemma}{Lemma}[section]
        \newtheorem{proposition}{Proposition}[section]
        \newtheorem{cor}{Corollary}[section]
        \newtheorem{example}{Example}[section]
        %\newtheorem{proof}{proof}
        %\newtheorem{note}{Note}[definition]

        \renewcommand{\labelenumi}{\arabic{enumi}. }
        \renewcommand{\labelenumii}{\labelenumi\alph{enumii}) }
        \renewcommand{\labelenumiii}{\labelenumii\roman{enumiii}: }

        \newcommand{\rNum}[1]{\expandafter{\romannumeral #1\relax}}
        \newcommand{\rNUM}[1]{\uppercase\expandafter{\romannumeral #1\relax}}

        \newcommand{\xian}{\noindent\rule{88mm}{0.2pt}}

        \newcommand{\fred}[0]{\color{red}}
        \newcommand{\bff}[1]{\mathbf{#1}}
        \newcommand{\mbb}[1]{\mathbb{#1}}
        \newcommand{\mcl}[1]{\mathcal{#1}}
        \newcommand{\mfr}[1]{\mathfrak{#1}}
        \newcommand{\spc}[1]{\begin{spacing}{#1}}
        \newcommand{\spce}{\end{spacing}}
        \newcommand{\quan}[1]{\textcircled{\small{#1}}}
        \newcommand{\rsqarrow}[0]{\rightsquigarrow}
        \newcommand{\laright}[0]{\looparrowright}
        \newcommand{\la}[0]{\langle}
        \newcommand{\ra}[0]{\rangle}

        \DeclareCaptionFont{tiny}{\tiny}

        %自动换行
        \newcommand{\tabincell}[2]{\begin{tabular}{@{}#1@{}}#2\end{tabular}}

        \tikzset{
        vertex/.style = {
            circle,
            fill            = black,
            outer sep = 2pt,
            inner sep = 1pt,
            }
        }

        %math symbol abbreviations
        \newcommand{\Ts}[0]{\mcl{T}\mcl{S}}
        \newcommand{\Nt}[0]{(\mcl{N},\nu)}
        \newcommand{\pr}[0]{\prime}

        %Special Names Abbreviations
        \newcommand{\SEP}[0]{SEP}

        %other abbreviations
        \newcommand{\vs}[0]{\vspace{5mm}}
            \newcommand{\cet}[1]{\begin{center}#1\end{center}}
        \newcommand{\lal}[1]{\begin{flushleft}#1\end{flushleft}}


        %formulae in paper
        \newcommand{\ch}[3]{#2 <\!\! #1 \!\!> #3}
            \newcommand{\cha}[2]{#1~\Box~#2}
        \newcommand{\chn}[2]{#1\sqcap#2}
        \newcommand{\para}[4]{#1 ~_#2\!\!\parallel_#3 #4}
        \newcommand{\agpara}[1]{\underset{#1}{\arrowvert}}
    %
        %circle numberingf
        %\newcommand*\circled[1]{\tikz[baseline=(char.base)]{
        %        \node[shape=circle,draw,inner sep=1pt] (char) {\tiny#1};}}
        \newcommand{\circled}[1]{\textcircled{{\tiny#1}}}
    %\newcommand{\envelope}{(corresponding author)}
    % if you have access to the marvosym font use its envelope symbol
    \usepackage{marvosym}
    \newcommand{\envelope}{(\raisebox{-.5pt}{\scalebox{1.45}{\Letter}}\kern-1.7pt)}
    %for inference rules
    \usepackage{proof}

    %math font
    \usepackage{mathrsfs}

    %tikz timing table
    \usepackage{tikz-timing}

    %subfigure
    \usepackage{subfigure}

    %calculate the height of a alphabet
    \usepackage{calc}

    %high light the citation
     %\usepackage{hyperref}

    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %new command in this paper
    \newcommand{\ISCDL}[0]{}
    \newcommand{\OISCDL}[0]{\mfr{I}_{scdl}}

    %clock and action
    \newcommand{\CC}[0]{a^c}
    \newcommand{\A}[0]{\CC}
    \newcommand{\Ac}[1]{a^{#1}}
    \newcommand{\NA}[0]{\bar{\C}}
    \newcommand{\Nc}[1]{\bar{#1}}
    \newcommand{\act}[0]{\mathit{b}}
    \newcommand{\com}[0]{|}
    \newcommand{\sig}[0]{\varsigma}
	\newcommand{\emset}[0]{\{\}}
	
    %substitution
    \newcommand{\sub}[0]{/\!\!/}
    \newcommand{\subs}[0]{\backslash}
    %clock definition
    \newcommand{\cdf}[0]{\mathbf{Cdf}}
    \newcommand{\rel}[0]{\mathbf{Rel}}
    \newcommand{\nneg}[0]{\mathop{\sim}}
    \newcommand{\Rel}[0]{\xi}
    \newcommand{\VarC}[0]{\mathit{RVar}(\mcl{C})}
    \newcommand{\Var}[0]{\mathit{Var}}
    \newcommand{\Sig}[0]{\mathit{Sig}}
    \newcommand{\SigMap}[0]{\mathit{SigM}}
    \newcommand{\ssig}[1]{\sig^{#1}}
	\newcommand{\RRel}{\mathit{Rel}}
	\newcommand{\Spec}{\mathit{Spec}}
	\newcommand{\Cdf}[0]{\mathit{Cdf}}
	\newcommand{\ccdf}[0]{\mathit{cdf}}
	
	\newcommand{\Fil}[0]{\mathit{Fil}}
	\newcommand{\Fee}[0]{\mathit{Fee}}
	\newcommand{\DF}[0]{\mathit{DF}}
    %programs

    %program, formula definition
    \newcommand{\sq}[0]{\rho}
    \newcommand{\pl}[0]{\cap}
    \newcommand{\trecset}[0]{\tau}
    \newcommand{\conn}[0]{\circledcirc}
    \newcommand{\Encode}[1]{(#1)^E}
    \newcommand{\var}[0]{\nu}
    \newcommand{\ary}[0]{\nu}
    \newcommand{\halt}[0]{\ddag}
    \newcommand{\locv}[1]{\{#1\}.}
    \newcommand{\oor}[0]{\veebar}
    \newcommand{\aand}[0]{\barwedge}
    \newcommand{\lup}[0]{\bullet}
    \newcommand{\ilup}[0]{\omega}
    \newcommand{\sstar}[0]{*}
    \newcommand{\fstar}[0]{+}
    \newcommand{\ppi}[0]{\pi}
    \newcommand{\trec}[0]{\mathit{trec}}
    \newcommand{\Commu}[0]{\mathit{Com}}
    \newcommand{\ACommu}[0]{Com}
	\newcommand{\Evt}[0]{\mathit{Evt}}
	\newcommand{\prog}[0]{\mathbf{Prog}}
	
	
    \newcommand{\iif}[0]{\mathit{if}\ }
    \newcommand{\then}[0]{\ \mathit{then}\ }
    \newcommand{\ddo}[0]{\ \mathit{do}\ }
    \newcommand{\els}[0]{\ \mathit{else}\ }
    \newcommand{\await}[0]{\mathit{wait}\ }
    \newcommand{\elsif}[0]{\ ::\ }
    \newcommand{\waitcase}[0]{\mathit{wait}\ }
    \newcommand{\ccase}[0]{\ ::\ }
    \newcommand{\present}[0]{\ \mathit{pres}\ }
    \newcommand{\negf}[0]{\mathit{Neg}}

    \newcommand{\SESP}[0]{SESP}
    \newcommand{\SEPP}[0]{SEP}
    \newcommand{\oSEPP}[0]{Omega-SEP}
    \newcommand{\CDL}[0]{sCDL}
    \newcommand{\CDLP}[0]{CDL}
    \newcommand{\SeqCDL}[0]{SCDL}
    \newcommand{\psSEP}[0]{ps-SEP}

    %program equal
    \newcommand{\peq}[0]{\equiv}
    \newcommand{\ppstar}[1]{{#1}^{*\triangleleft}}
    \newcommand{\esep}[1]{{#1}^{\triangleleft}}
    \newcommand{\pstar}[1]{{#1}^{\star\triangleleft}}
    \newcommand{\pomega}[1]{{#1}^{\omega\triangleleft}}
    \newcommand{\Auto}[0]{\mcl{A}}
    \newcommand{\Ptn}[0]{\Xi}
    \newcommand{\Init}[0]{I}
    \newcommand{\Final}[0]{\mcl{F}}
    \newcommand{\Trans}[0]{\mcl{T}}
    \newcommand{\Cur}[0]{\Upsilon}
    \newcommand{\DL}[0]{\halt}
    \newcommand{\mmerge}[0]{\mathit{Mer}}
    \newcommand{\match}[0]{\mathit{Mat}}
    \newcommand{\pos}[0]{\bff{pos}}
    \newcommand{\ssub}[0]{\mathit{Sub}}
    \newcommand{\dvar}[0]{\mcl{V}}
    %\newcommand{\st}[1]{\lfloor #1\rfloor}
    \newcommand{\st}[1]{ #1}
    \newcommand{\fnl}[1]{(#1)^e}
    \newcommand{\Trac}[0]{Trac}
    %heap, function
    \newcommand{\loc}[1]{\lfloor #1 \rfloor}
    \newcommand{\lmap}[2]{#1\mapsto #2}
    \newcommand{\llmap}[2]{(#1\mapsto #2)}
    %\newcommand{\sep}[0]{\between}
    %\newcommand{\hpseq}[2]{#1:#2}
    \newcommand{\hpseq}[2]{#1}
    %\newcommand{\hprel}[0]{\Theta}
    %\newcommand{\sep}[0]{}
    %\newcommand{\hpseq}[0]{}
    \newcommand{\hprel}[0]{}
    \newcommand{\cons}[0]{\bff{new}}
    \newcommand{\rmv}[0]{\bff{rmv}}
    \newcommand{\apd}[0]{\triangleright}
    \newcommand{\heq}[0]{\triangleleft}
    %case
    \newcommand{\cse}[0]{\mathbf{if}}
    \newcommand{\oth}[0]{\mathbf{else}}
    %operators
    \newcommand{\cat}[0]{\bullet}
    \newcommand{\vcat}[0]{:}
    \newcommand{\cho}[0]{\sqcup}
    \newcommand{\opt}[0]{\cdot}
    \newcommand{\red}[0]{\rsqarrow}
    \newcommand{\ded}[0]{\hookrightarrow}
    \newcommand{\rwt}[1]{#1}
    \newcommand{\rwtp}[1]{(#1)}
    \newcommand{\pcd}[2]{#1::#2}
    \newcommand{\pcdp}[2]{(#1::#2)}
    \newcommand{\IF}[0]{\Lleftarrow}
    \newcommand{\btriangleleft}[0]{\bar{\triangleleft}}
    \newcommand{\Els}{else}
    %items
    \newcommand{\rmn}[1]{(\romannumeral#1)}
    \newcommand{\rul}[1]{$(#1)$}
    %inference
    \newcommand{\mscdl}[0]{\models_{cdl}}
    \newcommand{\mcdl}[0]{\models_{cdl}}
    \newcommand{\mscdlf}[0]{\models_{cdl}}
    \newcommand{\mcdlf}[0]{\models_{cdl}}
    \newcommand{\dscdl}[0]{\vdash_{cdl}}
    \newcommand{\dcdl}[0]{\vdash_{cdl}}
    \newcommand{\dscdlf}[0]{\vdash^+_{cdl}}
    \newcommand{\dcdlf}[0]{\vdash^+_{cdl}}
    \newcommand{\state}[0]{w}
    \newcommand{\seq}[0]{\state}
    \newcommand{\Lan}[0]{\mcl{L}}
    \newcommand{\ellip}[0]{......}
    \newcommand{\sequent}[0]{证明序列}%(sequent)
    \newcommand{\place}[0]{\_}
    \newcommand{\communicate}[0]{\mathit{Inter}}
    \newcommand{\Equal}[0]{\mathit{Equal}}
    \newcommand{\Transf}[0]{\mathit{Trans}}
    \newcommand{\Tag}[0]{\mathit{Tag}}
    \newcommand{\Exp}[0]{\mathit{Exp}}
    \newcommand{\Solv}[0]{\mathit{Solv}}
    \newcommand{\Acommunicate}[0]{Inter}
    \newcommand{\AEqual}[0]{Equal}
    \newcommand{\ATransf}[0]{Trans}
    \newcommand{\ATag}[0]{Tag}
    \newcommand{\AExp}[0]{Exp}
    \newcommand{\ASolv}[0]{Solv}
    \newcommand{\mmcdl}[0]{\Vdash}
    \newcommand{\vv}[0]{g} %just to distinguish from v
    \newcommand{\qq}[0]{A}
    \newcommand{\Equ}[0]{\mcl{E}}
    %paper structure
    \newcommand{\Sect}[0]{Section}
    \newcommand{\Algo}[0]{Algorithm}
    \newcommand{\Example}[0]{Example}

    %formula
    \newcommand{\true}[0]{\bar{0}}
    \newcommand{\false}[0]{\bar{1}}
    \newcommand{\ff}[0]{\mathit{ff}}
    \newcommand{\cdlfmla}{\mathbf{Fmla}}

    %other constants
    %\newcommand{\Algo}[0]{Algo.}
    \newcommand{\Def}[0]{Def.}
    \newcommand{\eqc}[0]{\widehat}
    \newcommand{\ddef}[0]{::=}
    \newcommand{\dddef}[0]{=_{\mathit{df}}}

    %evaluation
    \newcommand{\eval}[0]{\mathit{Eval}}
	
	\newcommand{\val}[0]{\mathit{val}}
	
    %examples
    %digital filter

    %emphasis
    \newcommand{\emp}[1]{{\color{red} #1}}
    \newcommand{\clr}[1]{{\color{blue} #1}}
    \newcommand{\clrr}[1]{{\color{green} #1}}
    \newcommand{\clrrr}[1]{{\color{purple} #1}}

    %------------------------proof--------------------------------------------------
    \newcommand{\transl}[0]{\mathbf{Trans}}
    \newcommand{\CFOLS}[0]{\la \mcl{U}, 0, C, S, +, \cdot, \le\ra}
    \newcommand{\CPFOLS}[0]{\la \mcl{U}, 0, C, S, +, \le\ra}
    \newcommand{\AFOL}[0]{AFOL}
    \newcommand{\FODL}[0]{FODL}
    \newcommand{\QQFAFOL}[0]{QF-AFOL}
    \newcommand{\QFAFOL}[0]{QF-LAFOL}
    \newcommand{\RSEPP}[0]{Finite-SEP}
    \newcommand{\DDTL}[0]{DTDL}
    \newcommand{\finite}[0]{\mathit{finite}}
    \newcommand{\PL}[0]{PL}
    \newcommand{\IEl}[0]{\mathit{IEl}}
	\newcommand{\Len}{\mathit{Len}}
	\newcommand{\Iter}{\mathit{Iter}}
	\newcommand{\Theo}{Theorem}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %color contents
    \usepackage{xcolor}
    %\newcommand{\tagr}[1]{{\color{red} #1}}
    %\newcommand{\tagb}[1]{{\color{blue} #1}}
    \newcommand{\tagr}[1]{#1}
    \newcommand{\tagb}[1]{#1}
    \newcommand{\fb}[1]{{\color{blue} #1}}
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
    %%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%math operator
	\DeclareMathOperator{\ssharp}{\#}
	\DeclareMathOperator{\ddollar}{\$}
	\DeclareMathOperator{\paral}{\parallel}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	\lstnewenvironment{tabularlstlisting}[1][]
	{%
		\lstset{%aboveskip=-1.3ex,belowskip=-3.5ex,
			basicstyle=\scriptsize\sffamily, 
			%showstringspaces=false,
			columns=flexible,
			breaklines=true,
			tabsize=2,
			#1}%
	}
	{}

	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%symbols in Coq
	\newcommand{\coqlte}{'\!\!\!<=}
	\newcommand{\coqNeg}{'\!\!\!\sim}
	\newcommand{\coqAnd}{'\!\!/\backslash}
	\newcommand{\ntC}{\mathit{ntC}}
	\newcommand{\doubleslash}{/\!\!/}
	\newcommand{\tplace}{\mfr{p}}
	\newcommand{\Names}{\mfr{V}}
	\newcommand{\arw}{-\!\!>}
	%font for Coq
	%\usepackage{DejaVuSansMono}
	%% Another possibility is
	%% \usepackage{dejavu}
	%% which loads the DejaVu Serif and DejaVu Sans fonts as well
	%\renewcommand*\familydefault{\ttdefault} %% Only if the base font of the document is to be typewriter style
	%\usepackage[T1]{fontenc}
	
	\newcommand{\setsf}[1]{{\sffamily #1}}
	
	%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
	%general
	%\newcommand{\Sect}{Section}
	
\begin{document}

\begin{frontmatter}

\title{A Clock-based Dynamic Logic for the Verification of CCSL Specifications in Synchronous Systems}
%\tnotetext[mytitlenote]{Fully documented templates are available in the elsarticle package on \href{http://www.ctan.org/tex-archive/macros/latex/contrib/elsarticle}{CTAN}.}

%% Group authors per affiliation:
%\author{    \fnref{myfootnote}}
%\address{Radarweg 29, Amsterdam}
%\fntext[myfootnote]{Since 1880.}

%% or include affiliations in footnotes:
\author[address3,address4,address1]{Yuanrui Zhang}
\ead{zhangyrmath@126.com}

\author[address1]{Hengyang Wu}
%\ead{zhangyrmath@126.com}

\author[address1]{Yixiang Chen}

\address[address3]{School of Mathematics and Statistics, Southwest University}
\address[address4]{RISE, College of Computer \& Information Science, Southwest University}
\address[address1]{MoE Engineering Research Center for Software/Hardware Co-design Technology and Application,\\
East China Normal University, Shanghai 200062, China}
\address[address2]{University Cote d'Azur, CNRS, Inria, I3S, 06900 Sophia Antipolis, France}

\author[address2]{Fr\'ed\'eric Mallet\corref{cor}}
\cortext[cor]{Corresponding author}
\ead{Frederic.Mallet@inria.fr}

\begin{abstract}
The Clock Constraint Specification Language (CCSL) is a clock-based specification language for real-time embedded systems.  
	With logical clocks defined as a first-class citizen, CCSL provides a natural way for describing clock constraints in synchronous systems --- a special program model for 
	real-time embedded systems. %, where the time model is discrete. 
    %However, due to the limitations of the existing verification approaches,
    In this paper, we propose a clock-based dynamic logic called \emph{CCSL Dynamic Logic} (CDL) for the verification of CCSL specifications in synchronous systems.
    %It supports modelling synchronous systems in its program model and describing CCSL specifications in its logic.
    It extends first-order dynamic logic with a synchronous execution mechanism in its program model and with CCSL primitives as terms in its logical formulae.
    We build a sound and relatively complete proof system for CDL to support the verification. 
    Compared with previous approaches for verifying CCSL specifications, which are based on model checking and SMT checking techniques, our approach, which is based on theorem-proving, 
    offers a unified verification framework in which both bounded and unbounded CCSL specifications can be verified. 
    Technically, with the proof system of CDL, a complex CDL formula can be semi-automatically transformed into a set of quantifier-free, arithmetical first-order logic (QF-AFOL) formulae which can be checked by an SMT solver in an efficient way. 
    As a case study, we analyze a simple synchronous system throughout the paper to illustrate how CDL works.
    We analyze and prove the soundness and completeness of the proof system for CDL.
    Currently, CDL is partially mechanized in Coq. 
    

    \ifx
    for CDL as the verification support for CCSL.


    a unified framework under which both system behaviour and CCSL can be efficiently modelled

    which are mainly based on model checking, fail in providing a full verification support for all CCSL specifications.
    And the language lacks a unified framework in which the behaviour of RTESs

    are [problem with this word?undecidable], in the sense that: for model checking, only a subset of `bounded' CCSL specifications can be verified; for SMT solving,
    only finite configurations of a system model can be checked.
    To overcome these limitations we propose a verification framework for CCSL that combines logic inference and SMT check procedure.
    We propose an inference system for CCSL by embedding CCSL primitives into the logic framework of first-order dynamic logic, which results in
    a [second-order??] quantifier-free logic system.
    The inference procedure in fact translate the verification problem of CCSL specifications
    into the satisfaction problem of a quantifier-free, first-order logic formula over linear integer arithmetic, which is decidable and can be solved by an SMT solver.
    We give examples to show that our proposed verification approach can prove CCSL specifications which can not be verified by previous approaches.
    \fi
\end{abstract}

\begin{keyword}
Dynamic Logic\sep Clock Constraint Specification Language\sep Synchronous Systems \sep Verification \sep Theorem Proving
\MSC[2010] 00-01\sep  99-00
\end{keyword}

\end{frontmatter}

\linenumbers

\section{Introduction}
    \label{section: Introduction}
    The Clock Constraint Specification Language \cite{Mallet2008,Andre09} (CCSL) is a formal declarative language for specification of real-time embedded systems.
    It was first defined as an annex of UML/MARTE (as indicated in~\cite{OMG2009}, page 169) to supersede the UML profile for SPT~\cite{SPT}, but later developed as an independent language equipped with a formal semantics~\cite{Mallet2008}. 
    In CCSL, \emph{clock} is a primitive concept capturing a sequence of the occurrences of system events, while clock expressions capture the logical constraints between events. 
    For example, ``event $c_1$ always occurs before event $c_2$'' can be captured as a clock expression $c_1\prec c_2$ in CCSL (see \Sect~\ref{section: Preliminaries of CCSL}).  
    Clock constraints in CCSL are purely logical (i.e., irrelevant to explicit time values) and so are independent from the time model of a system. 
    Therefore, CCSL can be widely applied to specify the properties of clocks of different types of system models, such as MARTE models~\cite{OMG2009,DU201871}, timed automata~\cite{suryadevara13,Yin2011VMT,journals/jsa/ChenLZ18} and synchronous system models~\cite{conf/lctrts/AndreM09-CCSL_Esterel,CCSLSignal} (such as Signal~\cite{BENVENISTE1991103} and Esterel~\cite{BERRY199287}). 
    Especially in synchronous models, where the time model is discrete and each event is triggered at a lock step without time consumption, CCSL can serve as a clock calculus that can naturally capture the fundamental pure logical constraints between events. 
    Some typical examples of using CCSL in different system models can be found in \cite{OMG2009,DU201871,suryadevara13,Yin2011VMT,journals/jsa/ChenLZ18,conf/lctrts/AndreM09-CCSL_Esterel,CCSLSignal}, including the one used in this paper (see Example~\ref{example:Digital Filter System}). 
	
	
	
    Given a system model and a CCSL specification, the verification problem of the CCSL specification is to answer whether all behaviours of the system model satisfy the given CCSL specification~\cite{MALLET201578}.
    Previous approaches to the verification of CCSL specifications are mainly based on model checking~\cite{suryadevara13,Yin2011VMT,conf/lctrts/AndreM09-CCSL_Esterel,articleMallet,zhang14}, 
	where the main idea is to encode a system and a CCSL specification as finite transition systems, and make reachability analysis on their product. 
	Despite being fully automatic, one major problem is that it can only verify 
	CCSL specifications whose corresponding transition systems have a finite number of states (which we also call \emph{bounded CCSL specifications}~\cite{MalletMS13}).  
	In CCSL, however, even very simple constraints can be unbounded, such as the expression $c_1\prec c_2$ mentioned above. 
	Recently, a promising solution for verifying unbounded CCSL specifications was proposed~\cite{conf/icfem/ZhangMZ16,conf/lctrts/ZhangY17}, 
	where a specification is encoded as a logical formula that can be checked by an SMT solver. 
	But the problem with this method is that directly encoding CCSL as logical formulae would generate very complex formulae that contain quantifiers and functions (e.g., formula $\forall i\in \mbb{N}^+. \mcl{X}_\sigma(c_1, i)\ge \mcl{X}_\sigma(c_2,i)$), which are undecidable or can be costly for SMT solvers, especially when using existential quantifiers and uninterpreted functions. 
	
    Compared with model checking and SMT solving, theorem proving is a different method.
    It is not based on state space exploration and it supports well the verification of specifications 
    with infinite-state transition systems. 
    %whose transition systems possibly contain an infinite state space. 
    In this method, 
    logics like Hoare logic~\cite{Hoare63} and dynamic logic~\cite{journals/sigact/HarelKT01} provide the ability to describe program models, 
    so that a system and its specification can be described in a single logical form, such as a Hoare triple in Hoare logic and a formula of the form $[p]\phi$ (where $p$ is a program model, $\phi$ is a formula that describes a specification) in dynamic logic. 
    The verification of the specification can then be realized by transforming the logical form into a verification condition (which consists of a set of pure first-order logic (FOL) formulae) according to the syntactical structure of the program model.     
    In the verification of synchronous program models (such as Esterel programs~\cite{conf/lctrts/AndreM09-CCSL_Esterel}), 
    another advantage of taking theorem-proving-based approaches is that in the derivation the structure of the program model can be kept. 
    This is different from model-checking-based approaches where such information is lost since system models are expressed as finite transition systems. 
    With program structures, modular verification is possible for large-scale systems. 
    %Logics like dynamic logic~\cite{journals/sigact/HarelKT01} provide a modular way of transforming system models into relatively simple logic formulae, which %can then be efficiently tackled by SMT solvers.


In this paper, we focus on the verification of CCSL specifications in a special type of system models --- synchronous system models --- based on theorem proving. 
Specifically, we propose a variation of dynamic logic, called \emph{CCSL Dynamic Logic} (CDL), for specifying and verifying CCSL specifications in a synchronous system model. 
We propose a proof system for CDL and prove that it is sound and relatively complete to arithmetical first-order logic (AFOL) in the sense of~\cite{journals/siamcomp/Cook78} (which is also called \emph{relative completeness}). 
	Currently, we have mechanized a part of CDL in Coq~\cite{series/txtcs/BertotC04}. 
    CDL consists of a program model and a set of logical formulae to capture both the dynamic synchronous system behaviour and the static CCSL specification in the same language.
    It allows verifying both bounded and unbounded CCSL specifications in a single verification framework.
    %In CDL, a \emph{dynamic formula} $[p]\phi$/$[p]\Rel$ consists of a program ($p$) and a logical part (which could be another CDL formula $\phi$ or a CCSL relation term $\Rel$). 
    %Dynamic logic provides a program model and a logic to capture both the dynamic system behaviour and the static specification in the same language.
       
       Fig.~\ref{figure:Verification framework of CDL} shows this verification framework. 
       In contrast to the previous approaches~\cite{conf/icfem/ZhangMZ16,conf/lctrts/ZhangY17} which directly encode a CCSL specification as a relatively complex logical formula, CDL, as an intermediate language, 
       captures the verification problem of the specification as a formula $\phi$ of the form: $I\wedge I_c\to [\paral(p,q_1,...,q_n)]\Rel$. 
       By verifying this formula, the verification problem that whether the synchronous system model satisfies the specification can be solved. 
       In formula $\phi$, the synchronous system is modeled as a program $p$ in CDL, while the CCSL specification, which consists of a set of \emph{clock definitions} and a set of \emph{clock relations} (see \Sect~\ref{section: Preliminaries of CCSL}), is modeled as programs $q_1,...,q_n$ and a term $\Rel$  in CDL (with $q_1,...,q_n$ modeling the clock definitions and $\Rel$ modeling the set of clock relations respectively);
       the operator $\paral$ combines the programs $p, q_1,...,q_n$ so that they can run concurrently;
       $I\wedge I_c$ is an initial condition of all variables in the programs $p,q_1,...,q_n$. 
       Formula of the form $[q]\Rel$ means that all execution traces of program $q$ satisfies term $\Rel$.  
       %The formula $\phi$ means `under an initial condition $I\wedge I_c$, all execution traces of the program $\paral(p,q_1,...,q_n)$ satisfy $\Rel$'. 
       To verify the formula $\phi$, 
       we transform it into a set of pure FOL formulae (which in our case are quantifier-free arithmetical first-order logic (QF-AFOL) formulae) through the proof system of CDL in a modular way.
       These formulae contain no quantifiers and functions so that they can be checked by an SMT solver~\cite{BarFT-RR-17} in an efficient way compared to the previous approaches.
       %where as Fig.~\ref{figure:Verification framework of CDL} shows, specification is transformed into Quantifier-free Arithmetical First-Order Logic (AFOL) formulae without functions through CDL proof system in a modular way.
    %These formulae can then be solved by an SMT-solving procedure in an efficient way.
    The whole transformation procedure is semi-automatic, and can be implemented by popular theorem provers such as Coq~\cite{series/txtcs/BertotC04} and Isabelle~\cite{Nipkow-Paulson-Wenzel:2002}.



    \tikzset{
	state/.style={
		rectangle,
		rounded corners,
		draw=black, semithick,
		minimum height=2em,
		minimum width=2em,
		inner sep=2pt,
		text centered,
	},
	state2/.style={
		rectangle,
		rounded corners,
		draw=black, semithick,
		dashed,
		draw=black, semithick,
		minimum height=2em,
		minimum width=2em,
		inner sep=2pt,
		text centered,
	},
	state3/.style={
		circle,
		draw=black, semithick,
		minimum height=2em,
		minimum width=2em,
		inner sep=2pt,
		text centered,
	},
	state4/.style={
		circle,
		draw=black, semithick,
		minimum height=1em,
		minimum width=1em,
		inner sep=2pt,
		text centered,
	},	
	statex/.style={
		rectangle,
		draw=black, semithick,
		dashed,
		draw=black, semithick,
		minimum height=1em,
		minimum width=1em,
		inner sep=1pt,
		text centered,
	},
	edge2/.style={
		snake=snake, semithick, segment amplitude=0.07cm, >=to
	},
	edge3/.style={
		snake=snake, semithick, segment amplitude=0.07cm, >=to
	},
		st1/.style={
			rectangle,
			%rounded corners,
			draw=black, semithick,
			minimum height=2em,
			minimum width=2em,
			inner sep=2pt,
			text centered,
		},
	st2/.style={
		ellipse,
		draw=black, semithick,
		minimum height=2em,
		minimum width=2em,
		inner sep=2pt,
		text centered,
	},
	st3/.style={
		rectangle,
		rounded corners,
		draw=black, semithick,
		minimum height=2em,
		minimum width=2em,
		inner sep=2pt,
		text centered,
	},
	st4/.style={
		rectangle,
		%rounded corners,
		draw=black, semithick,
		minimum height=1em,
		minimum width=2em,
		inner sep=1pt,
		text centered,
	},
}

\begin{figure}[!htb]
	\centering
	\scalebox{0.8}{
		\begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
		% Position of QUERY
		% Use previously defined 'state' as layout (see above)
		% use tabular for content to get columns/rows
		% parbox to limit width of the listing
		%\node[state, initial] (w0) {$\eqc{p_1}$};
		
		\node[st1] (s1) {$\begin{gathered}\mbox{synchronous system model}\\ (\mbox{with initial condition }I): \\p\end{gathered}$};
		\node[st1, right of = s1, xshift=6cm,yshift=0.75cm, draw=none] (s2) {$\begin{gathered}\mbox{CCSL specification}\\ (\mbox{with initial condition }I_c)\end{gathered}$ };
		\node[st1, below of=s2,yshift=0.5cm,xshift=-2cm] (s21) {$\begin{gathered}\mbox{clock definitions:}\\ q_1,...,q_n\end{gathered}$};
		\node[st1, below of=s2,yshift=0.5cm,xshift=2cm] (s22) {$\begin{gathered}\mbox{clock relations:}\\ \Rel\end{gathered}$};
		
		\node[st1, right of = s1, xshift=2cm, yshift=-4.5cm, fill=blue!50] (s3) {$\begin{gathered}\mbox{CDL formula $\phi$}: \\I\wedge I_c\to [\paral(p,q_1,...,q_n)]\Rel\end{gathered}$};
		\node[st2, right of= s1, xshift=2cm, yshift=-4.5cm-2cm, fill=blue!50] (s5) {CDL proof system};
		%\node[st1, xshift=1.25cm, yshift=-2.5cm] (s4) {CCSL rel};
		\node[st1, left of=s3, draw=none, yshift=-1cm,xshift=-2cm] (txt1) {our approach};
		\node[st1,draw=none, right of=s5, xshift=4cm] (txt2) {$\begin{gathered}\mbox{previous}\\\mbox{approaches}\end{gathered}$};
		
		\node[st1, right of= s1, xshift=2cm, yshift=-4.5cm-2cm-2cm, fill=green!50] (s6) {QF-AFOL formulae};
		\node[st1, right of=s3, xshift=2cm] (x1) {complex formula};
		\node[st2, below of=s6, yshift=1cm] (s7) {SMT solver};
		\node[st1, draw=none, below of=s7, yshift=1cm] (s8) {yes/no?};
		
		\node at ([yshift=-0.25cm]s2.south) (pp6) {};
		\draw [-] ([yshift=0.2cm]s2.south) -- ([yshift=-0.25cm]s2.south) -- (s21.north |- pp6) -- (s21.north);
		\draw [-] ([yshift=-0.25cm]s2.south) -- (pp6 -| s22.north) -- (s22.north);
		
		\draw [dashed] ([xshift=-0.25cm,yshift=0.25cm]s2.north -| s21.west) rectangle ([xshift=0.25cm,yshift=-0.25cm]s21.south -| s22.east);
		\node at ([xshift=-0.25cm,yshift=0.25cm]s2.north -| s21.west) (pp1) {};
		\node at ([xshift=0.25cm,yshift=-0.25cm]s21.south -| s22.east) (pp2) {};
		\draw[->] (s1.east -| pp1) -- node[below]{specify} (s1.east);
		
		\draw ([xshift=-0.25cm,yshift=0.25cm]pp1.west -| s1.west) rectangle ([xshift=0.25cm,yshift=-0.25cm]pp2);
		\node at ([xshift=0.25cm,yshift=-0.25cm]pp2) (pp5) {};
		%\draw (p1 -| s3.north) -- node [left] {expressed} (s3.north);
		
		
		\draw [rounded corners] ([xshift=-0.5cm, yshift=0.25cm]s3.north -| s3.west) rectangle ([xshift=0.5cm, yshift=-0.25cm]s3.east |- s5.south);
		\node at ([xshift=-0.5cm, yshift=0.25cm]s3.north -| s3.west) (p2) {};
		\draw (txt1.east) -- (p2 |- txt1.east);
		\node at ([yshift=0.25cm]s3.north) (pp4) {};
		\draw (pp4 |- pp5) -- node[right]{expressed as} (s3.north);
		
		%\draw ([yshift=0.25cm, xshift=-0.25cm]s1.north -| s1.west) rectangle ([yshift=-0.25cm, xshift=0.25cm]s2.east|-s2.south);
		\node at ([yshift=-0.25cm, xshift=0.25cm]s2.east|-s2.south) (p1) {};
		%\draw (p1 -| s3.north) -- node [left] {expressed} (s3.north);
		\draw [dashed] (x1.north |- pp2) -- node[right] {encoded as} (x1.north);
		\draw [dashed] (x1.south) -- (x1.south |- s7.east) -- (s7.east);
		%\draw([yshift=0cm, xshift=0cm]s1.south) -- ([yshift=-0.3cm, xshift=0cm]s1.south) -- ([yshift=-0.3cm, xshift=-0cm]s1.south -| s3.north) -- node [left, yshift=0.1cm] {expressed} ([xshift=-0cm, yshift=0cm]s3.north);
		%\draw[-](s2.south)--([yshift=-0.3cm, xshift=0cm]s2.south) -- ([yshift=-0.3cm, xshift=-0cm]s1.south -| s3.north);
		%\draw ([xshift=0.2cm, yshift=0.2cm]s3.south) -- node [left, xshift=0cm] {express}([xshift=0.2cm]s4.north);
		\draw[dashed, semithick] ([yshift=0.25cm, xshift=-0.75cm]s5.north -| s5.west) rectangle ([yshift=-0.5cm, xshift=1.5cm]s6.south -| s6.east);
		\node[st1, draw=none, left of=s6, xshift=-3cm] (s9) {Tool Support: Isabelle, Coq};
		\node at ([yshift=0.25cm, xshift=-0.75cm]s5.north -| s5.west) (pp3) {};
		\draw[->] (s9.east) -- (s9.east -| pp3);
		
		\draw[-] (txt2.west) -- ([xshift=0.2cm]txt2.west -| x1.south);
		
		
		
		
		%\draw[rounded corners] ([yshift=0cm, xshift=0cm]t5.south) -- ([yshift=0cm, xshift=0cm]t5.south |- t6.mid) -- node [above, xshift=1cm] {$\halt$} ([yshift=0cm, xshift=0cm]t6.east);
		%\node[state, below of=1, yshift=2cm, draw=none] (2) {Input: $R_1$\ \ Output: $R_6$};
		% draw the paths and and print some Text below/above the graph
		%\draw[dashed, thick, rounded corners, red] ([xshift=-0.25cm, yshift=0.3cm]1.mid -| 1.west) rectangle ([yshift=-0cm-0.25cm,xshift=0.25cm]0.south -| 0.east);
		%\draw[dashed, thick, rounded corners, red] (w1.south) -- ([yshift=0.3cm]1.mid -| w1.south);
		\path
		(s3) edge node {} (s5)
		(s5) edge node {} (s6)
		(s6) edge node {} (s7)
		(s7) edge node {} (s8)
		
		%(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
		;
		\end{tikzpicture}
		
		
	}%end scalebox
	
	\captionsetup{font=footnotesize}
	\caption{Verification framework of CDL}
	\label{figure:Verification framework of CDL}
\end{figure}

	Fig.~\ref{figure:An overview of CDL} shows an overview of CDL. It gives a picture of each part of the logic, its functionality and its relationship with CCSL and traditional \emph{first-order dynamic logic} (FODL)~\cite{books/sp/Harel79}. 
	%A dynamic logic consists of a program model that describes the behaviours of systems and a logical part that describes the specification of systems.
	The syntax of CDL is based on FODL. 
	On one hand, 
	the program model of CDL inherits from FODL the sequence operator $;$ and the choice operator $\cup$, and is extended with a synchronous execution mechanism that is supported by 
	several new features: \emph{signal}, \emph{combinational event}, \emph{infinite loop} and \emph{concurrent executions} (see \Sect~\ref{section: The Syntax and Semantics of CDL}). 
	On the other hand, 
	the logical formulae of CDL inherit from FODL the formulae of the form $[p]\phi$ that capture the \emph{state properties} of programs (see \Sect~\ref{section:First-Order Dynamic Logic}), and are extended with the formulae of the form $[p]\Rel$ in order to express CCSL specifications --- a type of \emph{temporal properties} of programs. 
	Clock relations $\RRel$ are embedded in the term $\Rel$, while clock definitions can be encoded as CDL programs. 
	
	\ifx
	It inherits the concept of \emph{signal} from synchronous programming languages such as Signal~\cite{BENVENISTE1991103} and Esterel~\cite{BERRY199287} as the synchronous communication abstraction and
	other primitives from the program model of FODL (like sequence, choice and loop) to express local computations and program controls.
	
	Technically, 
    CDL extends the traditional first-order dynamic logic \cite{books/sp/Harel79} (FODL) with a synchronous execution mechanism in its program model, and with CCSL primitives in its logical formulae.
    The program model of CDL has a synchronous semantics: the time model is discrete and at each time (also called `\emph{instant}'), several events can occur simultaneously.
	    It inherits the concept of \emph{signal} from synchronous programming languages such as Signal~\cite{BENVENISTE1991103} and Esterel~\cite{BERRY199287} as the synchronous communication abstraction and
    other primitives from the program model of FODL (like sequence, choice and loop) to express local computations and program controls.
    CDL supports parallel executions, as the main feature of synchronous systems.
    Clock relation $\RRel$ is embedded into dynamic formulae as the form `$[p]\RRel$' (Def.~\ref{definition: CDL Formula}) in order to express the clock-based specification.
    %: `all execution traces of program $p$ satisfy clock relation $Rel$'. %in order to express the clock specification of program $p$.
    Different from the traditional dynamic formula of the form $[p]\phi$ in FODL, the formula $[p]\RRel$ captures a type of \emph{temporal properties} of the program $p$.
    %As the semantics of process logic~\cite{}, the semantics of the program of CDL is based on traces.
    %With the concept of `clock' built in CDL as a primitive and a program model that supports synchronous behaviour,
    %These characteristics make CDL nature for expressing CCSL specifications of synchronous systems.
	\fi
	
    The proof system of CDL is mainly based on that of FODL, but enriched with rules for the new primitives introduced in CDL (see Table~\ref{table:Rules for path formulae} in \Sect~\ref{section: The Proof System of CDL}): the combinational events and the formulae of the form $[p]\Rel$.
    %Generally, dynamic logic does not directly support  reasoning about parallel programs.
    To reason about parallel programs, we propose rewrite rules (see Table~\ref{table:Rewriting rules for parallel SEP} in \Sect~\ref{section: The Proof System of CDL}) together with an automatic procedure (\Algo s~\ref{alg: Interaction Algorithm} - \ref{alg:Solv} in \Sect~\ref{section: The Proof System of CDL}). 
    These rules reduce a parallel program into a sequential one so that the rules for sequential programs can be applied. 
    Such a way for verifying parallel programs is specially suitable for synchronous models because the behaviour of a synchronous model is always deterministic~\cite{BERRY199287}, which means that
    any synchronous parallel program can always be reduced to only one sequential program. 
    %This procedure is important for the verification of parallel programs in practice.
    The procedure for proving a CDL formula in the proof system of CDL is semi-automatic, since it is generally undecidable to find a loop invariant in a program that is complex enough to express the Presburger arithmetic theory~\cite{journals/tocl/BlassG01}.
    %the procedure of choosing loop invariants in a program complex enough to express Presburger arithmetic theory is generally undecidable~\cite{journals/tocl/BlassG01}.
    %The proof system provides a semi-automatic verification procedure for CCSL specifications, where the only place that needs to be manually intervened is the choice of loop invariant.
    %These rules decompose a CDL formula into pieces which are easy for SMT-checking, according to the `structure' of the program model.
    %The proof system provides a modular way of verifying CCSL specifications by decomposing a CDL formula according to the `structure' of the program model.
    The proof system is proved to be sound and relatively complete (see \Sect~\ref{section: Soundness and Relative Completeness of CDL Proof System}).
    Essentially, as other dynamic logics, the expressiveness of CDL stays the same as AFOL in the domain of natural numbers~\cite{journals/sigact/HarelKT01}.

	
	\begin{figure}[!htb]
		\centering
		\scalebox{0.8}{
			\begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
			% Position of QUERY
			% Use previously defined 'state' as layout (see above)
			% use tabular for content to get columns/rows
			% parbox to limit width of the listing
			%\node[state, initial] (w0) {$\eqc{p_1}$};
			
			%cdl
			\node[st1,draw=none,fill=yellow!50] (c1) {CDL};
			\node[st1,draw=none, right of=c1, yshift=3cm, xshift=0cm, align=center] (c2) {CDL\\ language};
			\node[st1, right of=c1, yshift=-3cm, xshift=0cm, align=center, fill=blue!50] (c3) {CDL\\ proof System};
			
			\node[st1,right of=c2, yshift=1.75cm, xshift=2cm, align=center, text width=2.25cm, fill=blue!50] (c4) {CDL program \\ (SEP)};
			\node[st1,right of=c2, yshift=-1.75cm, xshift=2cm, align=center, text width=2.25cm, fill=blue!50] (c5) {CDL formula};
			
			\node[st1, right of=c2, yshift=1.75cm, xshift=2cm + 5.5cm, align=center] (c6) {FODL program:\\ $x:=e, p;q, p\cup q$};
			\node[st3, right of=c2, yshift=1.75cm+1.75cm, xshift=2cm + 2.75cm, align=center] (c7) {signal $\sig$,\\ combinational event $\alpha$,\\ $p^\lup, p\paral q$};
			
			\node[st1,right of=c2, yshift=-1.75cm, xshift=2cm+5.5cm, align=center] (c8) {FODL formula:\\ $tt, \neg\phi, \phi\wedge\varphi, \forall x.\phi, [p]\phi$};
			\node[st3,right of=c2, yshift=-1.75cm-1.5cm, xshift=2cm+2.75cm, align=center] (c9) {CDL formulae:\\ $[p]\Rel$};
			
			\node[st1, right of=c3, yshift=0cm, xshift=6cm, align=center] (c10) {FODL\\ proof system};
			\node[st3, right of=c3, yshift=1.5cm, xshift=1.75cm, align=center] (c11) {rules for special primitives, \\ rewrite rules for parallel SEPs};
			%\node[st1, right of=c3, yshift=0.5cm, xshift=3cm, align=center] (c11) {rules from FODL};
			%\node[st1, right of=c3, yshift=-0.5cm, xshift=3cm, align=center] (c12) {rules from traditional FOL};
			%\node[st1, right of=c3, yshift=-1.5cm, xshift=3cm, align=center] (c13) {rewrite rules for parallel SEPs};
			
			
			
			%ccsl
			\node[st1, draw=none, right of=c8, yshift=0cm, xshift=2.5cm, align=center,fill=yellow!50] (cc1) {CCSL};
			\node[st1, left of=cc1, yshift=2cm,align=center] (cc2)  {clock definition:\\ $c\triangleq E$};
			\node[st1, left of=cc1, yshift=-1.5cm,align=center] (cc3) {clock relation:\\ $\RRel$};
			
			\node[st1, draw=none, right of=c10, xshift=5cm, align=center,fill=yellow!50] (c12) {FODL};
			\node[st1, draw=none, above of=c12, yshift=3.5cm, align=center] (c13) {FODL\\ language};
					
					
			%contribution
			\node[st1, draw=none, right of=c2, xshift=0.5cm, align=center] (con1) {\rmn{1}\\ (\Sect~\ref{section: The Syntax and Semantics of CDL})};
			\node[st1, draw=none, right of=c2, xshift=5cm, yshift=-0.5cm, align=center] (con3) {\rmn{3}\\ (\Sect~\ref{section: The Encoding of CCSL Specification in CDL})};
			\node[st1, draw=none, right of=c1, xshift=2cm, yshift=0cm, align=center] (con2) {\rmn{2}(\Sect~\ref{section: The Proof System of CDL} and \ref{section: Soundness and Relative Completeness of CDL Proof System}), \\ \rmn{4}(\Sect~\ref{section:Mechanization of CDL in Coq})};
			
			%specification
			\node[st4, above of=c2, yshift=1cm, xshift=0cm, align=center] (model) {synchonous system};
			\node[st4, above of=c2, yshift=1cm-0.5cm, xshift=0cm, align=center] (spec) {CCSL specification};
						
			%draw
			\draw [-] (c1.east) -- ([xshift=0.5cm]c1.east) -- ([xshift=0.5cm]c1.east |- c2.west) -- (c2.west);
			\draw [-] ([xshift=0.5cm]c1.east) -- ([xshift=0.5cm]c1.east |- c3.west) -- (c3.west);
			
			\draw [-] (c2.east) -- ([xshift=1cm]c2.east) -- ([xshift=1cm]c2.east |- c4.west) -- (c4.west);
			\draw [-] ([xshift=1cm]c2.east) -- ([xshift=1cm]c2.east |- c5.west) -- (c5.west);
			
			\draw [=<, dashed] (c6.west) -- node[below] {is the base of} (c4.east);
			\draw [-,dashed] (c7.south) -- node[right,yshift=0.25cm] {new features} (c7.south |- c4.east);
			
			\draw [=<, dashed] (c8.west) -- node[above] {is the base of} (c5.east);
			\draw [-,dashed] (c9.north) -- node[right,yshift=-0.25cm] {new features} (c9.north |- c8.west);
			
			\draw [=<, dashed] (cc3.west) -- node[above] {embedded in} (c9.east);
			\draw [=<] (cc2.north) -- ([yshift=0.25cm]cc2.north) -- node[below, fill=blue!50] {encoded as} ([yshift=0.25cm]cc2.north -| c4.south) -- (c4.south);
			
			\draw [-] (cc1.west) -- ([xshift=-0.5cm]cc1.west) -- ([xshift=-0.5cm]cc1.west |- cc2.east) -- (cc2.east);
			\draw [-] ([xshift=-0.5cm]cc1.west) -- ([xshift=-0.5cm]cc1.west |- cc3.east) -- (cc3.east);
			
			%\draw [=<, dashed] (cc1.north) -- (cc1.north |- c7.east) -- node [below] {synchronous execution mechanism} node[above]{inherit from} (c7.east);
			
			\draw [-] (c13.south) -- ([yshift=-1.6cm]c13.south) -- ([yshift=-1.6cm]c13.south -| c8.east);
			\draw [-] (c13.north) -- (c13.north |- c6.east) -- (c6.east);
			\draw [-] (c12.east) -- ([xshift=0.27cm]c12.east) -- ([xshift=0.27cm]c12.east |- c13.east) -- (c13.east);
			\draw [-] (c12.west) -- (c10.east);
			
			\draw [=<, dashed] (c10.west) -- node[below]{} (c3.east);
			\draw [-,dashed] (c11.south) -- node[right]{new rules} (c11.south |- c10.west);
			
			\draw [=<, dashed] ([xshift=0.5cm]c4.south) -- node{embedded in} ([xshift=0.5cm]c5.north);
			\draw [=<, dashed] ([xshift=0.5cm]c6.south) -- node[right,yshift=-0.75cm]{embedded in}([xshift=0.5cm]c8.north);
			\draw [=<, dashed] (c3.north) -- node[left] {proves} (c2.south);
			
			\draw [-] ([xshift=-0.2cm,yshift=0.2cm]model.north -| model.west) rectangle ([xshift=0.2cm, yshift=-0.2	cm]spec.east |- spec.south);
			
			\draw [=<, dashed] (c4.north) -- (c4.north |- model.east) -- node [below] {expresses} (model.east);
			\draw [=<, dashed] ([yshift=0.15cm]c5.west) -- ([yshift=0.15cm, xshift=1cm]c5.west -| spec.south) -- node[left,yshift=1cm]{expresses}([yshift=-0.2cm, xshift=1cm]spec.south);
			\draw [=<, dashed] ([xshift=0cm]cc1.north) -- ([xshift=0cm, yshift=0.5cm]c7.north -| cc1.north) -- node[above]{expresses} ([yshift=0.5cm,xshift=0.4cm]c7.north -| spec.east) -- ([xshift=0.4cm]spec.east) -- (spec.east);
			
			\draw [-, dashed] ([xshift=0cm]con1.north) -- ([xshift=-0.75cm]c4.south);
			\draw [-, dashed] (con1.south) -- ([xshift=-0.75cm]c5.north);
			\draw [-, dashed] ([xshift=0.25cm]con3.north) -- ([xshift=0.25cm+0.5cm,yshift=0.5cm]con3.north);
			\draw [-, dashed] ([xshift=-0.25cm]con2.south) -- ([xshift=0.5cm]c3.north);
			\draw [=<, dashed] (c7.north) -- ([yshift=0.75cm]model.north -| c7.north) -- node[below]{introduced from} ([yshift=0.75cm]model.north) -- (model.north);
			%(model.north) -- ([yshift=0.75cm]model.north) -- node[below]{introduced from} ([yshift=0.75cm]model.north -| c7.north) -- (c7.north);
			
			\end{tikzpicture}
			
			
		}%end scalebox
		
		\captionsetup{font=footnotesize}
		\caption{An overview of CDL}
		\label{figure:An overview of CDL}
	\end{figure}

    The work in this paper is mainly based on and extends~\cite{zhang:hal-01929184}, where a primary version of CDL was proposed.
    That primary CDL only supports verifying simple CCSL clock relations.
    When a specification contains clock definitions, it cannot be directly expressed in the primary CDL because it does not support parallel programs.
    We extend the primary CDL with a parallel operator and its related rewrite rules in the proof system.
    This extension is essential, considering the application domain, as well as non-trivial, as we show here, but could not be achieved in limited length without the foundations defined in \cite{zhang:hal-01929184}.
    In this paper we also give a full analysis of the soundness and completeness of CDL.

	In summary, the main contributions of this paper are listed as follows (shown in Fig.~\ref{figure:An overview of CDL}):
	\begin{enumerate}[label=(\roman*)]
		\item We define the syntax and semantics of CDL. 
		\item We propose a proof system for CDL, and analyze its soundness and completeness. 
		\item We show how to express CCSL specifications in CDL by proposing an encoding of the clock definitions of CCSL as the programs of CDL. 
		\item We mechanize a part of CDL, which consists of all formulae that contain the rules for \emph{sequential SEPs} (i.e., all rules in Table~\ref{table:Rules for path formulae}, \ref{table:Rules for non-path formulae} and \ref{table: Rules for first order logic} in \Sect~\ref{section: The Proof System of CDL}) but no parallel SEPs, in Coq. 
	\end{enumerate}

The rest of this paper is organized as follows:
\Sect~\ref{section:Preliminaries} gives a general background to CCSL.
\Sect~\ref{section: The Syntax and Semantics of CDL} introduces the syntax and semantics of CDL.
%Sect.~\ref{section: The Encoding of CCSL Specification in CDL} focuses on the encoding of CCSL specifications in CDL logic.
In \Sect~\ref{section: The Proof System of CDL}, we propose a proof system for CDL.
In \Sect~\ref{section: The Encoding of CCSL Specification in CDL}, we show how to express a CCSL specification in CDL.
\Sect~\ref{section: Soundness and Relative Completeness of CDL Proof System} analyzes the soundness and completeness of CDL.
%In Sect.\ref{section:A Case Study}, we give a simple case study to show how CDL can express and verify CCSL verification problems.
%and show that the verification problem which cannot be fully checked with previous approaches can be verified in our CDL logic system.
%In Sect.~\ref{section: Soundness and Relative Completeness of CDL Proof System} we analyze the soundness and completeness of CDL proof system.
In \Sect~\ref{section:Mechanization of CDL in Coq}, we mechanize a part of CDL using Coq and illustrate how a CDL formula can be proved in Coq through a small example. 
\Sect~\ref{section: Related Works} discusses related work.
\Sect~\ref{section: Conclusion and Future Work} concludes this paper and discusses future work.

    \ifx
    CDL is not the only dynamic logic for real-time systems.



    actually provides an insight of
    %As finding a schedule given a CCSL specification is generally an undecidable problem~\cite{},

    for every configuration of clocks we get a set of solutions by solving the BDD structure of a CCSL specification, then we pick one solution and update the BDD

    The core idea is that for every configuration we solve a BDD structure to encode each clock constraint into a logic formula, expressed as a BDD structure, based on the current configuration of clocks.


    To verify whether a CCSL specification is satisfied by a system model \cite{} proposes encoding CCSL into the system model.
    The transformation principle varies according to different types of models.
    e.g., in \cite{}, CCSL was encoded into

    The formal analysis of CCSL mainly focuses on two aspects: schedule analysis and verification.
    The former is to find a schedule (or a set of schedules) that satisfies a CCSL specification,
    and the latter, as discussed in this paper, is to check if a given system model satisfies a CCSL specification.


    The earliest approach for schedule analysis was proposed in \cite{}, provided as a theoretical support for a simulation tool of CCSL---Timesquare~\cite{}.
    %In this approach, the history of all clocks forms the current state.
    It combines the BDD-based solver and the rewriting on clock constraints.
    The core idea is to encode each clock constraint into a quantifier-free logic formula, expressed as a BDD structure, based on the current configuration of clocks.
    By solving this BDD a set of solution is obtained.
    We pick one solution and update the BDD structure by doing the rewriting for each clock constraint.
    Then we solve this new BDD again....
    By repeating this procedure we can obtain a schedule of the constraints.

    Schedule analysis is very useful when CCSL is used to coordinate the behaviour of system models from different domains,
    where we need to check

    Previous approaches for formal analysis of CCSL are mainly based on SMT-solving and model checking.


    There are two main aspects of the verification of CCSL: given a set of CCSL constraints, 1. whether a schedule exists that satisfy it; 2. whether a system model satisfies it.

    The verification problems of CCSL mainly focus on two aspects:

    [] proposed an SMT approach for solving CCSL constraints.
    \fi


    \section{The Clock Constraint Specification Language (CCSL)}
    \label{section:Preliminaries}
    \subsection{Syntax and Semantics of CCSL}
    \label{section: Preliminaries of CCSL}
        We present the syntax and semantics of CCSL based on \cite{MALLET201578,conf/icfem/ZhangMZ16}.
    %In CCSL, a logical clock is in fact a boolean valued signal in synchronous models.
    %It models a sequence of occurrences of a signal.
	
	In synchronous systems, a CCSL clock captures a sequence of the occurrences of a signal. 
	A \emph{tick} of a clock indicates an occurrence of its corresponding signal. 
	We often use $c$ to denote a clock, and use $\mcl{C}$ to denote a finite set of clocks. 
	A \emph{clock schedule} $\sigma : \mbb{N} \to 2^{\mcl{C}}$ defines one possible arrangement of all clocks over a discrete timeline (where $\mbb{N} = \{0,1,2,...\}$ is the set of natural numbers), 
	where each clock either ticks or does not tick at each time step $i\in \mbb{N}$ (also called \emph{instant}). 
	We define $c\in \sigma(i)$ iff clock $c$ ticks at instant $i\in \mbb{N}$.
	We assume $\sigma(0)=\emptyset$, indicating that no clock ticks at the beginning of the timeline.
 	A configuration $\mcl{X}_{\sigma}:\mcl{C}\times \mbb{N}\to \mbb{N}$ keeps track of the number of ticks of all clocks up to the current instant $i\in \mbb{N}$ of a schedule $\sigma$.
	It is defined as 
	$$\mcl{X}_\sigma(c, i)\dddef \left \{
	\begin{array}{ll}
	0, &\mbox{if $i=0$}\\
	\mcl{X}_\sigma(c, i-1) + 1,  &\mbox{if $i>0$ and $c\in \sigma(i)$}\\
	\mcl{X}_\sigma(c, i-1), &\mbox{if $i>0$ and $c\notin \sigma(i)$}
	\end{array}
	\right..$$
	
	There are two types of clock expressions in CCSL: clock relations and clock definitions. 

    Clock relations describe binary relationships between clocks.
    The syntax of clock relations is defined as follows:
    $$\RRel\ddef c_1\subseteq c_2\ |\ c_1\ssharp c_2\ |\ c_1\prec c_2\ |\ c_1\preceq c_2, $$
    where $c_1$ and $c_2$ are clocks.
    The semantics of a clock relation is defined as the set of clock schedules satisfying it, shown as the items 1-4  in Table~\ref{table:semantics of CCSL}, where
    $\mbb{N}^+ = \mbb{N} - \{0\}$. 
    \emph{Subclock} says that $c_1$ can only tick if $c_2$ ticks;
    \emph{Exclusion} says that $c_1$ and $c_2$ cannot tick at the same instant;
    \emph{Precedence} means that $c_1$ always ticks faster than $c_2$;
    \emph{Causality} expresses that $c_1$ ticks not slower than $c_2$.
    \ifx
    Fig.~\ref{figure:figure2} shows a possible schedule of these relations, where $b$ is a basic clock which represents the minimal granularity of time.
    \begin{figure}[h!]
        \includegraphics[width=1\textwidth]{figures/figure2}	
        \caption{A possible schedule of each clock relation}
        \label{figure:figure2}
    \end{figure}
    \fi

For example, the leftmost figure of Fig.~\ref{figure:A possible schedule of selected clock definition} shows a possible schedule $\sigma$ (starting from the instant $1$) that satisfies the clock relation $c_1\prec c_2$,
where
\ifx 
clock
$$\begin{aligned}
%&b = tick\ tick\ tick\ tick\ tick\ tick\ tick\ tick\ tick\ tick\ tick\ tick\ ...,\\
&c_1 = tick\ \fb{idle}\ tick\ tick\ \fb{idle}\ \fb{idle}\ tick\ \fb{idle}\ \fb{idle}\ tick\ \fb{idle}\ \fb{idle}\ ...,\\
&c_2 = \fb{idle}\ tick\ \fb{idle}\ tick\ \fb{idle}\ \fb{idle}\ tick\ tick\ \fb{idle}\ \fb{idle}\ tick\ \fb{idle}\ ...;
\end{aligned}$$
\fi
%For better comparison, we define $b$ as a clock whose is a `based clock' representing the minimal granularity of time.
$$\sigma = \emset\{c_1\} \{c_2\} \{c_1\} \{c_1,c_2\} \emset \emset \{c_1,c_2\} \{c_2\} \emset \{c_1\} \{c_2\} \emset....$$
We use `$\{\}$' to mean an empty set $\emptyset$. 
The configuration $\mcl{X}_\sigma$ satisfies $\mcl{X}_\sigma(c_1,1) = 1$, $\mcl{X}_\sigma(c_1,2) = 1$, $\mcl{X}_\sigma(c_1,3) = 2$,
$\mcl{X}_\sigma(c_2,1) = 0$ and $\mcl{X}_\sigma(c_2,2) = 1$.


 \begin{tiny}
        \begingroup
         \begin{table}[htpb]
                  \noindent\makebox[\textwidth]{%
         \scalebox{0.8}{
         \renewcommand{\arraystretch}{1}
         \begin{tabular}[htp]{|l l l l l|}
         \midrule
         %& & & & \\
         1. &$\sigma \vDash_{ccsl} c_1\subseteq c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. c_1\in \sigma(i)\to c_2\in \sigma(i)\end{aligned}$
         & (Subclock)\\
         \hline
         2. &$\sigma \vDash_{ccsl} c_1\ssharp c_2$
         & iff
         &$\begin{aligned}\forall i\in \mbb{N}^+. c_1\notin\sigma(i)\vee c_2\notin\sigma(i)\end{aligned}$
         & (Exclusion)\\
         \hline
         3. &$\sigma \vDash_{ccsl} c_1\prec c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &(\mcl{X}_\sigma(c_1,i)>\mcl{X}_\sigma(c_2,i)\vee (\mcl{X}_\sigma(c_1,i) = \mcl{X}_\sigma(c_2,i)\to c_1\notin \sigma(i))\end{aligned}$
         & (Precedence)\\
         \hline
         4. &$\sigma \vDash_{ccsl} c_1\preceq c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. \mcl{X}_\sigma(c_1,i)\ge \mcl{X}_\sigma(c_2,i)\end{aligned}$
         & (Causality)\\
         \hline
         5. &$\sigma\vDash_{ccsl} c\triangleq c_1+c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. c\in \sigma(i) \leftrightarrow (c_1\in \sigma(i)\vee c_2\in \sigma(i))\end{aligned}$
         & (Union)\\
         \hline
         6. &$\sigma\vDash_{ccsl} c\triangleq c_1*c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. c\in \sigma(i)\leftrightarrow (c_1\in \sigma(i)\wedge c_2\in \sigma(i))\end{aligned}$
         & (Intersection)\\
         \hline
         7. &$\sigma\vDash_{ccsl}c\triangleq c_1\blacktriangleright c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &c\in \sigma(i)\leftrightarrow (\\
         &c_2\in \sigma(i)\wedge \\
         &\exists j.(0<j<i)\wedge (\forall k. (j\le k<i) \rightarrow (c_1\in \sigma(j)\wedge c_2\notin \sigma(k)))\\
         )
         \end{aligned}$
         & (Strict Sample)\\
         \hline
         8. &$\sigma\vDash_{ccsl}c\triangleq c_1\vartriangleright c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &c\in \sigma(i)\leftrightarrow (\\
         &c_2\in \sigma(i)\wedge \\
         &\exists j.(0<j\le i) \wedge (\forall k.(j\le k<i) \rightarrow (c_1\in \sigma(j)\wedge c_2\notin \sigma(k)))\\
         )\end{aligned}$
         & (Sample)\\
         \hline
         9. &$\sigma\vDash_{ccsl}c\triangleq c_1\curvearrowright c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &c\in \sigma(i)\leftrightarrow (c_1\in \sigma(i)\wedge \forall j. (0<j\le i) \rightarrow c_2\notin\sigma(j))\end{aligned}$
         & (Interruption)\\
         \hline
         10. &$\sigma\vDash_{ccsl} c\triangleq c'\varpropto n$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &c\in \sigma(i)\leftrightarrow (c'\in \sigma(i)\wedge \exists m\in \mbb{N}^+.\mcl{X}_{\sigma}(c', i)=m\cdot (n+1))\end{aligned}$
         & (Periodicity)\\
         \hline
         11. &$\sigma\vDash_{ccsl}c\triangleq c'\ddollar n$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &\mcl{X}_{\sigma}(c, i)=max(\mcl{X}_{\sigma}(c', i)-n, 0)\end{aligned}$
         & (Delay)\\
         \hline
         12. &$\sigma\vDash_{ccsl}c\triangleq c_1\wedge c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &\mcl{X}_\sigma(c, i)=max(\mcl{X}_\sigma(c_1,i), \mcl{X}_\sigma(c_2,i))\end{aligned}$
         & (Infimum)\\
         \hline
         13. &$\sigma\vDash_{ccsl}c\triangleq c_1\vee c_2$
         & iff
         & $\begin{aligned}\forall i\in \mbb{N}^+. &\mcl{X}_\sigma(c, i)=min(\mcl{X}_\sigma(c_1,i), \mcl{X}_\sigma(c_2,i))\end{aligned}$
         & (Supremum)\\
          \midrule
          \end{tabular}
          }%end of scalebox
            }%end of makebox
          \captionsetup{font=footnotesize}
          \caption{Semantics of CCSL}
          \label{table:semantics of CCSL}
          \end{table}
        \endgroup

          \end{tiny}


Clock definitions define new clocks from existing clocks by combining them using different clock expressions.
They greatly enhance the expressiveness of CCSL. 
A clock definition has the form:
$$Cdf\ddef c\triangleq E,$$ where $E$ is defined by the following grammar:
$$E\ddef c_1+c_2\ |\ c_1*c_2\ |\ c_1 \blacktriangleright c_2 \ |\ c_1\vartriangleright c_2\ |\ c_1\curvearrowright c_2\ |\ c\varpropto n\ |\ c\ddollar n\ |\ c_1\vee c_2\ |\ c_1\wedge c_2.$$
In the above definition, 
$c_1$ and $c_2$ are arbitary clocks, and $n\ge 1$. 
%$bw$ is a finite binary word (e.g. $1010$) and $|bw|\ge 2$.
The semantics of a clock definition is defined as a set of schedules satisfying it, shown as the items 5-13 in Table~\ref{table:semantics of CCSL}.
%where $(\rho P(x)). Q$ is the shorthand of $\rho x. P(x)\to Q$, $P, Q$ are predicates, $\rho\in \{\forall, \exists\}$;
%$bw(i)$ ($i\ge 0$) returns the $i^{th}$ bit of words $bw$, e.g. $(1010)(0)=1$, $(1010)(2)=1$;
%$\%$ is the modulo operation.
\emph{Union} defines the clock that ticks iff either $c_1$ or $c_2$ ticks;
\emph{Intersection} defines the clock that ticks whenever both $c_1$ and $c_2$ tick;
(resp. \emph{Strict}) \emph{Sample}  defines the clock that (resp. strictly) samples $c_1$ based on $c_2$;
\emph{Interruption} defines the clock that ticks as $c_1$ until $c_2$ ticks;
\emph{Periodicity} defines the clock that ticks every $n$ ticks of clock $c'$;
\emph{Delay} defines the clock that ticks when $c'$ ticks but is delayed for $n$ ticks of $c'$;
\emph{Infimum} (resp. \emph{Supremum}) defines the slowest (resp. fastest) clock that is faster (resp. slower) than both $c_1$ and $c_2$.

With clock definitions one can define complex CCSL expressions like $c\prec c_2$ and $c\triangleq c_1 \ddollar 2$. 
Fig.~\ref{figure:A possible schedule of selected clock definition} shows a possible schedule that satisfies the clock definitions $c\triangleq c'\varpropto n$ and $c\triangleq c'\ddollar n$ (when $n=2$) respectively. 
They are used in the case study in Example~\ref{example:Digital Filter System}.


\begin{figure}[!htb]
    \centering
    \begin{subfigure}
    \centering
    \begin{tikztimingtable}[timing/rowdist=2.5, yscale=1, xscale=1]
     & c 12{cc} \\
    $c_1$ & c {c} 3c {ccc} 5c {c} 5c {c} 5c  \\
    $c_2$ & 3c {c} 3c {c} 5c {ccc} 5c {c} 3c\\
    \extracode
    %\tablegrid
    \begin{scope}
    [font=\sffamily\footnotesize, shift={(-0cm, -0)}, anchor = east]
    every edge/.append style={->, thick, >=stealth, dashed, line width = 1pt}
    \node at (0.8*\twidth,-3*\rowdist+0.5) {$c_1\prec c_2$};
    %\draw [orange , semithick ]
    %(0.5,-\rowdist)+(0.25,0.5) ellipse (0.5 and 1) coordinate (Ax);
    %(0.25,0.5)+(0.5,-\rowdist) coordinate(x1);
    \draw[->, >=stealth, color=red , thick, dotted] (0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(1,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (2+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(1,-\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (3+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(3,-\rowdist+1);
    %\draw[ color=red , thick, dotted] (4+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(4-4,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (6+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(1,-\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (9+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(1,-\rowdist+1);
    %\draw[->, >=stealth, color=red , thick, dotted] (7+0.5+0.25,-2.0*\rowdist) coordinate(x1) -- +(7-7,-\rowdist+1);
    %\draw[->, >=stealth, color=red , thick, dotted] (9+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(9-9,-2*\rowdist+1);
    %\draw[->, >=stealth, color=red , thick, dotted] (10+0.5+0.25,-2.0*\rowdist) coordinate(x1) -- +(10-10,-1*\rowdist+1);
    \end{scope}
    \end{tikztimingtable}
    \end{subfigure}
    ~
    \begin{subfigure}
    \centering
    \begin{tikztimingtable}[timing/rowdist=2.5, yscale=1, xscale=1]
     & c 12{cc} \\
    $c'$ & 3c {c} 3c {cc} {c} 3c {c} 3c 3{cc} {c} c  \\
    $c$ & 9c {c} 9c {c} 5c\\
    \extracode
    %\tablegrid
    \begin{scope}
    [font=\sffamily\footnotesize, shift={(-0cm, -0)}, anchor = east]
    every edge/.append style={->, thick, >=stealth, dashed, line width = 1pt}
    \node at (0.8*\twidth,-3*\rowdist+0.5) {$c\triangleq c'\varpropto n\ (n=2)$};
    %\draw [orange , semithick ]
    %(0.5,-\rowdist)+(0.25,0.5) ellipse (0.5 and 1) coordinate (Ax);
    %(0.25,0.5)+(0.5,-\rowdist) coordinate(x1);
    %\draw[->, >=stealth, color=red , thick, dotted] (0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(0,-2*\rowdist+1);
    %\draw[->, >=stealth, color=red , thick, dotted] (1+0.5+0.25,-2.0*\rowdist) coordinate(x1) -- +(1-1,-\rowdist+1)
    \draw[red,semithick,dotted] (2+0.5+0.25,-1*\rowdist+0.5) ellipse (2 and 1);
    \draw[->, >=stealth, color=red , thick, dotted] (4+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(4-4,-1*\rowdist+1);
    \draw[red,semithick,dotted] (7+0.5+0.25,-1*\rowdist+0.5) ellipse (2 and 1);
    \draw[->, >=stealth, color=red , thick, dotted] (9+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(9-9,-1*\rowdist+1);
    \end{scope}
    \end{tikztimingtable}
    \end{subfigure}
    ~
    \begin{subfigure}
    \centering
    \begin{tikztimingtable}[timing/rowdist=2.5, yscale=1, xscale=1]
     & c 12{cc} \\
    $c'$ & 3c {c} 3c {cc} {c} 3c {c} 3c 3{cc} {c} c  \\
    $c$ & 9c {c} 3c {c} 3c 3{cc} {c} c\\
    \extracode
    %\tablegrid
    \begin{scope}
    [font=\sffamily\footnotesize, shift={(-0cm, -0)}, anchor = east]
    every edge/.append style={->, thick, >=stealth, dashed, line width = 1pt}
    \node at (0.8*\twidth,-3*\rowdist+0.5) {$c\triangleq c'\ddollar n\ (n=2)$};
    %\draw [orange , semithick ]
    %(0.5,-\rowdist)+(0.25,0.5) ellipse (0.5 and 1) coordinate (Ax);
    %(0.25,0.5)+(0.5,-\rowdist) coordinate(x1);

    \draw[red,semithick,dotted] (2+0.5+0.25,-1*\rowdist+0.5) ellipse (2 and 1);
    \draw[->, >=stealth, color=red , thick, dotted] (4+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(4-4,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (6+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(6-6,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (8+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(8-8,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (9+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(9-9,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (10+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(10-10,-1*\rowdist+1);
    \draw[->, >=stealth, color=red , thick, dotted] (11+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(11-11,-1*\rowdist+1);
    \end{scope}
    \end{tikztimingtable}
    \end{subfigure}
    \captionsetup{font=footnotesize}
    \caption{A possible schedule of selected clock expressions}
    \label{figure:A possible schedule of selected clock definition}
\end{figure}


\ifx
As examples, Fig.~\ref{figure:A possible schedule of selected clock definition} shows a possible schedule of selected definition `Union', `Strict Sample', `Interruption', `Periodicity', `Delay' and `Infimum'.
\fi
	
\subsection{CCSL Specifications}
A CCSL specification is a set of clock relations and clock definitions, defined as a triple
    $$\Spec\dddef\la\mcl{C}, \cdf, \rel\ra,$$ where $\mcl{C}$ is the set of all clocks appearing in the sets $\cdf$ and $\rel$. $\cdf$ is a set of clock definitions. $\rel$ is a set of clock relations.
    A schedule $\sigma$ satisfies a CCSL specification $\la\mcl{C}, \cdf, \rel\ra$, denoted by $\sigma\vDash_{ccsl} \la\mcl{C}, \cdf, \rel\ra$, if $\sigma\vDash_{ccsl} \RRel$ and $\sigma\vDash_{ccsl} \Cdf$ for each $\RRel\in \rel$ and $\Cdf\in \cdf$.

In CCSL, each specification can be captured as a special transition system (see~\cite{MALLET201578}), whose traces are the schedules of clocks in the specification. 
For example, the clock relation $c_1\subseteq c_2$ corresponds to a transition system shown in Fig.~\ref{figure:Transition systems of two clock relations}\rmn{1}. 
A CCSL specification is called \emph{bounded} if its corresponding transition system has a finite number of states~\cite{MalletMS13}, otherwise it is called \emph{unbounded}. 
For unbounded specifications, the reason that causes the unbounded size of the state space is that in some clock expressions, the difference in the numbers of ticks between some clocks is not bounded. 
For example, in the transition system of clock relation $c_1\prec c_2$ shown in Fig.~\ref{figure:Transition systems of two clock relations}\rmn{2}, the difference ($\delta$) in the number of ticks between the clock $c_1$ and $c_2$ is tagged at each state and 
it is increasing infinitely. 

\begin{figure}[!htb]
	\centering
	\scalebox{1}{
	\begin{tabular}{c c}
		\begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
		\node[state4, initial, initial text=] (s1) {};
		
		\path
		(s1) edge [loop above] node [above] {$\{c_1, c_2\}$} (s1)
		(s1) edge [loop right] node [right] {$\{c_2\}$} (s1)
		(s1) edge [loop below] node[below] {$\{\}$} (s1)
		;
		\end{tikzpicture}
		&
		\begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
		\node[st4,initial,initial text=] (s1) {$\delta = 0$};
		\node[st4, right of=s1] (s2) {$\delta=1$};
		\node[st4, right of=s2] (s3) {$\delta=2$};
		\node[st4, draw=none, right of=s3] (txt) {...};

		
		\path
		(s1) edge [loop below] node[below] {$\{\}$} (s1)
		(s1) edge [bend left] node[above] {$\{c_1\}$} (s2)
		
		(s2) edge [loop above] node[above] {$\{c_1,c_2\}$} (s2)
		(s2) edge [loop below] node[below] {$\{\}$} (s2)
		(s2) edge [bend left] node[above] {$\{c_1\}$} (s3)
		
		(s3) edge [loop above] node[above] {$\{c_1,c_2\}$} (s3)
		(s3) edge [loop below] node[below] {$\{\}$} (s3)
		(s3) edge [bend left] node[above] {$\{c_1\}$} (txt)
		
		
		(txt) edge [bend left] node[below] {$\{c_2\}$} (s3)
		
		(s3) edge [bend left] node[below] {$\{c_2\}$} (s2)
		
		(s2) edge [bend left] node[below] {$\{c_2\}$} (s1)
		;
		
		\end{tikzpicture}\\
		\rmn{1}
		&
		\rmn{2}\\
	\end{tabular}
		
	}%end scalebox
	
	\captionsetup{font=footnotesize}
	\caption{Transition systems of $c_1\subseteq c_2$ and $c_1\preceq c_2$}
	\label{figure:Transition systems of two clock relations}
\end{figure}


\ifx
The behaviour of clocks in CCSL expressions can be described as a special type of transition systems called `clock-labeled transition system' (cLTS)~\cite{}, where each transition is labelled as a set of clocks that ticks at current instant. Each trace of a cLTS corresponds to a schedule added with an empty set $\emptyset$ at the beginning. For example, Fig.~\ref{} shows the cLTS of clock relation $c_1\subseteq c_2$, where trace $...$ is a schedule of relation $c_1\subseteq c_2$. 
\fi







\section{The Syntax and Semantics of CDL}
    \label{section: The Syntax and Semantics of CDL}
    %From this section we begin defining our calculus of CCSL Dynamic Logic (CDL).
    In this section we define the CCSL Dynamic Logic (CDL).
    CDL enriches the program model of FODL with a synchronous execution mechanism, and enriches the logical formulae of FODL with CCSL primitives.
    As a background, we first give a brief introduction to FODL in \Sect~\ref{section:First-Order Dynamic Logic}. 
    In \Sect~\ref{section:The Syntax of CDL} we define the syntax of the program model and the logical formulae of CDL. 
    Then in \Sect~\ref{subsection: The Semantics of CDL}, we define the semantics for the program model and the logical formulae of CDL. 
    
    
    %We first give the syntax of the CDL program model and the CDL formula, then define the semantics of them. At last we give the definition of the satisfaction relation of CDL logic.

    \ifx
    As an instance of first-order dynamic logic, CDL provides clock primitives and clock relations to capture CCSL-like specifications.
    It also provides an abstract synchronous programming model to capture the synchronous events and synchronous behaviours of programming languages such as Esterel and Signal.
    It is as the logical framework for the verification of CCSL specifications, where as we will see in Section~\ref{}, clock definitions can be directly encoded into this logic.
    \fi

\subsection{First-Order Dynamic Logic}
\label{section:First-Order Dynamic Logic}
First-order dynamic logic (FODL) is a variation of modal logic for modeling and verifying program specifications.
It is an extension of propositional dynamic logic with an assignment $x := e$ and a test $P?$ in its program model.
The FODL we present here is based on \cite{journals/sigact/HarelKT01}.

The language of FODL consists of two parts: a program model and a set of logical formulae. 

The program model of FODL is a \emph{regular language}, whose syntax is defined as follows:
$$p\ddef x:=e\ |\ P?\ |\ p;p\ |\ p\cup p\ |\ p^*, $$
where $e$ is a term of a type of expressions, $P$ is a proposition of a logic. 
The syntax of $e$ and $P$ depends on the discussed domain(e.g., $e$ could be an arithmetic expression and $P$ could be a quantifier-free first-order logical formula defined in Def.~\ref{definition: Synchronous Event Program}). 
The test $P?$ means that at the current state, $P$ is true. $p;q$ means that the program first executes $p$ and after $p$ terminates, it executes $q$.
$p\cup q$ means that the program either executes $p$, or executes $q$, it is a non-deterministic choice.
$p^*$ means that the program executes $p$ a finite number of times.

The logical formulae of FODL  is defined as follows:
$$\phi\ddef \mathit{tt}\ |\ a\ |\ [p]\phi\ |\ \neg \phi\ |\ \phi\wedge \phi\ |\ \forall x. \phi,$$
where $\mathit{tt}$ is Boolean true, and $a$ is an atomic formula whose definition depends on the discussed domain (e.g., it could be $\theta$ defined in Def.~\ref{definition: CDL Formula}).
$[p]\phi$ is a formula that captures a state property (i.e., a property held on a state) of the program. 
It means that after all executions of the program $p$, the formula $\phi$ holds.

The semantics of FODL is based on Kripke frames~\cite{journals/sigact/HarelKT01}.
A Kripke frame is a pair $(S, val)$ where $S$ is a set of states, $val$ is an interpretation function whose definition depends on the type of logic being discussed.
In FODL, $val$ interprets a program as a set of pairs $(s,s')$ of states and interprets a formula as a set of states.
Intuitively, each pair $(s,s')\in val(p)$ means that starting from the state $s$, after the execution of $p$, the program terminates at the state $s'$.
For each state $s$, $s\in val([p]\phi)$ means that for all pairs $(s,s')\in val(p)$, $s'$ satisfies $\phi$.
For a formal definition of the semantics of FODL, one can refer to \cite{journals/sigact/HarelKT01}.

The proof system of FODL is sound and relatively complete.
Except for the rules for an assignment $x:=e$ and a test $P?$, 
the rules for other operators and logical connectives %can be found in Table~\ref{table:Rules for non-path formulae}, \ref{table: Rules for first order logic} below, 
are also defined 
as a part of the proof system of CDL (which consists of all rules in Table~\ref{table:Rules for non-path formulae} and \ref{table: Rules for first order logic} in \Sect~\ref{section: The Proof System of CDL})\footnote{where the rules for operator $*$ can be obtained by replacing each `$\lup$'  with `$*$' in the rules for operator $\lup$ in Table~\ref{table:Rules for non-path formulae}.}. 
We refer to \cite{journals/sigact/HarelKT01} for more details.
%A substitution $[tn/x]$ replaces a term $tn$ to a variable $x\in Var_{\mbb{N}^+}\cup Var_{\mbb{N}^+\to \mbb{N}^+}\cup Var_H\cup Var_T$.

    \subsection{The Syntax of CDL}
    \label{section:The Syntax of CDL}
	Like FODL, CDL consists of two parts: a program model and a set of logical formulae. 
	We first define the program model in \Sect~\ref{section:Syntax of Synchronous Event Programs} and then define the logical formulae in \Sect~\ref{section:Syntax of CDL Formula}.
	
    \ifx
    \subsubsection{The sCDL Language}
    \label{section:The sCDL Language}
    We begin describing a logic system by defining its \emph{language}. A language consists of a \emph{signature}, together with a set of \emph{variables}. Signature defines the set of all symbols used in a logic system. The signature for sCDL is given as the following definition.
    \begin{definition}[The sCDL Language]
    In sCDL language, the signature $\Sigma_{scdl}$ consists of:
    \rmn{1} A part of the signatures of first-order dynamic logic $\Sigma_{fodl}=\Sigma_{pdl}\cup \Sigma_{afol}$, which consists of :
      a) a part of signatures from propositional dynamic logic, denoted by $\Sigma_{pdl}$. It includes constant symbol $tt$ (true), $ff$ (false), the logical connectives and quantifiers $\wedge, \vee, \to, \neg, \forall, \exists$, and the modal operator $[]$ and $\la \ra$;
      b) a part of signatures from Arithmetical First-Order Logic (AFOL), denoted by $\Sigma_{afol}$. It includes a constant symbol $0$, arithmetic operator $S$ (successor), $+$ (addition), and arithmetic relation $\le $. It defines a variable set $Var=\{x_1,...,x_n,...\}$ ranging over the domain $\mbb{N}^+$. Usually, terms of successor like $S(0), S(S(0)),...$ are expressed as the corresponding natural numbers $1,2,...$;
     \rmn{2} a set of constant clocks $\mcl{C}=\{c_{1},...,c_{n},...\}$ (just defined as in Sect.~\ref{}), a set of constant program signals $Sig=\{a_1,...,a_n\}$, each corresponding to a clock, and a symbol $\epsilon$ representing the empty program;
     \rmn{3} a set of program compositional operators $PFunc=\{;, \cup, *\}$, a set of clock relations $CRel=\{\subset, \#, \prec, \preceq\}$, and a set of connectives between clock relations $CRelC=\{\curlywedge, \curlyvee\}$;
    %4. A set of clock variables $Var^C=\{\gamma_1, ..., \gamma_n\}$, ranging over the domain $\mcl{C}$.
     \rmn{4} a set of clock history variables $Var^H=\{h_{1},...,h_{n},...\}$ (just as defined in Sect.~\ref{}) and a set of variables indicating the tick of clocks $Var^T=\{b_{1},...,b_{n},...\}$ ranging over the domain $\mbb{N}^+$. They each corresponds to a constant clock.
     The set of variables in sCDL is denoted by $V_{scdl}$.
    \end{definition}

    We do not restrict ourselves to freely use auxiliary symbols such as different types of brackets $(,),\{,\},...$, comma `,', substitution $/$ and so on. And we assume that they are all belonging to the sCDL language, but we omit the discussion of their interpretations cause it is quite trivial.

    \ifx
    The language for sCDL we will introduce next in this section just contains a subset of symbols of the language for CDL.

    \begin{mydef}[The sCDL Language]
    sCDL language is just the CDL language excluding some symbols from clock operators, clock relations and program operators: $CFunc$, $\{\triangleleft, \between\}$, $\{\triangleq\}$.
    \end{mydef}
    \fi

    \ifx
    Solution of $\triangleq$: here the equation $c\triangleq e$ should be interpreted as a set of traces. Thus the combination with a program $p\triangleleft c\triangleq e$ should also be interpreted as a set of traces. Here the trace means a sequence of states in Kriple structure.
    \fi
    \fi

    \subsubsection{Syntax of Synchronous Event Programs}
    \label{section:Syntax of Synchronous Event Programs}
    %To conduct the inference of CCSL specifications we need to define a system model with a concrete program structure.
    %CCSL is mainly for modeling synchronous systems where the time model is discrete and several signals can occur simultaneously.
    To begin defining the syntax of CDL we first define the program model of CDL, called a \emph{synchronous event program} (SEP), based on the program model of FODL. 
    
    As indicated in Fig.~\ref{figure:An overview of CDL}, 
    in order to describe the behaviour of synchronous systems and CCSL specifications in dynamic logic, we introduce the synchronous execution mechanism in the program model of FODL.
    To this end we introduce the notion of signal as a primitive event to model the synchronous communication between system modules, as what has been done in synchronous programming languages like Signal~\cite{BENVENISTE1991103} and Esterel~\cite{BERRY199287}. 
    We introduce the notion of combinational event to express a simultaneous execution of several events.
    With this notion, SEP is able to support a synchronous semantics: the time model is discrete and at each instant, 
    several events can occur simultaneously. 
    %events are enforced to be executed at an instant so that a discrete time model is formed.  
    %In the regular program of FODL, only sequential behaviour can be modelled.
    We introduce the parallel operator `$\paral$' to describe the concurrent execution in synchronous systems.
	
	
	In synchronous systems, infinite loop is a main feature. In the infinite loop (e.g.,  the \emph{loop ... end} statement of Esterel~\cite{BERRY199287}), the program continuously proceeds until a deadlock happens or an interruption point is reached. 
    In SEP, we propose a new loop operator `$\lup$' to express the infinite loop in synchronous systems, based on the finite loop `$*$' in the program model of FODL.  
    Informally, a loop program $p^\lup$ expresses that the program $p$ either proceeds for any finite number of times, or proceeds for infinitely many times. 
    %until a deadlock occurs in $p$. 
	%With operator $\lup$, SEP is strong enough to express all behaviours of synchronous systems concerning the infinite loop, including 
	The deadlock and interruption in the infinite loop can be realized by using the operator $\lup$ and the test operator (see Def.~\ref{definition: Synchronous Event Program}) in SEP. 
	
	The syntax of SEPs is given as the following definition. 
	
	\ifx
    Because synchronous systems keep interacting with their environments, one of the main differences from other types of systems is that their `loops' are always infinite until some action blocks them.
    For example the `loop ... end' statement in Esterel~\cite{BERRY199287}.
    %have `infinite loops'.
    To model this we import a special loop program `$p^\lup$', which can express \tagr{a non-deterministic execution of a finite or an infinite loop of a system}.
    It semantically equals to $p^*\cup p^\omega$ --- the non-deterministic choice  of the finite loop program $p^*$ and the infinite loop program $p^\omega$. %--- a shorthand of the infinite word $\underbrace{p;p;...}_{\infty}$.
    %Such program is expressive enough for the synchronous behaviour we focus in this paper.
	\fi
	
	\ifx
    We call the program after enriched `Synchronous Event Program (\SEPP)',
    which can model general synchronous systems in an imperative style.
	\fi
	
    %turns out to be a special `omega language', with the support for modelling synchronous systems, we call it `Synchronous Event Program (\SEPP)'.

    \ifx
    In order to model synchronous systems we build a program model for CDL to support discrete time model and synchronous communication mechanism.
    Our model only contains a smallest set of primitives for modelling synchronous systems. It can be taken as a `core language' of a much richer imperative synchronous language like Esterel.
    A small language would easy the analysis of theory and keep us away from redundant details which only matter in practical usage.
    Once the core language is built and fully analyzed, one can easily enrich it with more sugars and data structures to support practical system modelling and verification.
    \fi
    \ifx
    The model should be as small as possible so that it only contains necessary primitives. This can avoids unnecessary complexity of analyzing our logic in theory and make us focus on the theory itself rather than
    the redundant information which only matter in practical usage. Additional sugars and data structures can be added later when we consider the practical issues.
    \fi


    \begin{definition}[Syntax of \SEPP s]
    \label{definition: Synchronous Event Program}
    The syntax of \SEPP s\ is defined as follows:
    $$\begin{aligned}
    p\ddef \mu\ |\ \alpha\ |\ \varrho\& P ?\alpha\ |\ p;p\ |\ p\cup p\ |\ p^\lup\ |\ \paral(p_1,...,p_n),\\
    \end{aligned}$$
    where $\alpha$ is defined as:
    $$\begin{aligned}\alpha\ddef\ &\epsilon \ |\ \act, \\
    \act\ddef\ &\sig!e\ |\ x:=e'\ |\ (\act | \act).\end{aligned}$$
    $e$, $P$ and $\varrho$ are defined as:
    $$\begin{aligned}
    e\ddef \ & x\ |\ n\ |\ e+e\ |\ e-e\ |\ n\cdot e\ |\ e/n,\\
    %\varrho\ddef \ &\hat{\sig}(x)\ |\ \bar{\sig}\ |\ \varrho\aand \varrho\ |\ \varrho\oor \varrho,\\
    P\ddef \ &tt\ |\ e\le e\ |\ \neg P\ |\ P\wedge P,\\
    \varrho\ddef \ &\hat{\sig}(x)\ |\ \bar{\sig}\ |\ \varrho\aand \varrho\ |\ \varrho\oor \varrho.
    \end{aligned}$$
    Note: $\varrho$ only appears in a parallel program of the form $\paral(p_1,...,p_n)$.
    \end{definition}
	
	%We denote the set of all SEPs as $\prog$. 
	
    $\mu, \alpha$ and $\varrho\&P?\alpha$ are atomic programs. Their intuitive meanings are given as follows:
    \begin{itemize}[label=-]
	\item
    A \emph{skip} program $\mu$ represents a program that does nothing and consumes no time.
	\item
    A combinational event $\alpha$ can be an \emph{idle event} $\epsilon$, or consists of several signals of the form $\sig!e$ or \emph{local assignments} of the form $x:=e$ linked by an operator `$|$' (e.g., $\alpha = (\sig!5 | x := 5)$), meaning that they occur simultaneously. 
    %(defined order here...). 
    Signal and local assignment are indivisible (atomic) events. 
    %They can be combined by an operator `$|$' (e.g., $\alpha = (\sig!5 | x := 5)$). 
    There is no execution order between the atomic events of a combinational event so the order in which they are linked by $|$ is irrelevant. 
    For example, the behaviour of $(\sig!5 | x := 5)$ is the same as that of $(x := 5 | \sig!5)$. 
    All atomic events in a combinational event occur simultaneously and consume one unit of time.
    %The execution of each event consumes a unit of time.
    An idle event $\epsilon$ does nothing, but consumes a unit of time.
	\item
    %In $\act$, signal and local assignment are indivisible actions. They can be combined by an operator `$|$'.
    A signal $\sig!e$ is a pair made of a signal name $\sig$ and a value expressed as an expression $e$.
    It means that the signal $\sig$ emits with the value of an expression $e$. When the value $e$ of the signal can be ignored, we denote the signal simply as `$\sig$'.
    We also call a signal $\sig$ without a value a \emph{pure signal}.
    The local assignment $x:=e$ means to assign the value of an expression $e$ to a variable $x$.
    $x$ is called a \emph{general variable}, with the domain $\mbb{Z}$.
    We use $\Var$ to denote a set of general variables.
    $e$ is a Presburger arithmetic expression, which consists of a variable $x$,
    an integer number $n\in \mbb{Z}$, and arithmetic expressions connected by addition $\place +\place$, subtraction $\place -\place$, scalar multiplication $n \cdot\place$ and scalar division $\place /n$ ($n\neq 0$).
    %In SEP, signal should be the `only way' for concurrent programs to communicate with each other.
    %Thus we stipulate that
	\item
    $\varrho\&P?\alpha$ is a \emph{test event}. It means that if the conditions $\varrho$ and $P$ are true, the event $\alpha$ proceeds, otherwise a deadlock occurs (i.e., the program halts without terminating).
    If there is no $\varrho$ or $P$, we simply write it as $\varrho?\alpha$ or $P?\alpha$. 
    %In \SEPP, testing $\varrho?$ and $P?$ must combine with an event $\alpha$, because the procedure for checking $\varrho$ or $P$ is assumed not to consume time.
    The procedure for checking $\varrho$ and $P$ is assumed to consume no time.
    The condition $P$ is a proposition expressed as a QF-AFOL formula,
    where $\mathit{tt}$ represents Boolean true ($\ff$ represents Boolean false),
    $\le$ represents the less-than relation between two integers.
    The \emph{signal test condition} $\varrho$ is a logical expression, it is only allowed when program is running concurrently with other programs (see below the intuitive explanation of the parallel operator `$\paral$').
    $\hat{\sig}(x)$ and $\bar{\sig}$ express the signal states (\emph{present} or \emph{absent}) at the current instant: $\hat{\sig}(x)$ means that the signal $\sig$ is present at the current instant, where the variable $x$ is for storing the value of the signal $\sig$;
    $\bar{\sig}$ means that ``the signal $\sig$ is absent at the current instant''. 
    $\oor$ and $\aand$ represent the logical \emph{or} and \emph{and} respectively. 
    %distinguished from `$\wedge$' and `$\vee$' in the traditional logic.
		
	\end{itemize}

	For convenience, sometimes we abuse the term \emph{event} to also denote a combinational event or a test event. 
	They should not be confused in the context. 
		
    In SEP, we use a special symbol $\halt$ to represent an idle event with a false condition: $$\halt\dddef \ff?\epsilon.$$
    This program always reaches a deadlock because its test condition will never be satisfied.
    It is often used to express the infinite loop (introduced below) program in the form $p^\lup;\halt$ in SEP (see Example~\ref{example:Digital Filter System}).
    The semantics of $\halt$ corresponds to the empty set (see Def.~\ref{definition: Semantics of SEP} below).
    We call a program, e.g. $\epsilon;\halt$, which always reaches a deadlock, a \emph{miracle program}.
    %we call it `miracle program' since its semantics corresponds to the empty set (see Def.~\ref{definition: Semantics of SEP} below).

    %halting program, defined as $$\halt\dddef \ff?\epsilon.$$

    Compositional programs are composed by atomic programs using operators $;$, $\cup$, $\lup$ and $\paral$. 
    Their intuitive meanings are given as follows:
    \begin{itemize}[label=-]
    \item
    Operators $;$ and $\cup$ correspond to the sequential and nondeterministic choice operators in the traditional FODL (see \Sect~\ref{section:First-Order Dynamic Logic}) respectively.
    \item
    $\lup$ is the loop operator.
    $p^\lup$ means that the program $p$ nondeterministically executes for some finite number of times or infinitely many times.
    %Equivalently, it can be seen as $p^*\cup p^\omega$, where omega program $p^\omega$ means `program $p$ executes for an infinite number of times'.
    \item
    $\paral$ is the n-tuple parallel operator. $\paral (p_1,...,p_n)$ means that the programs $p_1,...,p_n$ are running concurrently.
    At each instant, 
    the events in $p_1,...,p_n$ are triggered simultaneously and all conditions $\varrho$ are checked according to the signal state at the current instant.
    Signals are broadcasting their values, while each program can receive them at the same instant. 
    %Sometimes we write $\paral(p_1,...,p_n)$ as $p_1\paral ... \paral p_n$
	\end{itemize}
	%We call an SEP that does not contain any parallel operator $\paral$ a `sequential SEP'. 
	We call an SEP that is not in the form $p \paral q$ a \emph{sequential SEP}.
	
	In SEP, we stipulate that signals are the only way for communication between programs that are running concurrently.
	So all assignments in SEP must be local. 
	Formally, given a parallel program $\paral(p_1,...,p_n)$, if an assignment $x:=e$ appears in one of the programs $p_1,...,p_n$, e.g., say $p_1$, then
	the variable $x$ must not appear in the other programs $p_2,...,p_n$.
	
	    The precedence of operators are listed as follows from the highest to the lowest: $\lup$, $;$, $\cup$, $\paral$.
	    We stipulate that $;$ is right-associative, and $\cup$ is left-associative.
	    For example, program $\alpha_1\cup p_1;p_2;p^\lup_3\cup P_1?\alpha^\lup_2\cup P_2?\alpha_3$ means
	    $(((\alpha_1\cup p_1;(p_2;p^\lup_3))\cup P_1?\alpha^\lup_2)\cup P_2?\alpha_3)$.

    \begin{figure}[htb]
        \centering
        \ifx
        \begin{minipage}{.6\linewidth}
        \includegraphics[width=1\linewidth]{figures/df_system181122.pdf}
        \end{minipage}
        \begin{minipage}{0.39\linewidth}
        %\includegraphics{figures/feederfilter.pdf}
        \includegraphics[width=1\linewidth]{figures/feederfilter.pdf}
        \end{minipage}
        \fi
        \includegraphics[width=1\linewidth]{figures/df_system181122_2.pdf}
        \captionsetup{font=footnotesize}
        \caption{The Digital Filter system}
        \label{figure:Digital Filter Feeder}
    \end{figure}

    \begin{example}[Digital Filter System]
    \label{example:Digital Filter System}
    We consider a simple synchronous system --- a digital filter (DF) system --- throughout this paper.
    The DF system we analyze here is based on \cite{conf/lctrts/AndreM09-CCSL_Esterel}.
    As Fig.~\ref{figure:Digital Filter Feeder} shows, the main function of the DF system is to read image pixels from a memory, filter them in some way, and send the result out to a video device.
    The explicit structure of the DF system is shown in the right figure of Fig.~\ref{figure:Digital Filter Feeder}, where we consider a simplified behaviour between two modules: a feeder and a filter.
    They interact with each other and with their environment through ports $e$, $p$, $r$ and $o$.
    Ports are the only way for different modules to communicate in synchronous models. They can be modeled as signals $\sig_e$, $\sig_p$, $\sig_r$ and $\sig_o$ respectively in SEP.
    The behaviour of the DF system can be described in a loop where the behaviours of the Filter and the Feeder are described separately as follows:
    %The behaviour of the DF system is as follows:
    \begin{enumerate}[label=(\roman*)]
    \item The filter sends a ``Ready'' message through the port $r$, telling the feeder that ``I am ready for the pixels''. From the next instant it continuously receives pixels from the port $p$, one pixel per unit of time.
    After receiving 2 pixels, the filter waits for an ``Ending'' message from the port $e$, then it processes the pixels (taking no time) and sends the result to the environment through the port $o$.
    %After that, the Filter starts another loop and sends a `Ready' message again and a new loop starts. 
    %the Filter processes them (which takes one unit of time), and then (the next instant) it waits for sends the result to the environment through port $o$.

    \item On the other hand, the feeder receives the ``Ready'' message from the port $r$ at the same time when the filter sends it. From the next instant it starts an inner loop to send pixels through the port $p$, one pixel per unit of time. After sending 2 pixels, it sends an ``Ending'' message to inform the filter through the port $e$.
    %After that the Feeder continues waiting another `Ready' message....

    \end{enumerate}
    The behaviour of the filter and the feeder, and the behaviour of the DF system as a whole can be described as SEPs as follows:
    $$\begin{aligned}
    \Fil \dddef&\ (\sig_r;\hat{\sig_p}?\epsilon;\hat{\sig_p}?\epsilon;\hat{\sig_e}?\sig_o)^\lup;\halt, \\
    \Fee \dddef&\ (\hat{\sig_r}?\alpha_1;(P_1?\alpha_2\cup P_2?\alpha_3)^\lup;f=1?\sig_e)^\lup;\halt,\\
    \DF \dddef&\ \paral(Fil, Fee),
    \end{aligned}$$
    where $P_1 = (x=2\wedge f=0)$, $P_2 = (x<2\wedge f=0)$, $\alpha_1 = (x:=1|f:=0)$, $\alpha_2 = (\sig_p|f:=1)$, $\alpha_3 = (\sig_p|x:=x+1)$.
    %We define $\halt \ddef \ff?\epsilon$ to represent the program halting, so
    Generally, 
    a program $p^\lup;\halt$ describes that $p$ is executed infinitely many times, just like the command ``while $true$ do $p$'' in common imperative programs.
    The program $p$ can not successfully terminate after executing for any finite number of times since the test event $\halt$, as defined above, causes a deadlock. 
    The variable $f$ is a flag indicating the end of the loop $(P_1?\alpha_2\cup P_2?\alpha_3)^\lup$.

    The program $\Fil$ and $\Fee$ are running concurrently in $\DF$. For example, at the first instant, $\sig_r$ is executed, since the condition $\hat{\sig_r}$ is satisfied, the event $\alpha_1$ is also executed.
    So at the first instant, the combinational event $(\sig_r|x:=1|f:=0)$ is executed.
    \end{example}

    \ifx
    \begin{example}
    $\alpha_1 = x:=x+5$, $\alpha_2 = (x:=5\cdot (x+y) | \sig ! 5)$, $\alpha_3 = n>0 ? n:= n+1$ are atomic programs. In $\alpha_2$, assignment $x:=5\cdot (x+y)$ and signal $\sig$ occur simultaneously.
    $\alpha_3 = n>0 ? n:= n+1$ executes $n:=n+1$ if $n>0$ holds, and causes a deadlock otherwise.

    $p_1 = \mu ; \alpha_1$, $p_2 = \epsilon;\alpha_1$, $p_3 = p_1 \cup p_2$, $p_4 = (\alpha_1)^\lup$, $p_5 = \paral (\hat{\sig_1}\aand \bar{\sig_2}?\sig_3, \sig_1)$ are compositional programs.
    Program $p_1$ behaves exactly as $p'_1 = \alpha_1$, while program $p_2$ behaves differently from $p'_2 = \alpha_1$ ($p_2$ executes nothing but $p'_2$ executes $\alpha_1$ at the first time point).
    In $p_5$ two programs $\hat{\sig_1}\aand \bar{\sig_2}?\sig_3$ and $\sig_1$ are running concurrently.
    At current time, $\sig_1$ is executed; since the current state of signal $\sig_1$, $\sig_2$ are present and absent respectively, condition $\hat{\sig_1}\aand \bar{\sig_2}$ holds, thus $\sig_3$ is executed.
    \end{example}
    \fi

	\ifx
	\subsubsection{Local Assignments and Signals}
 
 In SEP, we stipulate that all signals are local in the sense that any signal can only be used to send values by one program in a set of programs that are running concurrently. 
 Formally, given a parallel program $\paral(p_1,...,p_n)$, if a signal $\sig$ appears in the events of one of program $p_1,...,p_n$, e.g., say $p_1$, then 
 it must not appear in the events of other programs $p_2,...,p_n$. 
 
	
	\begin{example}
		Let $p_1 = \paral(x:=5, \sig;y:=x+1)$, $p_2 = \paral(\hat{\sig_1}(x)?\sig!(x+1), \bar{\sig_2}?(\sig | \sig_1))$. 
		In $p_1$, $y$ is local, but $x$ is not local. 
		 In $p_2$, $\sig_1$ is local, but $\sig$ is not local. 
		
	\end{example}
	\fi
	
    \subsubsection{SEPs vs. Imperative Synchronous Languages}
    As a synchronous version of the program model of FODL, SEP inherits some core features of synchronous languages from Esterel~\cite{BERRY199287} (like signal and synchronous communication and execution) but
    mainly follows the style of regular languages for constructing programs.
    This makes SEP a convenient language both for synchronous modeling and compositional verification.
    Compared with imperative synchronous languages like Esterel, SEP is designed to be a lower-level language that is closer to the form for derivation in dynamic logic.
    SEP can encode the core behaviour of synchronous languages.

        \begin{tiny}
        \begingroup
         \begin{table}[htpb]
         \centering
         \scalebox{0.8}{
         %\renewcommand{\arraystretch}{1}
         \begin{tabular}[htp]{|c | c | c|}
         \toprule
         Esterel Statement & Corresponding SEP Statement \\
         \hline
         $\mathit{nothing}$ & $\mu$ \\
         \hline
         $\mathit{emit}\ \sig(e)$ & $\sig!e$\\
         \hline
         $x:= e$ & $x:=e$\\
         \hline
         $\mathit{pause}$ & $\epsilon$\\
         \hline
         $\mathit{emit}\ \sig_1;\mathit{emit}\ \sig_2$ & $(\sig_1|\sig_2)$\\
         \hline
         $\mathit{emit}\ \sig_1;\mathit{emit}\ \sig_2;\mathit{pause}; x:= e$ & $(\sig_1|\sig_2);x:=e$\\
         \hline
         $\mathit{present}\ \sig\ \mathit{then}\ \mathit{emit}\ \sig_1\ \mathit{else}\ x:=e\ \mathit{end}$ & $\hat{\sig}?\sig_1\cup \bar{\sig}?x:=e$\\
         \hline
         $\mathit{if}\ P\ \mathit{then}\ \mathit{emit}\ \sig_1\ \mathit{else}\ x:=e\ \mathit{end}$ & $P?\sig_1\cup \neg P? x:=e$\\
         \hline
         $\mathit{loop}\ (\mathit{emit}\ \sig_1;\mathit{pause})\ \mathit{end}$ & $(\sig_1)^\lup;\halt$\\
         \hline
         $\begin{aligned}&\mathit{suspend}\ (\mathit{emit}\ \sig_1;\mathit{pause};\mathit{emit}\ \sig_2)\ \mathit{when}\ \sig\end{aligned}$ & $\sig_1;(\hat{\sig}?\epsilon)^\lup;\bar{\sig}?\sig_2$\\
         \hline
         $(\mathit{emit}\ \sig_1;\mathit{emit}\ \sig_2)\paral (\mathit{emit}\ \sig_3;\mathit{pause};\mathit{emit}\ \sig_4)$ & $(\sig_1|\sig_2)\paral (\sig_3;\sig_4)$\\
         \hline
         $\begin{aligned}&\mathit{trap}\ T\ \mathit{in}\ \{\mathit{present}\ \sig\ \mathit{then}\ \mathit{exit}\ T\ \mathit{else}\ \mathit{emit}\ \sig_1\ \mathit{end}\}\end{aligned}$ & $\hat{\sig}?\epsilon\cup \bar{\sig}?\sig_1$\\
          \bottomrule
          \end{tabular}
          }%end of scalebox
          \captionsetup{font=footnotesize}
          \caption{An example of the encoding of Esterel programs as SEPs}
          \label{table:An Encoding from Esterel to SEP}
          \end{table}
        \endgroup
          \end{tiny}



    To show this,  as an example, Table~\ref{table:An Encoding from Esterel to SEP} gives an encoding of some statements from the Esterel language in \cite{Berry99theconstructive} as SEPs.
    The full encoding would be complex and is outside of the scope of this paper.
    One of the main differences between Esterel and SEP is that in SEP every combinational event consumes a unit of time, while in Esterel only the statement $\mathit{pause}$ consumes time.
    Thus the statement $\mathit{pause}$ means more than the idle event $\epsilon$ in SEP.
    It also indicates the end of a combinational event and splits two events that run at different instants.
    In SEP, the sequential operator $;$ means the sequential execution of events at different instants, while in Esterel the operator $;$ is just a symbol for linking different statements.
	
	\ifx
    We omit the explanations of other primitives in Esterel such as $\mathit{suspend} ... \mathit{when}...$, the parallel operator $\paral$ and $\mathit{trap} ... \mathit{in}...$,
    see~\cite{Berry99theconstructive} for more details.
	\fi

    \ifx
    where the primitives for external procedure call, trap statement and local declaration are not considered since they do not enhance the expressiveness of Esterel.
    We use $[| L|]$ for the encoding of the Esterel langauge $L$ in SEP.
    \fi



    \subsubsection{Syntax of CDL Formulae}
    \label{section:Syntax of CDL Formula}
    
    As indicated in Fig.~\ref{figure:Verification framework of CDL} and \ref{figure:An overview of CDL},
    CDL supports describing CCSL specifications of synchronous systems by embedding clock relations as special terms into the logical formulae of FODL.
    Clock definitions are actually not a syntactical part of CDL. 
    They can be encoded as an observer \SEPP\ and combined with the SEP of a system in parallel. 
    This encoding  is introduced in \Sect~\ref{section: The Encoding of CCSL Specification in CDL}.

    In synchronous system models, a CCSL clock indicates the occurrences of a signal.
    So in CDL we need to build a connection between signals and clocks, as stated in the following definition.

    \begin{definition}[Connection between Signals and Clocks]
    \label{definition: Clock History,  Clock Ticking}
    %A \emp{pure signal} is denoted by $\sig$.
    %A \emp{valued signal} is a pair consisting of a pure signal $\sig$ and a value $v\in \mbb{Z}$, denoted by $\sig!v$.
    Given a set of pure signals $\Sig$ and a clock set $\mcl{C}$, $$\SigMap: Sig \to \mcl{C}$$ is a bijection that associates a clock to each signal. 
    For each signal $\sig\in \Sig$, clock $\SigMap(\sig)$ models its occurrences.
    \end{definition}

    For each signal $\sig$ in \SEPP s, there is a clock $c=\SigMap(\sig)$.
    The clock $c$ models a sequence of the occurrences of the signal $\sig$: 
    In a schedule, 
    each tick of $c$ corresponds to a present state of $\sig$,
    and each absence of $c$ corresponds to an absence of $\sig$.
    
    Given a clock set $\mcl{C}$, 
    we often denote the corresponding signal (if it exists) of a CCSL clock $c\in \mcl{C}$ as $\sig^c$.
    So there are $c = \SigMap(\sig^c)$ and $\sig^c = \SigMap^{-1}(c)$. 

    \begin{example}
    In Example~\ref{example:Digital Filter System}, we define clocks $c_e, c_p, c_r$ and $c_o$ to model the sequences of the occurrences of the signals $\sig_e, \sig_p$, $\sig_r$ and $\sig_o$ respectively.
    Fig.~\ref{figure:The schedule of system Sdf} shows the schedule of the system $\DF$ for each clock.
    \end{example}

        \begin{figure}[htb]
        \centering
        \begin{tikztimingtable}[ timing/rowdist=2.25, yscale=1, xscale=1.5]
        & c 16{cc} \\
        $c_r$ & c {c} 7c {c} 7c {c} 7c {c} 7c \\
        $c_p$ & 3c {ccc} 5c {ccc} 5c {ccc} 5c {ccc} 3c\\
        $c_e$ & 7c {c} 7c {c} 7c {c} 7c {c} c\\
        $c_o$ & 7c {c} 7c {c} 7c {c} 7c {c} c\\
        \extracode
        %\tablegrid
        \begin{scope}
        [font=\sffamily\footnotesize, shift={(-0cm, -0)}, anchor = east]
        every edge/.append style={->, thick, >=stealth, dashed, line width = 1pt}
        %\node at (-2.5,-1.5*\rowdist) {$c_1\subseteq c_2$};
        %\node at (-2.5,-3.5*\rowdist) {$c_1\prec c_2$};
        %\draw [orange , semithick ]
        %(0.5,-\rowdist)+(0.25,0.5) ellipse (0.5 and 1) coordinate (Ax);
        %(0.25,0.5)+(0.5,-\rowdist) coordinate(x1);
        \draw[->, >=stealth, color=red, dashed] (0+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(3,-3*\rowdist+1);
        \draw[->, >=stealth, color=red, dashed] (4+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(3,-3*\rowdist+1);
        \draw[->, >=stealth, color=red, dashed] (8+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(3,-3*\rowdist+1);
        \draw[->, >=stealth, color=red, dashed] (12+0.5+0.25,-1.0*\rowdist) coordinate(x1) -- +(3,-3*\rowdist+1);

        \draw[->, >=stealth, color=blue , thick, dotted] (2+0.5+0.25,-2*\rowdist+1) coordinate(x1) -- +(2,\rowdist-1);
        \draw[->, >=stealth, color=blue , thick, dotted] (6+0.5+0.25,-2*\rowdist+1) coordinate(x1) -- +(2,\rowdist-1);
        \draw[->, >=stealth, color=blue , thick, dotted] (10+0.5+0.25,-2*\rowdist+1) coordinate(x1) -- +(2,\rowdist-1);
        \end{scope}

        \end{tikztimingtable}
        \captionsetup{font=footnotesize}
        \caption{\footnotesize{The schedule of system $DF$}}
        \label{figure:The schedule of system Sdf}
    \end{figure}

    In order to keep the schedule $\sigma$ and the configuration $\mcl{X}_\sigma$ for each clock at the current instant,
    in CDL we introduce a type of variables called \emph{clock-related variables}.
    They play a crucial role for reasoning about clock relations in CDL.

    \begin{definition}[Clock-related Variables]
    \label{definition:Clock Related Variables}
    For each clock $c$, we associate two \emph{clock-related variables} $$c^n\mbox{ and }c^s$$ to it. 
    The variable $c^n$ has type $\mbb{N}$, it records the number of times the clock has ticked up to the current instant.
    The variable $c^s$ has type $\{0,1\}$, it records the status of the clock (1 for ``ticked'' and 0 for ``not ticked'') at the current instant.
    \end{definition}
	
	The connection between some clock-related variables $c^n$ and $c^s$ in the Kripke frame of CDL and the schedule and configuration of the clock $c$ in the sematics of CCSL is stated in Prop.~\ref{proposition:relation beween CCSL cr and CDL cr} below. 
	 %Variable $c^n, c^s$ relate to the schedule and configuration of $c$ in the Kripke frame of CDL (as we will see in Prop.~\ref{proposition:relation beween CCSL cr and CDL cr}).
    
    Given a clock set $\mcl{C}$, we denote the set of variables related to $\mcl{C}$ as $\VarC$.

    CDL formulae extend FODL formulae with clock relations as special terms in order to express the CCSL specifications of \SEPP s.
    The syntax of CDL formulae is given in the following definition.

    \begin{definition}[Syntax of CDL Formulae]
    \label{definition: CDL Formula}
    A CDL formula $\phi$ is defined as follows:
    \begin{center}
    $\begin{gathered}
    \phi \ddef tt\ |\ \theta\ |\ [p]\Rel\ |\ [p]\phi\ |\ \neg \phi \ |\ \phi \wedge \phi\ |\ \forall x.\phi
    \end{gathered}$
    \end{center}
    where
    \begin{center}
    $\begin{aligned}
    \Rel \ddef\ &\RRel\ |\ \curlywedge (\RRel_1,..., \RRel_n),\\
    \theta \ddef\ &E \le E, \\
    E\ddef\ &x\ |\ c^n\ |\ c^s\ |\ n\ |\ E+E\ |\ E\cdot E
    \end{aligned}$
    \end{center}
    \end{definition}

	%We denote the set of all CDL formulae as $\cdlfmla$. 
	
    $tt$, $\theta$, $[p]\Rel$ and $[p]\phi$ are atomic CDL formulae.
    $E$ is an integer arithmetic expression.
    Different from $e$, it contains clock-related variables $c^n$ and $c^s$ (see Def.~\ref{definition:Clock Related Variables}) and the multiplication between expressions ($E\cdot E$).
    $x\in \Var$ is a general variable.	
    $p$ is an \SEPP. %$Rel$ can be seen as a temporal formula in Differential Dynamic Temporal Logic~\cite{conf/lfcs/Platzer07,books/daglib/0025392} (DDTL).
    Different from $[p]\phi$ in FODL, formula $[p]\Rel$ captures a temporal property related to a \emph{CCSL term} $\Rel$.
    It means that all execution paths of program $p$ satisfies $\Rel$.

	In term $\Rel$, 
    $\curlywedge (\RRel_1,..., \RRel_n)$ represents the conjunction of the clock relations $\RRel_1,...,\RRel_n$.
    The semantics of $\curlywedge (\RRel_1,..., \RRel_n)$ is defined as: $$\vDash_{ccsl}\curlywedge (\RRel_1,..., \RRel_n)\mbox{\quad iff\quad}\sigma\vDash_{ccsl}\RRel_1,...,\sigma\vDash_{ccsl}\RRel_n.$$
    To make it more convenient to express the negation of formula $[p]\RRel$ in CDL, we also import the negation $\nneg$ and the disjunction $\curlyvee$ of clock relations.
    Their semantics is defined as:
    \begin{enumerate}[label=(\roman*)]
    \item $\sigma\vDash_{ccsl}\nneg cr$ \quad iff\quad $\sigma\nvDash_{ccsl}cr$, 
    \item $\sigma\vDash_{ccsl} \curlyvee (cr_1,..., cr_n)$ \quad iff\quad
    $\sigma\vDash_{ccsl} \nneg \curlywedge (\nneg cr_1,...,\nneg cr_n)$,
    \end{enumerate}
    where $cr, cr_i \in \{\RRel_i, \nneg \RRel_i\}$ ($1\le i\le n$).

    In this paper, we often call $\Rel$ or $\nneg \Rel$ a \emph{path formula}, denoted by $\pi$.
    Other arithmetic expressions, relations and logical expressions, such as $E-E$, $E/E$, $E=E$, $E<E$, $\mathit{ff}$, $\la p\ra \nneg \Rel$, $\la p\ra \phi$, $\phi \vee \phi$, $\phi\to \phi$, $\exists x.\phi$, etc, can be expressed using the formulae given above.
    %In FODL, $\la\place\ra$ is the dual operator of $[\place]$.
    %$\la p\ra\phi$ means `after some execution of $p$, formula $\phi$ holds'.
    For example,  $\la p\ra \nneg \Rel$ can be expressed as $\neg [p]\Rel$, which means that there exists an execution path of $p$ that satisfies $\nneg \Rel$;
    $E_1-E_2$ and $E_1/E_2$ can be expressed as $\exists x.(E_2+x=E_1)$ and $\exists x.(x\cdot E_2=E_1)$ respectively.
    %$E_1=E_2$, $E_1<E_2$ can be expressed as


    \begin{example}
    \label{example:CDL formula}
    Consider two CDL formulae $$\begin{aligned}&\phi_1 = \varphi_1 \to [p_1]c_r\prec c_o, \\ &\phi_2 = \varphi_2 \to [p_2]x>z,\end{aligned}$$
    where $\varphi_1 = (c^n_r=0\wedge c^s_r=0\wedge y=0)$, $p_1 = \DF$ (where $\DF$ is given in Example~\ref{example:Digital Filter System}),
    $\varphi_2 = (x = 1\wedge z = 2\wedge \exists z. x = z)$, $p_2 = (x:=z+1 | \sig | y:=1);x:=y+1$.
    $\phi_1$ means that if $\varphi_1$ is true, then all execution paths of $p_1$ satisfies the clock relation $c_r\prec c_o$.
    $\phi_2$ means that if $\varphi_2$ holds, then after all executions of $p_1$, the formula $x>z$ holds.
    \end{example}

    Given a program $p$ (resp. formula $\phi$), we use $\mcl{C}(p)$ (resp. $\mcl{C}(\phi)$) to represent the set of all clocks appearing in $p$ (resp. $\phi$) and all clocks whose corresponding signals appear in $p$ (resp. $\phi$). For example,
    %let $\phi=[\sig_1; (\sig_1|\sig_3)^\lup]\curlywedge (c_1\prec c_3, c_2\preceq c_4)$, then
    %$\mcl{C}(\phi)= \{c_1, c_2, c_3, c_4\},$.
    in Example~\ref{example:CDL formula}, $\mcl{C}(\phi_1) = \{c_e, c_p, c_r, c_o\}$.
    %Here the corresponding signals of clocks $c_1,c_2,c_3$ are $\sig_1,\sig_2,\sig_3$ respectively.

    Like in FODL~\cite{journals/sigact/HarelKT01},
    we introduce the notion of \emph{dynamic/static variable} in CDL. 
    Intuitively, 
    a variable whose value might be changed along the execution of a program is called a \emph{dynamic variable}.
    
    \begin{definition}[Dynamic/Static Variables]
    \label{definition:Dynamic Static Variable}
    In CDL, given a program $p$ (resp. formula $\phi$), a variable $X$ is dynamic w.r.t. $p$ (resp. $\phi$) if
    \begin{enumerate}[label=(\arabic*)]
    \item $X\in \Var$, and it appears on the left side of an assignment of the form $X := e$, or
    \item $X$ is a clock-related variable $c^n$ and there exists a signal $\sig^c$ in $p$ (resp. $\phi$), or
    \item $X$ is a clock-related variable $c^s$.
    \end{enumerate}
	A variable is static w.r.t. $p$ (resp. $\phi$) if it is not dynamic w.r.t. $p$ (resp. $\phi$). 
	\end{definition}
	
	%Def.~\ref{definition:Dynamic Static Variable}(1) says that 
	For any general variable $X$, its value is set to the value of the expression $e$ after the execution of an assignment $X := e$. 
	According to Def.~\ref{definition:Clock Related Variables}, since a variable $c^n$ records the number of times the clock $c$ has ticked up to the current instant, 
	its value is increased by $1$ if the signal $\sig^c$ occurs, and is kept unchanged otherwise.
	Since a variable $c^s$ records the status of the clock $c$, 
	its value is set to $1$ if the 	signal $\sig^c$ occurs, and is set to $0$ otherwise. 
	
	
	\ifx
    The value of any variable $c^n$ will be changed after the occurrence of signal $\sig^c$: if signal $\sig^c$ occurs, $1$ is added to $c^n$ (if signal $\sig^c$ does not occur, $c^n$ is kept unchanged).
    The value of any variable $c^s$ will be changed at every instant (no matter whether $\sig^c$ occurs or not): $c^s$ is set to $1$ if signal $\sig^c$ occurs, and is set to $0$ otherwise.
    Any general variable $x$ is assigned with the value of an expression $e$ by an assignment of the form $x:=e$. 
	\fi
	
    %We define the notion of dynamic variable in CDL.
    \ifx
    \begin{definition}[Dynamic and Static Variables]
    \label{definition:Dynamic Variables}
    Given a clock set $\mcl{C}$, an \SEPP\ $p$ (resp. a \CDLP\ formula $\phi$),
    a variable $X$ is called a dynamic variable of $p$ (resp. $\phi$) if one of the following conditions holds:
    \begin{enumerate}[label=(\roman*)]
    \item $X\in Var$, and it appears on the left side of an assignment of the form $X := e$.
    \item $X = c^n$, and there exists a signal $\sig^c$ in $p$ (resp. $\phi$).
    \item $X =c^s$.
    \end{enumerate}
    Call $X$ a static variable of $p$ (resp. $\phi$) if it is not a dynamic variable.
    \end{definition}
    \fi

    We use $\mcl{V}(p)$ (resp. $\mcl{V}(\phi)$) to represent the set of the dynamic variables in $p$ (resp. $\phi$),
    $\Var(p)$ (resp. $\Var(\phi)$) to represent the set of the variables in $p$ (resp. $\phi$).

    \ifx
    Any clock-related variable of the form $c^n$ must be changed as the execution of signal $\sig^c$: if signal $\sig^c$ occurs, $c^n$ is added by $1$.
    Any clock-related variable of the form $c^s$ must be changed at every instant: if signal $\sig^c$ occurs, $c^s$ is set to $1$, otherwise, it is set of $0$.
    Any general variable $x$ is assigned with a value $e$ by an assignment of the form $x:=e$.
    %Intuitively, Def.~\ref{definition:Dynamic Variables} says that in CDL, any clock-related variables that are changed by the execution of signals, and any variables that is changed by an assignment in $p$ (resp. $\phi$) are
    %dynamic variables of $p$ (resp. $\phi$).
    %Intuitively, at each time all clock-related variables changes with the execution of the current event of a program.
    \fi

    \begin{example}
    In the formula $$\phi_1 = (c^n_r=0\wedge c^s_r=0\wedge y=0) \to [\DF]c_r\prec c_o$$ of Example~\ref{example:CDL formula},
    \ifx
    since $\mcl{C}=\{c_e, c_p, c_r, c_o\}$, $c^s_e$, $c^s_p$, $c^s_r$, $c^s_o$ are dynamic variables of $\phi_1$.
    They all can be changed as the execution of $p_1$.
    $c^n_e$, $c^n_p$, $c^n_r$, $c^n_o$ are dynamic variables since their corresponding signals $\sig_e$, $\sig_p$, $\sig_r$, $\sig_o$ appear in $p_1$.
    $x,f$ is the dynamic variables of $\phi_1$, since $p_1$ contains assignment $x:=1$, $x:=x+1$ and $f:=0$, $f:=1$.
    \fi
    $\mcl{V}(\phi_1) = \{c^n_e, c^s_e, c^n_p, c^s_p, c^n_r, c^s_r, c^n_o, c^s_o, x, f\}$.
    %$\phi$中的全体变量为$Var(\phi)=\{c^n_1, c^s_1, c^n_2, c^s_2, c^n_3, c^s_3, x, z, y, v\}$.
    The set of the static variables in $\phi_1$ is: $\Var(\phi_1)-\mcl{V}(\phi_1)=\{y\}$.
    \end{example}

    \ifx
    In CDL, any clock-related variable $c^s, c^n$ is defined as a dynamic variable. As we will see in Def.~\ref{definition: Semantics of SEP}\rmn{2}, they can be changed after the execution of any event at current time.  %any clock-related variable $c^n$ is a dynamic variable if signal $c$ appears in the program, and
    Any general variable that appears on the left side of an assignment is defined as a dynamic variable as well.
    Variables which are not dynamic variables are called `static variables'.
    e.g., the set of dynamic variables of formula $z=5\to [(c_1 | x:=y+1);c_2]c_1\preceq c_3$ is $\{x, c^n_1, c^s_1, c^n_2, c^s_2, c^n_3, c^s_3\}$,
    where $c^n_3, c^s_3$ can be seen as `changed' after the
    the set of static variables is $\{y, z\}$.
    \fi

	Like in FODL~\cite{journals/sigact/HarelKT01}, we introduce the notion of \emph{bound/free variable} in CDL. 
	This notion is important when we discuss substitutions in CDL.
	
	\ifx
	Intuitively, a variable $X$ is bounded if it is in the scope of the effect of some quantifier $\forall X$, $\exists X$,
	some assignment $X:=e$, some signal $\sig^c!e$ (if $X\in \{c^n, c^s\}$) or some signal testing condition $\hat{\sig}(X)$.
	\fi
	
	\begin{definition}[Bound/Free Variables]
	In CDL, given a variable $X$, we say that $X$ is in the scope of the effect of $A$, where $A\in \{X:=e, \hat{\sig}(X)\}$ or $A = \sig^c!e$ (when $X \in \{c^n, c^s\}$), if:
	\begin{enumerate}[label=(\arabic*)]
		\item there exists a formula of the form $[q]\varphi$ such that $X$ is in $\varphi$, and $A$ appears in $q$, or
		\item there exists a program of the form $q;r$ such that $X$ is in $r$, $A$ appears in $q$.
	\end{enumerate}

	Given a program $p$ (resp. formula $\phi$), a variable $X$ is bound w.r.t. $p$ (resp. $\phi$) if it is in the scope of the effect of some quantifier $\forall X$ or $\exists X$,
	some assignment $X:=e$, some signal $\sig^c!e$ (if $X\in \{c^n, c^s\}$) or some signal test condition $\hat{\sig}(X)$.
	
	%The proposition `$X$ is in the scope of the effect of $A$', where $A\in \{X:=e, \hat{\sig}(X)\}$ or $A = \sig^c!e$ (when $X \in \{c^n, c^s\}$), is defined s.t.:
	
	\end{definition}

	\ifx
    In CDL, given a program $p$ (resp. formula $\phi$), a variable $X$ is called a `bounded variable' of $p$ (resp. $\phi$) if it is in the scope of the effect of some quantifier $\forall X$, $\exists X$,
    some assignment $X:=e$, some signal $\sig^c!e$ (if $X\in \{c^n, c^s\}$) or some signal testing condition $\hat{\sig}(X)$.
    This notion is important when we discuss the substitution in CDL.
    $X$ is in the scope of the effect of $A$, where $A\in \{X:=e, \hat{\sig}(X)\}$ or $A = \sig^c!e$ (when $X \in \{c^n, c^s\}$), if:
    (1) there exists a formula of the form $[q]\varphi$ s.t. $X$ is in $\varphi$, and $A$ appears in $q$, or
    (2) there exists a program of the form $q;r$ s.t. $X$ is in $r$, $A$ appears in $q$.
	\fi
	
    \ifx
    We give the definition of bounded variable in CDL.

    \begin{definition}[Bounded and Free Variables]
    \label{definition:Bounded and Free Variables}
    Given an \SEP\ $p$ (resp. \CDLP\ formula $\phi$),
    a variable $X$ is called `bounded' in $p$ (resp. $\phi$) if one of the following conditions holds:
    \begin{enumerate}[label=(\roman*)]
    \item there exists a sub-formula of the form $\forall X.\varphi$ appeared in $\phi$ s.t. $X$ is in $\varphi$.
    \item there exists a sub-formula of the form $[q]\varphi$ appeared in $\phi$ s.t. $X$ is in $\varphi$, and
        \begin{enumerate}[label=(\arabic*)]
        \item if $X\in Var$, then there is an assignment of the form $X:=e$ or a signal testing condition of the form $\hat{\sig}(X)$ appeared in $q$;
        \item if $X\in \VarC$, without the lose of generality let $X=c^s$, then there is a signal of the form $\sig^c!e$ appeared in $q$.
        \end{enumerate}
    \item there exists a program of the form $q;r$ in $p$ (resp. $\phi$) s.t. $X$ is in $r$, and there is an assignment of the form $X:=e$, or a signal testing condition of the form $\hat{\sig}(X)$ appeared in $q$.

    \end{enumerate}

    Call variable $X$ is `free' in $p$ (resp. $\phi$), if it is not bounded in $p$ (resp. $\phi$).
    \end{definition}

    Note that in the condition \rmn{3} of Def.~\ref{definition:Bounded and Free Variables}, variable $X$ must be a general variable,
    according to the syntactical definition of CDL formula (Def.~\ref{definition: CDL Formula}).
    \fi

    \begin{example}
    In the formula $$\phi_2 = (x = 1\wedge z = 2\wedge \exists z. x = z) \to [(x:=z+1 | \sig | y:=1);x:=y+1]x>z$$ of Example~\ref{example:CDL formula}, the first and second occurrences of the variable $x$ are free, while the third occurrence of $x$ (in ``$x>z$'') is bound by the assignment $x:=y+1$.
    The first occurrence of the variable $z$ is free, the second occurrence of $z$ is bound by the quantifier $\exists z$, and the third and fourth occurrences of $z$ are free.
    The only occurrence of the variable $y$ (in ``$x:=y+1$'') is bound by the assignment $y:=1$.
    Consider the formula $$\phi_3 = [\paral(\epsilon;\sig!(x+1), y:=z+1;\hat{\sig}(z);x:=z+1)]x>z,$$ the first occurrence of the variable $z$ is free, while the second and third occurrences of $z$ are bound by
    the condition $\hat{\sig}(z)$.
    \end{example}

    With the concept of bound and free variables we introduce the notion of substitution in CDL.
    When doing a substitution on a formula, we need to make sure that the meaning of the formula does not change. So we introduce the notion of
    \emph{admissible substitution}.
    
    \begin{definition}[Substitution/Admissible Substitution]
    	Given a CDL formula $\phi$ and a variable $X\in \Var\cup \VarC$,
    	a substitution $\phi[E/X]$ replaces every free occurrence of $X$ in $p$ with the expression $E$.
    	
    	A substitution $\phi[E/X]$ is  admissible if there exists no variable $Y$ such that
    	\begin{enumerate}[label=(\arabic*)]
    		\item $Y$ is in $E$, and
    		\item $Y$ is bound in $\phi[E/X]$.
    	\end{enumerate}
    \end{definition}
    
    \ifx
    Like in traditional FODL,
    given a CDL formula $\phi$ and a variable $X\in Var\cup \VarC$,
    a substitution $\phi[E/X]$ replaces every free occurrence of $X$ with expression $E$.
    %a substitution replaces free occurrences of variables in a formula with an expression.
    %`Admissible substitution' guarantees the `meaning' of the formula dose not change before and after the substitution.
    When doing the substitution, we need to make sure the `meaning' of the formula does not change, so we define
    `admissible substitution'.
    A substitution $\phi[E/X]$ is said to be `admissible', if there exists no variable $Y$ s.t.
    (1) $Y$ is in $E$, and (2) $Y$ is bounded in $\phi[E/X]$.
    \fi
    
    \ifx
    \begin{definition}[Substitution and Admissible Substitution]
    \label{definition:Substitution and Admissible Substitution}
    Given a CDL formula $\phi$ and a variable $x\in Var$, a substitution $\phi[E/x]$ replaces every free occurrence of $x$ with expression $E$.

    We say a substitution $\phi[E/x]$ is `admissible', if there exists no variable $y$ s.t.
    \rmn{1} $y$ is in $E$, and \rmn{2} $y$ is bounded in $\phi[E/x]$.
    \end{definition}
    \fi

    Given a multi-set $\Gamma$ of formulae, we write $\Gamma[E/X]$ to represent the multi-set obtained by doing the substitution $\phi[E/X]$ for each formula $\phi$ in $\Gamma$.
    Given two vectors $\vec u = (E_1,...,E_n), \vec v = (X_1,...,X_n)$, we write $\phi[\vec u/\vec v]$ as a shorthand for $\phi[E_1/X_1]$$[E_2/X_2]$$...$$[E_n/X_n]$.
    \ifx
    Given a mapping $f : \vec v\to \vec u$, $\phi[\vec u/^{[f]} \vec u]$ replaces every variable in $\vec v$ with the term it corresponds by $f$, defined as:
    $$\phi[\vec u/^{[f]} \vec u]\ddef \phi[f(x_1),...,f(x_n)/x_1,...,x_n].$$
    Sometimes we omit the function $f$ and simply write $\phi[\vec u/^{[f]} \vec u]$ as $\phi[\vec u\sub \vec v]$ if $f$ is clear in the context.
    \fi

    \begin{example}
    In the formula $$\phi_2 = (x = 1\wedge z = 2\wedge \exists z. x = z) \to [(x:=z+1 | \sig | y:=1);x:=y+1]x>z$$ of Example~\ref{example:CDL formula}, let $E_1= z+1$, $E_2 = x+1$, and $v$ be a variable different from $x$ and $y$, then
    $\phi_2[v/z]$ is admissible, and $$\phi_2[v/z] = ((x = 1\wedge v = 2\wedge \exists z. x = z) \to [(x:=v+1 | \sig | y:=1);x:=y+1]x > v).$$
    $\phi_2[E_1/z]$ is admissible, and $$\phi_2[E_1/z]=((x = 1\wedge z+1 = 2\wedge \exists z. x = z) \to [(x:=(z+1)+1 | \sig | y:=1);x:=y+1]x > z+1).$$
    $\phi_2[E_2/z]$ is not admissible, and $$\phi_2[e_2/z] =  ((x = 1\wedge x+1 = 2\wedge \exists z. x = z) \to [(x:=(x+1)+1 | \sig | y:=1);x:=y+1]x > x+1).$$
    $\phi_2[E_2/z]$ is not admissible because the variable $z$ in ``$x>z$'' is a free occurrence in $\phi_2$, but after the substitution, $x$ in ``$x>x+1$'' is bound.
    %Intuitively, it is easy to see that $x>x+1$ does not hold for any $x$.
    \end{example}

    Unless specially mentioned, all substitutions discussed in this paper are admissible substitutions.

    \ifx
    \begin{mydef}[Path Formulae]
    We distinguish two types of sCDL formulae.
    The set of path formulae, denoted as $F^p_{scdl}$, consists of all atomic CR formulae $At_{cr}$.
    The set of state formulae, denoted as $F^s_{scdl}$, consists of all atomic AFOL formulae $At_{afo}$ and any formulae of the form $[p]\phi, \la p\ra \phi$.
    \end{mydef}
    \fi


    \subsection{Semantics of CDL}
    \label{subsection: The Semantics of CDL}

    %\subsubsection{Semantics of SEP}
    In the Kripke frame $(S, \val)$ (see also \Sect~\ref{section:First-Order Dynamic Logic}) of CDL, $S$ is a set of states, 
    $\val : (\prog \uplus \cdlfmla) \to ((S^*\cup S^\omega)\uplus 2^S)	$ interprets a program as a set of traces on $S$ and a logical formula as a set of states
    (where $\prog$ denotes the set of all SEPs and $\cdlfmla$ denotes the set of all CDL formulae, $S^*$ represents the set of all finite traces and $S^\omega$ represents the set of all infinite traces on $S$).
    %A state is a finite partial function that maps a variable in its domain to a value in a specific domain.
    A trace $tr\in (S^*\cup S^\omega)$ is a finite or infinite sequence of states.
    Given a finite trace $tr_1=s_1s_2...s_n$ and a (possibly infinite) trace $tr_2=u_1u_2...u_n...$,
    concatenation $tr_1\rtimes tr_2$ is a partial function defined as:
    %we define: %$tr_1^\frown tr_2:=s_1s_2...s_nu_1u_2...u_n....$;
    $$tr_1\rtimes tr_2\dddef s_1s_2...s_{n}u_2u_3... \mbox{ if }s_n=u_1.$$
    %If the length of $tr_2$ is $1$, then $tr_1\cdot tr_2=tr_1$.
    %The concatenation of traces $tr_1$ and $tr_2$ is defined as $tr_1\circ tr_2=tr_1\cdot tr_2\cup \{\mbox{infinite traces in } tr_1\}.$
    Given any $tr_1, tr_2$, we define
    $$tr_1\circ tr_2\dddef \left\{
        \begin{array}{ll}
            tr_1\rtimes tr_2, &\mbox{if $tr_1$ is finite}\\
            tr_1,  &\mbox{otherwise}
        \end{array}
        \right..$$
    Given two sets of traces $S_1$ and $S_2$, $S_1\circ S_2$ is defined as
    $$S_1\circ S_2\dddef \{tr_1\circ tr_2\ |\ tr_1\in S_1, tr_2\in S_2\}.$$
    We use $tr(i)$ to denote the $i^{th}$ ($i\ge 0$) element of trace $tr$, 
    use $tr_b$ to denote the first element of trace $tr$, $tr_b=tr(0)$, 
    and use $tr_e$ to denote the last element of trace $tr$ provided that $tr$ is a finite trace.
    \ifx
    For any trace element $tr(i)$, $idx(tr(i))$ denotes its index number, so $idx(tr(i))=i$.
    Say $tr$ is a subtrace of $tr'$, denoted as $tr\le tr'$, if: a) $tr(1)=tr'(1), tr(2)=tr'(2),..., tr_e=tr'(m$) for some $m$ when $tr$ is finite; b) $tr=tr'$ otherwise.
    $tr<tr'$ is defined as $tr\le tr'$ and $tr\neq tr'$.
    \fi
    \ifx
    As in \cite{} in order to define the semantics of concurrent programs we introduce $trec$, or `tree computation' of an SEP.
    A $trec$ is an SEP only containing the appearances of `$;$' and `$\pl$' operator. It is defined as: a) $\epsilon$, $\varrho\& P?\alpha$ are $trecs$; b)
    if $p, q$ are $trec$s, so are $p;q$ and $p\pl q$.
    $\pl$ connects two $trec$s that run concurrently.
    Each $trec$ can be represented as a tree structure whose arcs are labelled by the atomic programs in the $trec$, $\pl$ corresponds to a split of the tree into two branches.
    Note that generally, $p;q$ is not necessarily in a tree form, but can be transformed into a tree form by attaching the tree $q$ to each leave of the tree $p$. This corresponds to repeatedly performing the transformation $(p_1\pl p_2);q\equiv (p_1;q)\pl (p_2;q)$ in sub-programs of $p;q$.
    We use $p\conn q$ to denote this operation.
    The transformation $(p_1\pl p_2);q\equiv (p_1;q)\pl (p_2;q)$ can be proved based on Definition~\ref{} given next.
    For an SEP $p$, the set of $trecs$ $\trecset(p)$ is computed as follows:
    a) $\trecset(\epsilon):=\{\epsilon\}$; b) $\trecset(\varrho\& P?\alpha)=\{\varrho\& P?\alpha\}$;
    c) $\trecset(p;q):=\{r_1\conn r_2\ |\ r_1\in \trecset(p), r_2\in \trecset(q)\}$;
    d) $\trecset(p\cup q):=\trecset(p)\cup \trecset(q)$;
    e) $\trecset(p\paral q):=\{r_1\pl r_2\ |\ r_1\in \trecset(p), r_2\in \trecset(q)\}$.
    \fi

    In CDL, we interpret arithmetic operators $+, -, \cdot, /$, relation $\le$, %their usual meanings in the traditional number theory,
    and CCSL clock relations $\subseteq, \prec, \preceq, \ssharp$ as their usual meanings.
    Next we define the concepts	 of \emph{state} and \emph{evaluation} in CDL.


    \begin{definition}[State and Evaluation in CDL]
    \label{definition: State in CDL}
    A state $s : (\VarC \uplus \Var) \to (\mbb{N}\uplus \{0,1\}\uplus \mbb{Z})$ in CDL is a total function defined as follows:
    \begin{enumerate}[label=(\roman*)]
    %\item $s$ maps each constant of any domains to itself.
    \item $s$ maps each variable $c^n$ in $\VarC$ to a value in domain $\mbb{N}$.
    \item $s$ maps each variable $c^s$ in $\VarC$ to a value in domain $\{0,1\}$.
    \item $s$ maps each variable $x$ in $\Var$ to a value in domain $\mbb{Z}$.
    %(f(E_1, E_2))=f(s(E_1), s(E_2))$, where $f\in \{+, -, \cdot, /\}$. %$s$ maps each arithmetical operators to their usual meanings in the traditional integer theory.
    %If $e=e_1+e_2$ ($e=e_1-e_2$), then $s(e):=s(e_1)+s(e_2)$ ($s(e):=s(e_1)-s(e_2)$).
     %       \item If $e=V[t\mapsto e](t')$ (where $t,t'\in \{n, x\}$), then $s(e):=S(V)[S(t)\mapsto S(e)](S(t'))$.
    \end{enumerate}
    Given an expression $E$ and a state $s$, an evaluation $\eval_s(E)$ is defined as:
    \begin{enumerate}[label=(\roman*)]
    \item If $E=a$, where $a\in \{x, c^n, c^s\}$, then $\eval_s(a) \dddef s(a)$.
    \item If $E=n$, then $\eval_s(n) \dddef n$.
    \item If $E=f(E_1, E_2)$, where $f\in \{+, \cdot\}$, then $\eval_s(E) \dddef f(\eval_s(E_1), \eval_s(E_2))$.
    %\item 若$E=E_1 \cdot E_2$, 则$\eval_s(E)\ddef \eval_s(E_1)\cdot \eval_s(E_2)$.
    \end{enumerate}
    \end{definition}

	

    The semantics of CDL is defined by simultaneous induction in Def.~\ref{definition: Semantics of SEP}, \ref{definition: Semantics for parallel SEP}, \ref{definition:Semantics of Clock Relations in Kripke frame}
    and \ref{definition: Semantics of CDL Formula} below.
    In the following subsections we first build the semantics of SEPs (Def.~\ref{definition: Semantics of SEP} and \ref{definition: Semantics for parallel SEP}), then give the semantics of CDL formulae (Def.~\ref{definition:Semantics of Clock Relations in Kripke frame} and \ref{definition: Semantics of CDL Formula}).



    \subsubsection{Semantics of SEPs}
    The semantics of SEPs consists of two parts, the semantics for sequential SEPs and the semantics for parallel SEPs. Since CDL contains path formulae $\Rel$ and $\nneg\Rel$, the semantics of SEPs is based on traces, i.e., the meaning of each formula is given as a set of traces.
    This is different from the traditional FODL.

    \ifx
    We give the semantics of sCDL in the domain of Kriple structure.
    In SEP, the main differences from the regular program in dynamic logic~\cite{} are
    \rmn{1} and \rmn{2}. The rest are the same as in dynamic logic.
    \fi
    \begin{definition}[Semantics of Sequential SEPs]
    \label{definition: Semantics of SEP}
    Given a set of clocks $\mcl{C}$ and a set of general variables $\Var$, for any sequential SEP $p$, its semantics is given as a Kripke frame $(S, \val)$ defined as follows:
    %Given a Kripke frame $(S, val)$,
    %let $\mcl{C}$ be a finite set of clocks,
    %the semantics of sequential SEPs is given as follows:
    \begin{enumerate}[label=(\roman*)]
    %\item $\val(\epsilon):=\{ss\ |\ s\in S\}$.
    \item $\val(\mu)\dddef S$, where $S$ is the set of all traces of length 1.
    %\item $\val(\halt):=\emptyset$.
     \item  $\begin{aligned}\val(\alpha)&\dddef \{ss'\ |\ s, s'\in S; \\%dom(s)\subseteq dom(s')\\%dom(s')=dom(s)\cup V',\\
     &\mbox{for each } c\mbox{ where }\ssig{c}\mbox{ is in } \alpha, s'(c^s)=1\wedge s'(c^n)=s(c^n)+1; \\
     &\mbox{for other }d\in \mcl{C}\mbox{ not in }\alpha,  s'(d^s)=0\wedge s'(d^n)=s(d^n);\\
    &\mbox{for each } x:=e \mbox{ in }\alpha, s'(x)=\eval_s(e);\\
    %&\mbox{for each }x'\in V', s'(x') = s(x),\\
    %\}.\end{aligned}$$
    &\mbox{for other }y\in \Var\mbox{ not in }\alpha,  s'(y)=s(y)\}.\end{aligned}$
    %\item $val(\locv{x}{p}):=\{tr\ |\ tr\in val(p[x'/x]); x' \mbox{ only appears in }p\}$.
    \item $\val(P?\alpha)\dddef \{ss'\ |\ s\in \val(P), ss'\in \val(\alpha)\}$.
    \item $\val(p;q)\dddef \val(p)\circ \val(q)$.
    \item $\val(p \cup q)\dddef \val(p) \cup \val(q)$.
    \item $\displaystyle \val(p^\lup)\dddef (\bigcup_{n\ge 0} \val^n(p))\cup \val^\omega(p)$, where
    $$\begin{aligned}&\val^n(p)\dddef \underbrace{\val(p)\circ \val(p)\circ ...\circ \val(p)}_{n}, \\
    &\val^\omega(p)\dddef \underbrace{\val(p)\circ \val(p)\circ ...}_{\infty},\\
    &\val^0(p)\dddef S.\end{aligned}$$
    \end{enumerate}
   
    \end{definition}
    %When we discuss the semantics of CDL, we always assume a context in which there are only finite clocks to be discussed.
    %Note that idle event $\epsilon$ consumes one unit of time. %This is quite different from the traditional program model where
    %Halting program corresponds to an empty set since it means doing nothing
    %Halting program actually means causing deadlock.
    %Note that $\mu$ defines a set of traces of length $1$, so $val(p;\mu) = val(\mu;p) = val(p)$, which means that
    %$\mu$ can be taken as a unit element of operator $;$.
    %In Def.~\ref{definition: Semantics of SEP}, 
    \rmn{1} - \rmn{3} give the definitions of the semantics of atomic SEPs.
    In \rmn{1},
    the event $\mu$ defines a set of traces with length $1$.
    In \rmn{2},
    the event $\alpha$ defines a transition from a state $s$ to a state $s'$.
    In the state $s'$, for each clock $c$ whose corresponding signal $\sig^c$ is in $\alpha$, the variable $c^n$ recording the number of times clock $c$ has ticked up to the current instant is increased by 1, and the variable $c^s$ is set to $1$, indicating at the current instant, clock $c$ ticks.
    For each clock $d$ whose corresponding signal $\sig^d$ is not in $\alpha$, the variable $d^n$ in state $s'$ is kept unchanged while the variable $d^s$ is set to $0$, indicating at the current instant, $d$ does not tick. 
    For any assignment $x:=e$ in $\alpha$, the value of $x$ in $s'$ is set to the value of the expression $e$ in $s$, while other general variables in both $s$ and $s'$ are kept unchanged.
    %The semantics of $\{x\}.p$ is just the same as $p[x'/x]$, provided that $x'$ is a new variable and never appears in other places.
    In \rmn{3}, traces satisfying $P?\alpha$ are exactly those traces satisfying $p$, adding that their beginning states must satisfy $P$.
    The definition of $\val(P)$ is given in Def.~\ref{definition: Semantics of CDL Formula} below.

    \rmn{4} - \rmn{6} give the definitions of the semantics of compositional sequential SEPs.
    The semantics of the sequential operator $;$ and the choice operator $\cup$ are directly inherited from FODL~\cite{journals/sigact/HarelKT01}.
    In \rmn{6}, the semantics of the program $p^\lup$ consists of all traces which are generated by executing $p$ for a finite number of and infinitely many times.
    Intuitively, the traces of $p^\lup$ can be divided into 4 types: (1) all traces of length 1, which corresponds to the semantics of the program $\mu$;
    (2) all finite traces of the form $tr_1\circ tr_2\circ ...\circ tr_n$ where each $tr_i\in \val(p)$ ($1\le i\le n$) is a finite trace;
    (3) all infinite traces of the form $tr_1\circ tr_2...\circ tr_n\circ ...$ where each $tr_i\in \val(p)$ ($i\ge 1$) is a finite trace;
    (4) all infinite traces of the form $tr_1\circ tr_2...\circ tr_m$ ($m\ge 1$) where $tr_1,...,tr_{m-1}\in \val(p)$ are finite traces, while $tr_m\in \val(p)$ is an infinite trace.

    \begin{example}
    \label{example:semantics of sequential SEP}
    Let $\alpha = (\sig^c | x:=x+1)$, $P = (x > 1)$, $\mcl{C} = \{c, d\}$, $\Var = \{x, y\}$,
    if $s=\{c^n\mapsto~\footnote{we use $a \mapsto b$ to mean `element $a$ is mapped to element $b$' in a function.}] 0, c^s\mapsto 0, {d}^n\mapsto 0, {d}^s\mapsto 0, x\mapsto 2, y\mapsto 0\}$,
    $s'=\{c^n\mapsto 1, c^s\mapsto 1, {d}^n\mapsto 0, {d}^s\mapsto 0, x\mapsto 3, y\mapsto 0\}$,
    then $ss'\in \val(P?\alpha)$.
    In Fig.~\ref{figure:semantics of seq choice and loop},
    subfigure $(P?\alpha)$ gives a graphical illustration of trace $ss'$, where the red state $s$ satisfies the condition $P$.
    \end{example}

    Subfigures $(p;q)$, $(p\cup q)$ and $(p^\lup)$ of Fig.~\ref{figure:semantics of seq choice and loop} show examples of how traces are constructed through the operators $;$, $\cup$ and $\lup$.
    Subfigure $(p;q)$ says that a trace of program $p;q$ can be constructed by a trace $tr_1$ of $p$ and a trace $tr_2$ of $q$ with a concatenation operator $\circ$ linking them.
    The trace colored blue belongs to $p$ while the trace colored green belongs to $q$.
    The state $s''$ must belong to both $p$ and $q$ (which are colored half blue and half green).
    In subfigure $(p\cup q)$, we see that a trace of $p\cup q$ is either a trace of $p$ ($tr_1$), or a trace of $q$ ($tr_2$).
    The three traces of subfigure $(p^\lup)$ correspond to 3 types of traces of $p^\lup$ explained above respectively (the types (2), (3) and (4) above).
    %where two different types of infinite traces are illustrated.

    \ifx
    \begin{figure}[htpb]
    \centering
        \scalebox{0.8}{
        \begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
         \node[state4, label=west:$s$, fill=red, label=south:\mbox{$\begin{gathered}c^n\mapsto 0, c^s \mapsto 0\\ {c'}^n \mapsto 0, {c'}^s\mapsto 0\\ x\mapsto 2, y\mapsto 0\end{gathered}$}, label=north:\mbox{$P$}] (s1) {};
          %\node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
          %\node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
          \node[state4, right of=s1, label=east:$s'$, xshift=1cm, label=south:\mbox{$\begin{gathered}\emp{c^n\mapsto 1}, \emp{c^s\mapsto 1}\\ {c'}^n\mapsto 0, {c'}^s\mapsto 0\\ \emp{x\mapsto 3}, y\mapsto 0\end{gathered}$}] (s2) {};
          %\node[yshift=-0.75cm] (s4) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (s1) edge node [above,black] {$(\sig^c|x:=x+1)$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
         %(s1) edge [snake=brace, raise snake=0.2cm, -] node [above=0.25cm] {$Rel^0$} (s3)

         %(s3) edge [snake=brace, raise snake=-0.2cm, -] node [right=-0.2cm] {$p\cup q$} (s2)
         %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
         %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
         ;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        }%end scalebox

        \captionsetup{font=footnotesize}
        \caption{\footnotesize{One of traces of event $P?\alpha$}}
        \label{figure:semantics of event}

    \end{figure}
    \fi



    \begin{figure}[htpb]
    \centering
                 \noindent\makebox[\textwidth]{%
        \scalebox{0.8}{
        \begin{tabular}{c c c c c c}
        \hline
        \multicolumn{2}{|c|}{
        \begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
         \node[state4, label=west:$s$, fill=red, label=south:\mbox{$\begin{gathered}c^n\mapsto 0, c^s \mapsto 0\\ {d}^n \mapsto 0, {d}^s\mapsto 0\\ x\mapsto 2, y\mapsto 0\end{gathered}$}, label=north:\mbox{$P$}] (s1) {};
          %\node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
          %\node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
          \node[state4, right of=s1, label=east:$s'$, xshift=1cm, label=south:\mbox{$\begin{gathered}\emp{c^n\mapsto 1}, \emp{c^s\mapsto 1}\\ {d}^n\mapsto 0, {d}^s\mapsto 0\\ \emp{x\mapsto 3}, y\mapsto 0\end{gathered}$}] (s2) {};
         \path
         (s1) edge node [above,black] {$(\sig^c|x:=x+1)$} (s2)
         ;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        }%end multicolumn
        &
        \multicolumn{2}{c|}{
        \begin{tikzpicture}[->,>=stealth', node distance=2cm]
         \node[state4,label=west:\mbox{$s$}, fill=blue] (s1) {};
         \node[state4,right of=s1, label=east:$s''$, shape=circle split, circle split part fill={blue, green}, rotate=90] (s2) {};
         \node[state4,right of=s2, label=east:$s'$, fill=green] (s3) {};
         \path
         (s1) edge [edge3, blue] node [above,black] {$p$} node [below, black] {$tr_1$} (s2)
         (s2) edge [edge3, green] node [above,black] {$q$} node [below, black] {$tr_2$} (s3)
         (s3) edge [snake=brace, raise snake=0.5cm, -] node [below=0.5cm] {$tr_1\circ tr_2$} (s1)
         ;
        \end{tikzpicture}
        }%end multicolumn
        &
        \multicolumn{2}{c|}{
        \begin{tikzpicture}[->,>=stealth', node distance=2.5cm]
         \node[state4,fill=blue] (s1) {};
          \node[state4, yshift=-0.75cm,fill=green] (t1) {};
          \node[state4, right of=t1,yshift=-0.5cm, fill=green] (s2) {};
          \node[state4, right of=s1,yshift=0.5cm, fill=blue] (s3) {};
          %\node[right of=s1, draw=none] (s4) {...};
          %\node[yshift=-0.75cm] (s4) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (t1) edge [edge3,green] node [below,black] {$q$} node [above,black] {$tr_2$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)

         (s1) edge [edge3,blue] node [below, black] {$p$} node [above,black] {$tr_1$} (s3)
         (s3) edge [snake=brace, raise snake=0.25cm, -] node [right=0.25cm] {$\{tr_1, tr_2\}$} (s2)
         %(s1) edge [snake=brace, raise snake=0.2cm, -] node [above=0.25cm] {$Rel^0$} (s3)

         %(s3) edge [snake=brace, raise snake=-0.2cm, -] node [right=-0.2cm] {$p\cup q$} (s2)
         %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
         %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
         ;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        }%end multicolumn
        \\
        \multicolumn{2}{|c|}{($P?\alpha$)}& \multicolumn{2}{c|}{($p;q$)} & \multicolumn{2}{c|}{($p\cup q$)}\\
        \hline
        \multicolumn{3}{|c}{
         \begin{tikzpicture}[->,>=stealth', node distance=2cm]

         \node[state4, yshift=-1cm, fill=blue] (t1) {};
         \node[state4,right of=t1, shape=circle split, circle split part fill={blue, green}, rotate=90] (t2) {};
         \node[state4,right of=t2, draw=none] (t3) {...};
         \node[state4,right of=t3, fill=yellow] (t4) {};

         \path
         (t1) edge [edge3, blue] node [above,black] {$p$} node [below, black] {$tr_1$} (t2)
         (t2) edge [edge3, green] node [above,black] {$p$} node [below, black] {$tr_2$} (t3)
         (t3) edge [edge3, yellow] node [above,black] {$p$} node [below, black] {$tr_n$} (t4)
         (t4) edge [snake=brace, raise snake=0.5cm, -] node [below=0.5cm] {$tr_1\circ...\circ tr_n (n\ge 1)$} (t1)
         ;
        \end{tikzpicture}
        }%end multicolumn
        &
        \multicolumn{3}{c|}{
        \begin{tikzpicture}[->,>=stealth', node distance=2cm]

         \node[state4, yshift=-1cm, fill=blue] (t1) {};
         \node[state4,right of=t1, shape=circle split, circle split part fill={blue, green}, rotate=90] (t2) {};
         \node[state4,right of=t2, fill=green] (t3) {};
         \node[state4,right of=t3, draw=none] (t4) {...};
         %\node[state4,right of=t3, shape=circle split, circle split part fill={purple, yellow}, rotate=90] (t4) {};
         %\node[state4, right of=t4, draw=none] (t5) {...};

         \path
         (t1) edge [edge3, blue] node [above,black] {$p$}  node [below, black] {$tr_1$} (t2)
         (t2) edge [edge3, green] node [above,black] {$p$}  node [below, black] {$tr_2$} (t3)
         (t3) edge [dashed] (t4)
         %(t3) edge [edge3, purple] node [above,black] {$p$} (t4)
         (t4) edge [snake=brace, raise snake=0.5cm, -] node [below=0.5cm] {$tr_1\circ tr_2\circ ...$} (t1)
         %(t4) edge [edge3, yellow] node [above,black] {$p$} (t5)
         ;
        \end{tikzpicture}
        }%end multicolumn
        \\
        \multicolumn{6}{|c|}{
        \begin{tikzpicture}[->,>=stealth', node distance=2cm]

         \node[state4, yshift=-1cm, fill=blue] (t1) {};
         \node[state4,right of=t1, shape=circle split, circle split part fill={blue, green}, rotate=90] (t2) {};
         \node[state4,right of=t2, draw=none] (t3) {...};
         \node[state4,right of=t3, shape=circle split, circle split part fill={yellow, red}, rotate=90] (t4) {};
         \node[state4, right of=t4, draw=none] (t5) {...};

         \path
         (t1) edge [edge3, blue] node [above,black] {$p$} node [below, black] {$tr_1$} (t2)
         (t2) edge [edge3, green] node [above,black] {$p$} node [below, black] {$tr_2$} (t3)
         (t3) edge [edge3, yellow] node [above,black] {$p$} node [below, black] {$tr_{m-1}$} (t4)
         (t4) edge [edge3, red] node [below, black] {$tr_m$} (t5)
         (t5) edge [snake=brace, raise snake=0.5cm, -] node [below=0.5cm] {$tr_1\circ tr_2\circ... \circ tr_m (m\ge 1)$} (t1)
         (t4) edge [snake=brace, raise snake=0.25cm, -] node [above=0.25cm] {$p$} (t5)
         ;
        \end{tikzpicture}
        }%end multicolumn
        \\
        \multicolumn{6}{|c|}{($p^\lup$)}\\
        \hline
        \end{tabular}
        }%end scalebox
            }%end makebox
        \captionsetup{font=footnotesize}
        \caption{\footnotesize{One of the traces of programs $P?\alpha$, $p;q$, $p\cup q$ and $p^\lup$}}
        \label{figure:semantics of seq choice and loop}
    \end{figure}



    The crucial point of defining the semantics for parallel SEPs is to define how two parallel SEPs interact with each other. 
    For this purpose we introduce a language called $\trec$ \emph{program}, following an idea from~\cite{journals/jcss/Peleg87}. 
    A $\trec$ program can be considered as a \emph{string} of an SEP, just like the string of the regular language.  
    It characterizes one possible behaviour of an SEP. 
    We first define the syntax of $\trec$ programs (Def.~\ref{definition:trec program}) and the semantics for sequential $\trec$ programs (Def.~\ref{definition: Semantics of Sequential trec Program}), based on which we then define the semantics for parallel $\trec$ programs (Def.~\ref{definition:Semantics of Parallel trecs}), where we show how two $\trec$ programs interact with each other. 
    Finally, based on the semantics of $\trec$ programs we define the semantics for parallel SEPs in Def.~\ref{definition: Semantics for parallel SEP}.
    
    \ifx
    %the synchronous communication between two \emph{deterministic} SEPs.
    Formally, a program $p$ is deterministic, iff starting from one state $s$, there exists only one trace $tr$ s.t. $tr\in val(p)$ and $tr_b = s$. 
    A sequential SEP is not deterministic according to Def.~\ref{definition: Semantics of SEP}, as it contains non-deterministic-choice program $p\cup q$ and finite-or-infinite-loop program $p^\lup$.
    Following the spirit of \cite{journals/jcss/Peleg87}, we introduce a type of deterministic SEPs called `$\trec$ \emph{programs}' ($\trec$ for `tree computation').
    We firstly define the syntax of $\trec$ program (Def.~\ref{definition:trec program}) and the semantics of sequential $\trec$ programs (Def.~\ref{definition: Semantics of Sequential trec Program}). 
    Then based on semantics of sequential $\trec$ program we define the semantics of parallel $\trec$ program (Def.~\ref{definition:Semantics of Parallel trecs}), where we define how two $\trec$ programs interact with each other. 
    %the synchronous communication between $\trec$ programs (Def.~\ref{definition:Semantics of Parallel trecs}), then
    Finally, based on the semantics of $\trec$ program we define the semantics of parallel SEP in Def.~\ref{definition: Semantics for parallel SEP}.
	\fi
	
    \ifx
    In order to give the semantics for concurrent SEP,
    following the spirit in \cite{journals/jcss/Peleg87}, we define the `sequence' in concurrent SEP, called $trec$.
    %As in \cite{} in order to define the semantics of concurrent programs we introduce $trec$, or `tree computation' of an SEP.
    A $trec$ can be seen as an infinite version of SEP string connected only by operator `$;$', `$\varrho?...\els...$', `$P?$', `$\omega$' and `$\pl$'. $\pl$ connects two $trec$s that run concurrently.
    \fi

    \begin{definition}[Syntax of $\trec$ Programs]
    \label{definition:trec program}
    $\trec$ programs are a possibly infinite language, defined as follows:
    \begin{enumerate}[label=(\alph*)]
    \item $\mu$ is a finite $\trec$.
    \item $\alpha$ and $\varrho\& P?\alpha$ are finite $\trec$s.
    \item If $p_1, p_2,...,p_n, q$ are $\trec$s (where $q$ is finite), so are $q;p_1$ and $\pl(p_1,p_2,...,p_n)$.
    \item If $p$ is a finite $\trec$, then $p^\omega$ is an infinite $\trec$, where $p^\omega=\underbrace{p;p;...}_{\infty}$ is an infinite word.
    \end{enumerate}
    \end{definition}
	
	To distinguish the parallel operator $\paral$ in SEPs we adopted another operator `$\pl$' to express that $n$ $\trec$ programs execute concurrently. 
	
	The semantics of sequential $\trec$ programs can be defined based on the semantics of sequential SEPs in Def.~\ref{definition: Semantics of SEP}.
	
	\begin{definition}[Semantics of Sequential $\trec$ Programs]
	\label{definition: Semantics of Sequential trec Program}
	The semantics of a sequential $\trec$ program $p$ is defined as follows based on the semantics of sequential SEPs in Def.~\ref{definition: Semantics of SEP}:
	\begin{enumerate}[label=(\roman*)]
		\item $\val(\mu)$, $\val(\alpha)$, $\val(\varrho\& P?\alpha)$ and $\val(p;q)$ are defined just as those in the semantics of sequential SEPs. 
		\item $\val(p^\omega) = \val(p;p;...) \dddef \underbrace{\val(p) \circ \val(p) \circ \val(p) \circ ...}_{\infty}$.
	\end{enumerate} 
	
	\end{definition}
	 
	Intuitively, a $\trec$ program characterizes exact one behaviour of an SEP, since it contains no choice operators $\cup$ and loop operators $\lup$. 
	%is deterministic because it contains no choice operator $\cup$ and loop operator $\lup$. 
    %A $\trec$ program describes the deterministic behaviour of SEP.  
    %Its semantics can be given as in Def.~\ref{definition: Semantics of SEP}. 
    %is a deterministic (possibly infinite) SEP without the choice operator $\cup$ and loop operator $\lup$.
    %A $trec$ can be an infinite string, we use $p^\omega$ to denote an infinite string $p;p;...$.
	The next example gives an intuitive view of how a $\trec$ program captures one behaviour of an SEP. 
		
    \begin{example}
    \label{example:computation tree}
    Consider a $\trec$ program 
    $$p = \pl(\pl(\sig_1;\sig_4;\sig_1;\sig_4, \sig^\omega_2), \sig_3;\hat{\sig_4}?\sig_5;\sig_3;\sig_3;\sig_3), $$
    where two programs $\sig_1;\sig_4;\sig_1;\sig_4$, $\sig^\omega_2$ and $\sig_3;\hat{\sig_4}?\sig_5;\sig_3;\sig_3;\sig_3$ are running concurrently. 
    Fig.~\ref{figure:trec tree} shows the \emph{computation tree} that exactly captures the behaviour of $p$. Each node of the tree is a state.
    Starting from the initial state, each intersecting surface (indicated by a dashed red rectangle) represents an instant.
    Transitions from a state of one intersecting surface to a state of another intersecting surface  are triggered simultaneously
    (e.g., events $\sig_4$, $\sig_2$ and $\hat{\sig_4}?\sig_5$).
    $\trec$\ $p$ is an infinite string so its corresponding computation tree is infinite.
    %$\trec$\ $p$ can be seen as an infinite string if we take each intersecting surface as an abstract `state', and take all events occurring simultaneously as a `word' of that string.


    \end{example}

    \tikzset{
        state6/.style={
               circle,
               draw=black, semithick,
               minimum height=0.25em,
               minimum width=0.25em,
               text centered,
               }
    }

    \begin{figure}[ptbh]
        \centering
        \scalebox{0.8}{
        \begin{tikzpicture}[->,>=stealth', node distance=1.5cm]
      \node[state6, initial] (s1) {};
      \node[state6, right of=s1, yshift=1cm, xshift=0.5cm] (s2) {};
      \node[state6, right of=s1, yshift=0cm, xshift=0.5cm] (s3) {};
      \node[state6, right of=s1, yshift=-1cm, xshift=0.5cm] (s4) {};
      %\node[state6, right of=s1, yshift=-1.5cm, xshift=0.5cm] (s5) {};

      \node[state6, right of=s2] (t1) {};
      \node[state6, right of=t1] (t2) {};

      \node[state6, right of=s3] (u1) {};
      \node[state6, right of=u1] (u2) {};
      \node[state6, right of=u2, xshift=0.5cm] (u3) {};
      \node[state6, right of=u3] (u4) {};
      \node[state6, right of=u4, draw=none] (u5) {...};

      \node[state6, right of=s4] (x1) {};
      \node[state6, right of=x1] (x2) {};

      %\node[state6, right of=s5] (y1) {};
      %\node[state6, right of=y1] (y2) {};

      \node[state6, right of=x2, xshift=0.5cm] (z1) {};
      %\node[state6, right of=z1] (z2) {};
      %\node[state6, right of=z2, draw=none] (z3) {...};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)

     \draw[dashed, thick, rounded corners, red] ([yshift=0.25cm, xshift=-0.25cm]s2.north -| s2.west) rectangle ([yshift=-0.25cm, xshift=0.25cm]s4.east |- s4.south);
      \draw[dashed, thick, rounded corners, red] ([yshift=0.25cm, xshift=-0.25cm]t1.north -| t1.west) rectangle ([yshift=-0.25cm, xshift=0.25cm]x1.east |- x1.south);
     \draw[dashed, thick, rounded corners, red] ([yshift=0.25cm, xshift=-0.25cm]t2.north -| t2.west) rectangle ([yshift=-0.25cm, xshift=0.25cm]x2.east |- x2.south);
     \draw[dashed, thick, rounded corners, red] ([yshift=0.25cm, xshift=-0.25cm]u3.north -| u3.west) rectangle ([yshift=-0.25cm, xshift=0.25cm]z1.east |- z1.south);

     \path
     (s1) edge node [above] {$\sig_1$} (s2)
     (s1) edge node [yshift=0.15cm] {$\sig_2$} (s3)
     (s1) edge node [yshift=0.15cm, xshift=0.25cm] {$\sig_3$} (s4)
     %(s1) edge node [below] {$\gamma_1$} (s5)

     (s2) edge node [above] {$\sig_4$} (t1)
     (t1) edge node [above] {$\sig_1$} (t2)
     (t2) edge node [above] {$\sig_4$} (u3)

     (s3) edge node [above] {$\sig_2$} (u1)
     (u1) edge node [above] {$\sig_2$} (u2)
     (u2) edge node [above] {$\sig_2$} (u3)
     (u3) edge node [above] {$\sig_2$} (u4)
     (u4) edge node [above] {$\sig_2$} (u5)

     (s4) edge node [above] {$\hat{\sig_4}?\sig_5$} (x1)
     (x1) edge node [above] {$\sig_3$} (x2)
     (x2) edge node [above] {$\sig_3$} (z1)
     (z1) edge node {$\sig_3$} (u4)
     %(s5) edge node [above] {$P_1?\gamma_2$} (y1)
     %(y1) edge node [above] {$\gamma_3$} (y2)
     %(y2) edge node [above] {$\gamma_4$} (z1)

     %(z1) edge node [above] {$\beta_2$} (z2)
     %(z2) edge node [above] {$\beta_2$} (z3)
     ;
    \end{tikzpicture}
    }%end of scalebox
        \captionsetup{font=footnotesize}
        \caption{{\footnotesize The computation tree of a $\trec$ program}}
        \label{figure:trec tree}
    \end{figure}

    \ifx
    \begin{example}
    Let $p_1 = x\ge 1?\alpha_1\cup x\ge 1?\alpha_2;\alpha_3$, $p_2 = (\alpha_1;\alpha_2)^\lup$,
    $p_3 = \varrho?\alpha_1; \alpha_2; \alpha_3$, $p_4 = \paral (\alpha_1, \alpha_2\cup \alpha_3)$, then
    $\trecset(p_1) = \{x\ge 1?\alpha_1, x\ge 1?\alpha_2;\alpha_3\}$,
    $\trecset(p_2) = \{\mu, \alpha_1;\alpha_2, $ $(\alpha_1;\alpha_2);(\alpha_1;\alpha_2),..., (\alpha_1;\alpha_2)^\omega\}$,
    $\trecset(p_3) = \{\varrho?\alpha_1; \alpha_2; \alpha_3\}$,
    $\trecset(p_4) = \{\pl (\alpha_1, \alpha_2), \pl (\alpha_1, \alpha_3)\}$.
    \end{example}
    \fi

    %Essentially, each $trec$s represents a possible execution paths of an SEP.
    %A $trec$ can be an infinite sequence.
    %Based on this observation, it is easy to define parallel operator $\paral$ with $trec$s and operator $\pl$.

    \ifx
    $trec$ captures the basic characteristics of a concurrent SEP, just like the role a sequence plays for a sequential SEP.
    Each $trec$ can be represented as a tree structure whose arcs are labelled by the atomic programs in the $trec$, and $\pl$ corresponds to a split of the tree into two branches.
    Generally, given two trees $p$, $q$, $p;q$ is not necessarily in a tree form. Instead we define the operator $\conn$. $p\conn q$ concatenates two $trec$s by attaching tree $q$ to each leave of tree $p$. Thus the result is still a tree.
    \fi

    Before defining the semantics for parallel $\trec$ programs, we introduce some auxiliary functions to ease this process.
    The function $\mmerge(a_1,...,a_n)$ merges $n$ events into one, where $a_i\in \{\alpha_i, \varrho_i\&P_i?\alpha_i\}$ ($1\le i\le n$).
    Given events $\beta_1,...,\beta_m$ and test events $\varrho_1\&P_1?\alpha_1$,...,$\varrho_n\&P_n?\alpha_n$,
    we define $$\mmerge(\beta_1,...,\beta_m, \varrho_1\&P_1?\alpha_1,...,\varrho_n\&P_n?\alpha_n)\dddef P_1\wedge...\wedge P_n?(\beta_1|...|\beta_m|\alpha_1|...|\alpha_n),$$
    where $(\beta_1|...|\beta_m|\alpha_1|...|\alpha_n)$ represents the combinational event whose events are exactly those in $\beta_1,...,\beta_m$, $\alpha_1,...,\alpha_n$.

    The function $\match(a,\varrho)$ matches the signal test condition $\varrho$ with the event $a$, where $a\in \{\alpha, P?\alpha\}$.
    It returns $true$ iff the match is successful as defined in the following rules:
	\begin{enumerate}[label=(\arabic*)]
    \item $\match(a, \hat{\sig}(x))\dddef tt$ if $\sig$ is in $\alpha$,  $\match(a, \hat{\sig}(x))\dddef\ff$ if $\sig$ is not in $\alpha$.
    \item $\match(a, \bar{\sig})\dddef tt$ if $\sig$ is not in $\alpha$, $\match(a, \bar{\sig})\dddef\ff$ if $\sig$ is in $\alpha$.
    \item $\match(a, \varrho_1\oor \varrho_2)\dddef\match(a, \varrho_1)\vee \match(a, \varrho_2)$.
    \item $\match(a, \varrho_1\aand \varrho_2)\dddef\match(a, \varrho_1)\wedge \match(a, \varrho_2)$.
	\end{enumerate}
	
	%Suppose there are $n$ conditions  $\hat{\sig_1}(x_1),...,\hat{\sig_n}(x_n)$ in $\varrho$. 
	%For each condition $\hat{\sig_i}(x_i)$ ($1\le i\le n$),	
	
    For each condition of the forms $\hat{\sig_1}(x_1),...,\hat{\sig_n}(x_n)$ in $\varrho$ and each signal of the forms $\sig_1!e_1,...,\sig_n!e_n$ in $a$ (where $a\in \{\alpha, P?\alpha\}$),
    the function $\ssub(p, a, \varrho)$ substitutes the variables $x_1,...,x_n$ in $p$, which store the values of signals $\sig_1,...,\sig_n$ in $\varrho$ as the expressions $e_1,...,e_n$ in $a$.
    It is defined as $$\ssub(p, a, \varrho)\dddef p[e_1,...,e_n/x_1,...,x_n].$$
    %It is defined as: $\ssub(p, \alpha, \varrho):= p[e_1,...,e_n/x_1,...,x_n]$ iff there exist $c_1(x_1),...,c_n(x_n)$ in $\varrho$, and $c_1!e_1,...,c_n!e_n$ in $\alpha$.
	

    \begin{definition}[Semantics of Parallel $\trec$ Programs]
    \label{definition:Semantics of Parallel trecs}
    For any parallel $\trec$ program $\pl(p_1,...,p_n)$,
    let $$a = \mmerge(a_{k_1},...,a_{k_m}), $$
    where $a_{k_j}\in \{\alpha_{k_j}, P_{k_j}?\alpha_{k_j}\}$ ($1\le j\le m$).
    $p_{k_1}$,...,$p_{k_m}$ are all programs among the programs $p_1,...,p_n$ such that $\val(p_{k_1}) = \val(a_{k_1};p'_{k_1})$, ..., $\val(p_{k_m}) = \val(a_{k_m};p'_{k_m})$ holds. %(where $p'_{k_j}\in \{a_{k_1}, a_{k_j};q'_{k_j}\}$, $1\le j\le m$).
    The semantics of $\pl(p_1,...,p_n)$ is defined as
    $$\val(\pl(p_1,...,p_n)) \dddef \Commu(\pl(p_1,...,p_n), a),$$
    where the function $\Commu$ is defined as follows:
    \begin{enumerate}[label=(\roman*)]
    \item If there exists a program $r$ among the programs $p_1,...,p_n$ such that $\val(r) = \val(\mu)	$ holds, then
    $$\Commu(\pl(p_1,...,r,...,p_n), a) \dddef \Commu(\pl(p_1,...,p_n), a).$$

    \item If there exist programs $r_1,...,r_m$ among the programs $p_1,...,p_n$ such that $\val(r_k) = \val(\varrho_k\& P_k?\beta_k;q_k)	$ ($1\le k\le m$) holds, %(where $u\in \{\varrho?\beta, \varrho\&P?\beta, \varrho?\beta;q, \varrho\&P?\beta;q\}$),
        \begin{enumerate}[label=(\arabic*)]
        \item if $\match(a, \varrho_k)$ holds for all $1\le k\le m$, then
        $$\Commu(\pl(p_1,...,r_1,...,r_m,...,p_n), a) \dddef \Commu(\pl(p_1,...,r'_1,...,r'_m,...,p_n), a'), $$
        where $$\begin{aligned}r'_k =&\ P_k?\ssub(\beta_k,a,\varrho_k);\ssub(q_k, a, \varrho_k)\mbox{ for all }1\le k\le m,\\ a' =&\  \mmerge(P_1?\ssub(\beta_1,a,\varrho_1),...,P_m?\ssub(\beta_m,a,\varrho_m), a).\end{aligned}$$

        \item if there exists $1\le k\le m$ such that $\match(a, \varrho_k)$ does not hold, then
        $$\Commu(\pl(p_1,...,r,...,p_n),a) \dddef \emptyset.$$
        \end{enumerate}

    \item Otherwise (i.e., all programs $p_1,...,p_n$ satisfy $\val(p_1) = \val(a_1;p'_1)$, ..., $\val(p_n) = \val(a_n;p'_n)$, where $a_j\in \{\alpha_j, P_j?\alpha_j\}$ for $1\le j\le n$),
        $$\Commu(\pl(p_1,...,p_n), a)\dddef \val(a; \pl(p'_1,...,p'_n)) = \val(a)\circ \val(\pl(p'_1,...,p'_n)).$$
    \end{enumerate}
    \end{definition}



    The semantics of $\pl(p_1,...,p_n)$ is obtained by computing the parallel interaction between the $\trec$ programs at each instant.
    The computation is a process of continuously refining the event executed at the current instant.
    %Intuitively, the synchronous communication between $\trec$ programs is illustrated as follows:
    The symbol $a$ represents the current observed event.
    At the beginning, we observe that all events of the form $\alpha$ or $P?\alpha$ in $p_1,...,p_n$ are executable at the current instant.
    The function $\Commu$ continuously updates the current observed event $a$ according to the different situations (\rmn{1} - \rmn{3}) until
    all events that can be executed at the current instant are observed.
    Situation \rmn{1} says that we simply neglect the event $\mu$ since it neither does anything nor consumes time.
    In situation \rmn{2}, we ``unwrap'' the condition of the events $\varrho_1\&P_1?\beta_1$,...,$\varrho_m\&P_m?\beta_m$ in the programs $r_1$,...,$r_m$ according to whether the event $a$ matches the conditions $\varrho_1$,...,$\varrho_m$ (\rmn{2} (1) and \rmn{2} (2)).
    If the match is successful, we obtain a new observed event $a'$ by adding the events that are unwrapped from $\varrho_1\&P_1?\beta_1$,...,$\varrho_m\&P_m?\beta_m$.
    If the match is unsuccessful, the program deadlock occurs so the semantics of $\pl(p_1,...,p_n)$ is an empty set.
    In situation \rmn{3}, $\Commu$ returns the event that is executed at the current instant if all test events have been already unwrapped.

    \begin{example}
    Consider the $\trec$ program $p = \pl(\pl(\sig_1;\sig_4;\sig_1;\sig_4, \sig^\omega_2), \sig_3;\hat{\sig_4}?\sig_5;\sig_3;\sig_3;\sig_3)$ of Example~\ref{example:computation tree}, first there is
    $$\begin{aligned}\val(\pl(\sig_1;\sig_4;\sig_1;\sig_4, \sig^\omega_2)) =&\ \val(\sig_1|\sig_2)\circ \val(\pl(\sig_4;\sig_1;\sig_4, \sig^\omega_2))\\
    =&\ \val(\sig_1|\sig_2)\circ \val(\sig_4|\sig_2)\circ \val(\sig_1;\sig_4, \sig^\omega_2)\\
    =&\ \val(\sig_1|\sig_2)\circ \val(\sig_4|\sig_2)\circ \val(\sig_1|\sig_2)\circ \val(\pl(\sig_4, \sig^\omega_2))\\
    =&\ \val(\sig_1|\sig_2)\circ \val(\sig_4|\sig_2)\circ \val(\sig_1|\sig_2)\circ \val(\sig_4|\sig_2)\circ ...\\
    =&\ \val((\sig_1|\sig_2);(\sig_4|\sig_2);(\sig_1|\sig_2);(\sig_4|\sig_2);...), \end{aligned}$$
    which means $\pl(\sig_1;\sig_4;\sig_1;\sig_4, \sig^\omega_2)\equiv (\sig_1|\sig_2);(\sig_4|\sig_2);(\sig_1|\sig_2);(\sig_4|\sig_2);...$.
    The semantics of $p$ is given as:
    $$\begin{aligned}
    \val(p) =&\ \val(\pl((\sig_1|\sig_2);(\sig_4|\sig_2);(\sig_1|\sig_2);(\sig_4|\sig_2);..., \sig_3;\hat{\sig_4}?\sig_5;\sig_3;\sig_3;\sig_3))\\
    =&\ \val(\sig_1|\sig_2|\sig_3)\circ \val(\pl((\sig_4|\sig_2);(\sig_1|\sig_2);(\sig_4|\sig_2);..., \hat{\sig_4}?\sig_5;\sig_3;\sig_3;\sig_3))\\
    =&\ \val(\sig_1|\sig_2|\sig_3)\circ \val(\sig_4|\sig_2|\sig_5)\circ \val(\pl((\sig_1|\sig_2);(\sig_4|\sig_2);..., \sig_3;\sig_3;\sig_3))\\
    =&\ ...\\
    =&\ \val(\sig_1|\sig_2|\sig_3)\circ \val(\sig_4|\sig_2|\sig_5)\circ \val(\sig_1|\sig_2|\sig_3)\circ \val(\sig_4|\sig_2|\sig_3)\circ ....
    \end{aligned}$$
    The semantics of $p$ equals to the semantics of an infinite $\trec$ program
    $$(\sig_1|\sig_2|\sig_3);(\sig_4|\sig_2|\sig_5);(\sig_1|\sig_2|\sig_3);(\sig_4|\sig_2|\sig_3);....$$
    \end{example}

	We define the set of $\trec$ programs of an SEP as the following definition. 
	
    %An SEP consists of a set of all deterministic SEPs (i.e., $\trec$ programs) that capture its behaviour.
    %Next we introduce the $\trec$ set of an SEP.
    
    \begin{definition}[$\trec$ Set of SEPs]
    	\label{definition : trec of SEP}
    	The $\trec$ set of an SEP $p$, denoted as $\tau(p)$, is inductively defined as follows:
    	\begin{enumerate}[label=(\roman*)]
    		\item $\trecset(\mu)\dddef \{\mu\}$.
    		\item $\trecset(a)\dddef \{a\}$, where $a\in \{\alpha, \varrho\& P?\alpha\}$.
    		\item $\trecset(p;q)\dddef \{r_1; r_2\ |\ r_1\in \trecset(p), r_2\in \trecset(q), r_1\mbox{ is finite}\}\cup \{r_1\ |\ r_1\in \trecset(p), r_1\mbox{ is infinite}\}$.
    		\item $\trecset(p\cup q)\dddef \trecset(p)\cup \trecset(q)$.
    		\item $\trecset(p^\lup)\dddef \{r\ |\ r\in \trecset(p^n)\cup \trecset(p^\omega), n\ge 0\}$, where $p^0 = \mu$, $p^n = \underbrace{p;...;p}_n$ and $p^\omega = \underbrace{p;p;...}_{\infty}$.
    		%\item $\trecset(\paral (p_1,...,p_n))\ddef \{\pl (r_1, ...,r_n)\ |\ r_1\in \trecset(p_1),..., r_n\in \trecset(p_n)\}$.
    		\item $\trecset(\paral(p_1,...,p_n)) \dddef \{\pl(r_1,...,r_n)\ |\ r_1\in \tau(p_1), ..., r_n\in \tau(p_n)\}$.
    	\end{enumerate}
    \end{definition}
    
    Intuitively, $\trecset(p)$ defines the language of a program $p$, i.e., the set of all strings of $p$. 
    
    %Intuitively, $\trecset(p)$ capturesreturns the set of all `deterministic behaviour' of program $p$.
    %Prop.~\ref{theorem:relationship between p and trecset(p)} below declares their relationships.
    
    Based on Def.~\ref{definition:Semantics of Parallel trecs} and Def.~\ref{definition : trec of SEP}, we define the semantics for parallel SEPs as the following definition.

    \begin{definition}[Semantics of Parallel SEPs]
    \label{definition: Semantics for parallel SEP}
    For any programs $p_1, ...,p_n$,
    $$\val(\paral(p_1,...,p_n))\dddef\bigcup_{r_1\in \tau(p_1),...,r_n\in \tau(p_n)}\val(\pl(r_1,...,r_n)).$$
    \end{definition}
	 We use `$\equiv$' to express that two programs $p$ and $q$ are semantically equivalent, i.e., $p\equiv q$ iff $\val(p)=\val(q)$.
	 
	With the semantics of SEPs, now we introduce the notion of \emph{executable event} in SEP, which is used in the formal analysis of SEPs below. 
	
	
	\begin{definition}
		[Executable Events]
		\label{defnition:Executable Event}
		Given a $\trec$ program $q$, its executable events, denoted as $\Evt(q)$, is defined as follows:
		\begin{enumerate}[label=(\roman*)]
			\item $\Evt(\mu) \dddef \emptyset$.
			\item $\Evt(a) \dddef \{a\}$, where $a\in \{\alpha, \varrho\& P?\alpha\}$. 
			\item $\Evt(q_1;q_2)\dddef \Evt(q_1)\cup \Evt(q_2)$. 
			\item $\Evt(\cap(q_1,...,q_n))\dddef \Evt(q';q'')$, if $\cap(q_1,...,q_n)\equiv q';q''$, $\Evt(\cap(q_1,...,q_n))\dddef \emptyset$ otherwise. 
		\end{enumerate}
		
		Given a program $p$, its executable events are the set of executable events of all of its $\trec$ programs, defined as follows:
		$$\Evt(p) \dddef \bigcup_{r\in \trecset(p)}Evt(r).$$
		
		An event $a$ (where $a\in \{\alpha, \varrho\& P?\beta\}$) is a current executable event of $p$ iff there exists a $\trec$ program $q\in \trecset(p)$ such that $q \equiv a;q'$. 
	\end{definition}
	Intuitively, an executable event of a program is an event that is possibly executed by the program at some instant.
	A current executable event of a program is an executable event at the current instant.  
	
    %The set of traces of a parallel SEP equals
    The next proposition shows that the definitions of $\trec$ programs: Def.~\ref{definition:trec program} and \ref{definition : trec of SEP} are in accord with our intuition about the language of SEPs.
    It says that the $\trec$ set of an SEP exactly captures all behaviours of the SEP.
	
    \begin{proposition}[A Relation between $p$ and $\tau(p)$]
    \label{theorem:relationship between p and trecset(p)}
    Given an SEP $p$, there is $$\val(p) = \bigcup_{r\in \tau(p)}\val(r).$$
    \end{proposition}

    Prop.~\ref{theorem:relationship between p and trecset(p)} can be proved by induction on the syntactic structure of the program $p$ according to %Def.~\ref{definition: Semantics of SEP}, \ref{definition: Semantics of Sequential trec Program}, \ref{definition:Semantics of Parallel trecs}, \ref{definition : trec of SEP} and Def.~\ref{definition: Semantics for parallel SEP}. 
    Def.~\ref{definition: Semantics of SEP} - \ref{definition: Semantics for parallel SEP}. 
    %Here we just give an example of proof in Appendix
    %We omit the details here.
    \begin{proof}
    	For the basic case, we take event $\alpha$ for an	 example, the cases for the skip program $\mu$ and the event $\varrho\& P?\alpha$ are similar. 
    	Based on Def.~\ref{definition : trec of SEP}, we have $\trecset(\alpha) = \{\alpha\}$, so obviously $\val(\alpha) = \bigcup_{r\in \trecset(\alpha)} \val(r) = \val(\alpha)$.  
    	
    	For the inductive case, we take the sequence program $p;q$ for example, other cases are similar. 
    	Suppose $\val(p) = \bigcup_{r\in \trecset(p)}\val(r)$  and $\val(q) = \bigcup_{r\in \trecset(q)}\val(r)$ hold. 
    	According to Def.~\ref{definition: Semantics of SEP}, we have $\val(p;q) = \val(p)\circ val(q) = (\bigcup_{r\in \trecset(p)}\val(r)) \circ (\bigcup_{r\in \trecset(q)}\val(r)) = \bigcup_{r_1\in \trecset(p), r_2\in \trecset(q)}\val(r_1)\circ \val(r_2) = \bigcup_{r_1\in \trecset(p), r_2\in \trecset(q)}\val(r_1; r_2)$. 
    	According to Def.~\ref{definition : trec of SEP}, we immediately obtain the result. 
    	
    	
    	
    \end{proof}

    Based on the semantics of SEPs we derive some semantic equivalence relations between programs, which play an important role in the rewrite rules for parallel SEPs later given in \Sect~\ref{subsection:Rewriting Rules for Parallel SEPs}.

    \begin{proposition}
    \label{proposition:equivalent relations}
    For any SEPs $p,q,r$, $p_1,...,p_n$, there are equivalence relations between SEPs listed as follows:
    \begin{enumerate}[label=(\roman*)]
    \item Relations for $\mu$: $\mu;p\equiv p\equiv p;\mu$, $\mu^\lup\equiv \mu$, $\paral(p_1,...,p_{i-1},p_i,p_{i+1},...,p_n)\equiv \paral(p_1,...,p_{i-1},p_{i+1},...,p_n)$ (where $p_i=\mu$).
    \item Associative law for $;$: $(p;q);r \equiv p;(q;r)$.
    \item Commutative, associative laws for $\cup$: $p\cup q\equiv q\cup p$, $(p\cup q)\cup r\equiv p\cup (q\cup r)$.
    \item Distributive law of $;$ over $\cup$: $(p\cup q);r\equiv p;r\cup q;r$, $r;(p\cup q)\equiv (r;p)\cup (r;q)$.
    \item Relation for $\lup$: $p^\lup\equiv \mu\cup p;p^\lup$.
    \item Commutative law for $\paral$: $\paral(p_1,...,p_i,...,p_j,...,p_n)\equiv \paral(p_1,...,p_j,...,p_i,...,p_n)$.
    \item Distributive law of $\paral$ over $\cup$: $\paral(p_1,...,(p_{i,1}\cup p_{i,2}),...,p_n)\equiv \paral(p_1,...,p_{i,1},...,p_n)\cup \paral(p_1,...,p_{i,2},...,p_n)$.
    \end{enumerate}
    \end{proposition}

    All relations in Prop.~\ref{proposition:equivalent relations} can be directly obtained from the semantics of SEPs.
    %We omit their detailed proofs.
    \rmn{1}-\rmn{4} and \rmn{6} are obvious.
    The relations in \rmn{1} shows that $\mu$ is a neural element for the sequential operator $;$, the loop operator $\lup$ and the parallel operator $\paral$. 	 
    Intuitively, in \rmn{5} the loop program $p^\lup$ executing for 0 or more times can be split into a program executing for 0 time ($\mu$) and a program executing for 1 or more times ($p;p^\lup$).
    \rmn{7} is a direct result of Def.~\ref{definition: Semantics for parallel SEP}.
	
	\begin{proof}[The Proof of Prop.~\ref{proposition:equivalent relations}]
		We only give the proof for \rmn{5} as an example, other relations are similar. 	 
		On the one hand, according to Def.~\ref{definition: Semantics of SEP}, we have $\val(p^\lup) = (\bigcup_{n\ge 0}\val^n(p)) \cup \val^\omega (p) = \val^0(p)\cup (\bigcup_{n\ge 1}\val^n(p)) \cup \val^\omega(p) = \val(\mu)\cup (\bigcup_{n\ge 1}\val^n(p)) \cup \val^\omega(p)$. 
		On the other hand, we have $\val(p;p^\lup) = \val(p)\circ \val(p^\lup) = \val(p)\circ ((\bigcup_{n\ge 0}\val^n(p)) \cup \val^\omega (p)) = (\val(p)\circ (\bigcup_{n\ge 0}\val^n(p))) \cup (\val(p)\circ \val^\omega(p)) = (\bigcup_{n\ge 0}\val(p)\circ \val^n(p))\cup (\val(p)\circ \val^\omega(p)) = (\bigcup_{n\ge 1}\val^n(p))\cup \val^\omega(p)$. 
		So we have $\val(p^\lup) = \val(\mu)\cup \val(p;p^\lup) = \val(\mu\cup p;p^\lup)$. 
		
		%For relation \rmn{7}: According to Def.~\ref{definition: Semantics for parallel SEP} we have 
		
		
	\end{proof}

    \subsubsection{Consistent SEPs}
    In synchronous models, due to the basic assumption that events can occur simultaneously at an instant, the behaviour of programs may cause logical inconsistencies~\cite{Berry99theconstructive}.
    In SEP, similar problem exists because of the synchronous execution mechanism we introduce. 
    We classify the logical inconsistencies in SEP into two types:
    
    \begin{enumerate}[label=(\arabic*)]
    	\item At some instant, there are two simultaneous assignments to a single variable or two occurrences of a single signal. 
    	This must be avoided since
    	in the combinational event, all events are assumed to be executed simultaneously and there is no notion of \emph{micro steps} with which the order between these events can be defined. 
    	%and there is no order between them (so there is no notion of `micro steps' as in programming langauges such as Esterel~\cite{}), the semantics of SEP does not allow two simultaneous assignments to a single variable. e.g., event $(x:=1 | x:=2)$ is not allowed. 
    	%so we do not allow two simultaneous assignments to a single variable and two occurrences of a single signal. 
    	%See programs $p_1, p_2$ as an example in Example.~\ref{example: Consistent SEP} below. 
    	%e.g., event  $(x:=1 | x:=2)$ and event $(\sig ! 1 | \sig ! 2)$ should be avoided. 
    	
    	%\item For simplicity, in SEP we do not allow a signal emits more than once at an instant.  e.g., event $(\sig ! 1 | \sig ! 2)$ is not allowed. 
    	
    	\item 
    	At some instant, an event contradicts some condition of this event. 
    	This must be avoided because, intuitively, a signal must be emitted right after its test condition is satisfied. 
    	%See program $p_3$ as an example in Example.~\ref{example: Consistent SEP} below.
    	%e.g., program like $\paral(\bar{\sig_1}?\sig_2, \hat{\sig_2}?\sig_1)$ should be avoided since the executing event at current instant $(\sig_1 | \sig_2)$ contradicts the condition $\bar{\sig_1}$. 
    \end{enumerate}
	
	Based on these two types of logical inconsistencies, we formally define a set of \emph{consistent SEPs} to confine the semantics of SEPs given in Def.~\ref{definition: Semantics of SEP} and \ref{definition:Semantics of Parallel trecs}. 
	In this paper, we only focus on the SEPs whose semantics matches the following definition. 
	
    \ifx
    The semantics of SEPs defined above is not suitable for all programs whose syntax is given by Def.~\ref{definition: Synchronous Event Program}.
    In SEP, 
    e.g., we fail to give a semantics for an event $(x:=1|x:=2)$, where $x$ has to be assigned to value $1$ and $2$ at the same time!
    We should not give a semantics for a parallel program like $\paral(\sig_2, \bar{\sig_1}?\sig_1)$, which executes event $(\sig_2|\sig_1)$ at current instant according to  Def.~\ref{definition:Semantics of Parallel trecs}, but it contradicts the condition $\bar{\sig_1}$.
	e.g., 
	\fi
		
    \ifx
    As in other synchronous languages like Esterel~\cite{BERRY199287}, where a `constructive' semantics was proposed to preserve the consistency of the program,
    in CDL instead of giving a constructive semantics,

    We define a set of SEPs that is `consistent' to the semantics given above.
    We introduce `healthy SEP' that satisfies the basic intuitive assumptions in synchronous models.
    Without specially mentioned, all programs discussed in this paper are healthy ones.
	\fi
	    
    \begin{definition}[Consistent SEPs]
    \label{definition:Healthy SEP}
    An SEP $p$ is consistent iff it satisfies the following properties:
    \begin{enumerate}[label=(\roman*)]
    \item For any executable event $a\in \Evt(p)$, there exist at most one assignment $x:=e$ for each variable $x$, and at most one signal $\sig!e$ for each signal $\sig$.
    \item For any parallel program $\paral(p_1,...,p_n)$ in $p$ and any executable event $a\in \Evt(\paral(p_1,...,p_n))$,
    %At each instant, in each executable event $a$ of a parallel program $\paral(p_1,...,p_n)$ in $p$, 
    for each signal $\sig$ in $a$, if $\sig$ appears in an event $\varrho?\alpha'$ in $p_1,...,p_n$,
    then $\match(a,\varrho)$ must hold.
    \end{enumerate}
    \end{definition}

    In Def.~\ref{definition:Healthy SEP}, properties \rmn{1} and \rmn{2} correspond to the types of logical inconsistencies (1) and (2) respectively. 
    %says that the executing event of any parallel program must accord with each signal testing condition that defines it.
    %Not hard to see that

    \begin{example}
    \label{example: Consistent SEP}
    Programs $p_1 = (x:=1 | x:=2)$ and $p_2 = (\sig!2 | \sig!3)$ are not consistent, since they do not satisfy Def.~\ref{definition:Healthy SEP} \rmn{1}.
    Program $p_3 = \paral(\bar{\sig_1}?\sig_2, \bar{\sig_2}?\sig_1)$ is not consistent, since it does not satisfy Def.~\ref{definition:Healthy SEP} \rmn{2}: on the one hand, its current executable event is $(\sig_1|\sig_2)$ according to Def.~\ref{definition:Semantics of Parallel trecs}, on the other hand, $\sig_2$ comes from event $\bar{\sig_1}?\sig_2$, but $(\sig_1|\sig_2)$ does not satisfy $\bar{\sig_1}$.
    \end{example}

    In other synchronous languages like Esterel~\cite{BERRY199287}, a \emph{constructive semantics} was proposed to preserve the consistency of the program,
    where an algorithm was developed to check whether a program satisfies the consistent properties (similar to the properties given in Def.~\ref{definition:Healthy SEP}).
    In this paper, we mainly focus on the CDL and its proof system, so 
    instead of giving a constructive semantics of SEPs, we restrict ourselves to focus only on the consistent SEPs. 
    %A constructive semantics 
    
    

    \ifx
    the semantics that guarantees the assumptions listed in Def.~\ref{definition:Healthy SEP} is called `constructive'~\cite{Berry99theconstructive}.
    There an algorithm has been developed to check whether an Esterel program is consistent or not.
    Our semantics of SEPs defined in Def.~\ref{definition: Semantics of SEP}, \ref{definition: Semantics for parallel SEP} is not constructive in this sense.
    In this paper, instead of proposing a constructive semantics, we restrict ourselves to only consider healthy SEPs.
    %and focus on logic itself.
    \fi


    \subsubsection{Semantics of CDL}
    In \Sect~\ref{section: Preliminaries of CCSL}, clock relations are defined under a schedule $\sigma$ and a configuration $\mcl{X}_\sigma$.
    In order to introduce clock relations into dynamic logic we define the semantics of clock relations in the Kripke frame of CDL.
    \begin{definition}[Semantics of Clock Relations in Kripke Frames]
    \label{definition:Semantics of Clock Relations in Kripke frame}
    Given a trace $tr$, the semantics of clock relations $tr\vDash_{ccsl}\Rel$ is defined as:
    $$tr\vDash_{ccsl}\Rel\mbox{ iff for each }i\in \mbb{N}^+, tr(i)\in \val(\hbar(\Rel)), $$
    where the function $\hbar(\Rel)$ returns an AFOL formula that describes what should be held at each instant for each clock relation. It is given as follows:
    \begin{enumerate}[label=(\arabic*)]
    \item $\hbar(c_1\subseteq c_2)\dddef c^s_1=1\to c^s_2=1$.
    \item $\hbar(c_1\ssharp c_2)\dddef c^s_1=0\vee c^s_2=0$.
    \item $\hbar(c_1\prec c_2)\dddef c^n_1>c^n_2 \vee (c^n_1 = c^n_2 \rightarrow c^s_1 = 0)$.
    \item $\hbar(c_1\preceq c_2)\dddef c^n_1\ge c^n_2$.
    \item $\displaystyle \hbar(\curlywedge(\RRel_1,...,\RRel_n)\dddef \bigwedge_{1\le i\le n} \hbar(\RRel_i)$.
    \end{enumerate}
    \end{definition}

    A trace satisfies a clock relation iff each of its states (from the second state $tr(1)$) satisfies an AFOL formula that exactly captures the corresponding condition of this clock relation in Table~\ref{table:semantics of CCSL},
    which should hold at each instant in a schedule.
    The semantics of $\val(\hbar(\Rel))$ is defined in Def.~\ref{definition: Semantics of CDL Formula} below.

    From Def.~\ref{definition:Semantics of Clock Relations in Kripke frame} we can see a connection between the semantics of clock relations in CCSL (Table~\ref{table:semantics of CCSL}) and that in the Kripke frame of CDL, described in the following proposition.

    \begin{proposition}[$tr\vDash_{ccsl}\Rel$ vs. $\sigma\vDash_{ccsl}\Rel$]
    \label{proposition:relation beween CCSL cr and CDL cr}
    Any trace $tr$ that satisfies $tr(0)(c^n) = 0$ and $tr(0)(c^s) = 0$ for any clock $c$ is called an \emph{initial trace}.
    For any schedule $\sigma$, there exists an initial trace, denoted by $tr^\sigma$, such that 
    %For any initial trace $tr$, we can construct a schedule $\sigma^{tr}$ such that
    %For any trace $tr$, let $\sigma^{tr}$ be the schedule s.t.
    \begin{enumerate}[label=(\roman*)]
    \item $\sigma(0)=\emptyset$.
    \item for each clock $c$ and $i\ge 0$, $\mcl{X}_\sigma(c,i) = tr^\sigma(i)(c^n)$.
    \item for each clock $c$ and $i\ge 0$, $c\in \sigma(i)$ iff $tr^\sigma(i)(c^s)=1$.
    \end{enumerate}
    More, there is $$tr^\sigma\vDash_{ccsl} \Rel\mbox{\quad iff\quad}\sigma\vDash_{ccsl}\Rel. $$
    
    Given an initial trace $tr_0$, if there exists a schedule $\sigma_0$ such that $tr_0 = tr^\sigma$, then we often denote this schedule as $\sigma^{tr_0}$. 
    \end{proposition}

    Prop.~\ref{proposition:relation beween CCSL cr and CDL cr} can be proved by induction on the structure of $\Rel$ based on Table~\ref{table:semantics of CCSL}, Def.~\ref{definition:Semantics of Clock Relations in Kripke frame} and Def.~\ref{definition: Semantics of CDL Formula}.
	\begin{proof}
		For basic cases, we take $c_1\prec c_2$ as an example, other basic cases are similar. 
		On the one direction, if $tr^\sigma\vDash_{ccsl} c_1\prec c_2$ holds, we now prove $\sigma\vDash_{ccsl}c_1\prec c_2$. 
		By Def.~\ref{definition:Semantics of Clock Relations in Kripke frame} we have 
		for any $i\in \mbb{N}^+, tr^\sigma(i)\in \val(\hbar(c_1\prec c_2))$. 
		According to the definition of $\hbar$ in Def.~\ref{definition:Semantics of Clock Relations in Kripke frame} and Def.~\ref{definition: Semantics of CDL Formula} below we have 
		$tr^\sigma(i)(c^n_1) > tr(i)(c^n_2) \vee (tr^\sigma(i)(c^n_1) = tr^\sigma(i)(c^n_2) \to tr^\sigma(i)(c^s_1)=0)$ holds for any $i\in \mbb{N}^+$.
		By the construction of $tr^\sigma$, we know that  
		for any $i\ge 0$, $\mcl{X}_\sigma(c,i) = tr^\sigma(i)(c^n)$ holds, where $c\in \{c_1, c_2\}$. 
		Therefore, according to the semantics of CCSL in Table~\ref{table:semantics of CCSL}, we get $\sigma \vDash_{ccsl}c_1\prec c_2$. 
		The proof for the other direction is similar. 
		
		The inductive case $\Rel = \curlywedge (\RRel_1,...,\RRel_n)$ is obvious. 
	\end{proof}
	
	Prop.~\ref{proposition:relation beween CCSL cr and CDL cr} says that for any schedule $\sigma$, we can have an initial trace $tr^\sigma$ whose behaviour can be exactly captured by $\sigma$. Moreover, the satisfaction relation $tr^\sigma\vDash_{ccsl}\Rel$ exactly captures the semantics of $\Rel$ in CCSL.
	
    When $tr$ is not an initial trace, the schedule $\sigma^{tr}$ satisfying conditions \rmn{1} - \rmn{3} above does not exist.
    In this case, $tr\vDash_{ccsl}\Rel$ actually captures partial information about the satisfaction $\sigma\vDash_{ccsl}\Rel$ of some schedule $\sigma$,
    where $\rho$, one of suffixes of $\sigma$, 
    %whose one of suffixes, denoted by $\rho$, 
    satisfies conditions \rmn{2} - \rmn{3} above.


    %the satisfaction of $\sigma\vDash_{ccsl}\Rel$ of a suffix $\sigma$ of some schedule s.t.


    \ifx
    if there exists a corresponding schedule $\sigma^{tr}$ whose behaviour can be exactly captured by trace $tr$,
    then the semantics of schedule $\sigma^{tr}$ can be reflected by that of trace $tr$.
    %It is easy to see that for any trace $tr$, $\sigma^{tr}$ exists iff $tr(0)$ satisfies that for any clock $c$, $tr(0)(c^n) = 0$ and $tr(0)(c^s) = 0$.
    \fi

    Fig.~\ref{figure:clock relation in Kripke frame} shows a corresponding relation between a schedule $\sigma$ and its corresponding initial trace $tr^\sigma=s_0s_1...s_i...$.
    Intuitively, %because SEP is a synchronous model, 
    according to the semantics of SEPs, 
    each state of the trace $tr^\sigma$ exactly represents an instant in the schedule $\sigma$.
    The combinational event executed at the instant $i$ ($i\ge 1$) is $\alpha_i$.
    %If $tr'=s_2s_3...s_i...$ is a non-initial trace,

    \ifx
    According to the syntax of $\Rel$ given in Def.~\ref{definition: CDL Formula}, $tr\vDash_{ccsl}\Rel$ can be defined accordingly.
    Intuitively, because SEP is a synchronous program model, in each trace $tr$ of an SEP, each state exactly represents an instant of the schedule $\sigma^{tr}$.
    In other words, the `discrete-time line' of schedule $\sigma^{tr}$ are exactly captured by trace $tr$.
    Fig.~\ref{figure:clock relation in Kripke frame} shows a corresponding relation between $tr$ and $\sigma^{tr}$.
    %By Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}, we see that the `discrete time line' of shc
    \fi

    \begin{figure}[htbp]
    \centering
    \scalebox{0.8}{
    \begin{tikzpicture}[->,>=stealth', node distance=1.5cm]
     \node[state4, label=north:$s_0$, fill=red, initial] (s1) {};
      %\node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
      %\node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
      \node[state4, right of=s1, label=north:$s_1$] (s2) {};
      \node[state4, right of=s2, label=north:$s_2$] (s3) {};
      \node[state4, right of=s3, draw=none] (s4) {...};
      \node[state4, right of=s4, label=north:$s_i$] (s5) {};
      \node[state4, right of=s5, draw=none] (s6) {...};

       \node[state2, yshift=-1cm, draw=none] (t1) {$\sigma	(0)=\emptyset$};
      %\node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
      %\node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
      \node[state2, right of=t1, draw=none] (t2) {$\sigma(1)$};
      \node[state2, right of=t2, draw=none] (t3) {$\sigma(2)$};
      \node[state2, right of=t3, draw=none] (t4) {};
      \node[state2, right of=t4, draw=none] (t5) {$\sigma(i)$};
      \node[state2, right of=t5, draw=none] (t6) {};
      %\node[yshift=-0.75cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge node [above,black] {$\alpha_1$} (s2)
     (s2) edge node [above,black] {$\alpha_2$} (s3)
     (s3) edge node [above,black] {$\alpha_3$} (s4)
     (s4) edge node [above,black] {$\alpha_i$} (s5)
     (s5) edge node [above,black] {$\alpha_{i+1}$} (s6)

     %(s3.mid) edge [snake=brace, raise snake=0.5cm, -] node [above=0.75cm] {$tr'$} (s6.mid)
     %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
     %(s1) edge [snake=brace, raise snake=0.2cm, -] node [above=0.25cm] {$Rel^0$} (s3)

     %(s3) edge [snake=brace, raise snake=-0.2cm, -] node [right=-0.2cm] {$p\cup q$} (s2)
     %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
     %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
     ;
     \draw [dashed] (t1.north) -- (s1.south);
     \draw [dashed] (t2.north) -- (s2.south);
     \draw [dashed] (t3.north) -- (s3.south);
     \draw [dashed] (t5.north) -- (s5.south);
     %;
    \end{tikzpicture}
    }%end scalebox
        \captionsetup{font=footnotesize}
        \caption{\footnotesize{The corresponding relation between trace $tr$ and schedule $\sigma^{tr}$}}
        \label{figure:clock relation in Kripke frame}
    \end{figure}

    \ifx
    From Definition~\ref{definition: Semantics of SEP} easy to see the connection between a trace $tr$ and a schedule $\sigma$ defined in Sect.~\ref{}.
    For each $tr$, there is a corresponding $\sigma^{tr}$ such that
    for all clock $c$, $i\in \mbb{N}$, $tr(i)(b^c)=tt$ iff $c\in \sigma^{tr}(i)$.
    We introduce a relation $tr\vDash Rel^0$. For any CCSL formula $X\in \{Rel^0, Cdf\}$, $tr\vDash X$ holds iff $\sigma^{tr}\vDash_{ccsl} X$.
    %So in the rest of paper we sometimes mix the usage of $tr$ and its corresponding $\sigma^{tr}$, e.g. we
    %write $tr\vDash_{ccsl} \phi$ instead of $\sigma^{tr}\vDash_{ccsl}\phi$.

    Definition~\ref{} gives the semantics of sCDL formula, where except \rmn{1}-\rmn{3}, the definitions
    keep the same as in dynamic logic.
    %\section{Quantifier-free First Order Process Logic}
    \fi

    \begin{example}
    For schedule $\sigma = \{\} \{c\}$, its corresponding initial trace is the trace $tr = ss'$ discussed in Example~\ref{example:semantics of sequential SEP}, 
    %The corresponding schedule of trace $tr = ss'$ discussed in Example~\ref{example:semantics of sequential SEP} is schedule $\sigma^{tr} = \{\} \{c\}$,
    where $\mcl{X}_{\sigma}(c,0) = tr(0)(c^n)=0$, $\mcl{X}_{\sigma}(d,0) = tr(0)(d^n) = 0$, $\mcl{X}_{\sigma}(c,1) = tr(1)(c^n) = 1$, $\mcl{X}_{\sigma}(d,1) =tr(1)(d^n) = 0$.
    $c,d\notin \sigma(0)$ since $tr(0)(c^s) = tr(0)(d^s) = 0$,
    $c\in \sigma(1)$ since $tr(1)(c^s) = 1$.
    \end{example}


    \begin{definition}[Semantics of CDL Formulae]
    \label{definition: Semantics of CDL Formula}
    %Given a Kripke frame $(S, val)$, the semantics of CDL formulae is given as follows:
    %\item $val(At_{cr})=\{tr\ |\ tr\vDash_{ccsl} At_{cr}\}$, where $\vDash_{ccsl}$ is just the satisfaction given in Section~\ref{}.
    Given a set of clocks $\mcl{C}$ and a set of general variables $\Var$, for any CDL formula $\phi$, its semantics is given as a Kripke frame $(S, \val)$ defined as follows:
    \begin{enumerate}[label=(\roman*)]
    \item $\val(tt)\dddef S$.
    \item $\val(E\le E')\dddef\{s\ |\ \eval_s(E)\le \eval_s(E')\}$.
    %\item $\val(\lmap{e^0}{e})=\{(s, h)\ |\ h(s(e^0))=s(e)\}$.
    \item $\val([p]\Rel)\dddef\{s\ |\ \mbox{for all } tr \mbox{ with }s=tr_b \mbox{ and }tr\in \val(p), tr\vDash_{ccsl} \Rel\}$.
    %\item $\val(\la p\ra\neg Rel^0)=\{tr\ |\ \mbox{there exists a } tr'\in \val(p) \mbox{ with } tr\cdot tr' \mbox{ exists} \mbox{ such that } tr'\vDash \neg Rel^0\}$;
    \item $\val([p]\phi)\dddef\{s\ |\ \mbox{for all }tr\in \val(p)\mbox{ with }tr_b=s, \mbox{ if }tr_e\mbox{ exists, then }tr_e\in \val(\phi)\}$.
    \item $\val(\neg\phi)\dddef\{s\ |\ s\notin \val(\phi)\}$.
    \item $\val(\phi\wedge \varphi)\dddef \val(\phi)\cap \val(\varphi)$.
    \item $\val(\forall x.\phi)\dddef \{s\ |\ \mbox{for each }v_0\in \mbb{Z}, s\in \val(\phi [v_0/x])\}$.
    %\rmn{8} $\val(\forall \gamma\phi)=\{tr\ |\ tr\in \val(\phi [c/\gamma]), c\in \mcl{C}\}$.
    \end{enumerate}
	We introduce a symbol $\mscdl$ to express the satisfaction relation between a CDL formula $\phi$ and a state $s$ in set $\val(\phi)$. 
	$s$ satisfies $\phi$, denoted by $s\mscdl \phi$, is defined as: 
	$$s\mscdl\phi \mbox{ iff } s\in \val(\phi).$$
	If for all state $s$, $s\mscdl \phi$ holds, then $\phi$ is said to be valid, denoted as $\mscdl \phi$.
    \end{definition}

    The semantics of CDL formulae is based on states.
    %\rmn{3} is a variation of the definition of dynamic temporal formula `$[p]\Box \phi$' in \cite{conf/lfcs/Platzer07}.
    %But different from the temporal formulae there, a trace satisfying a clock relation is from the second state of the trace due to the definition of $\vDash_{ccsl}$ in Sect.~\ref{section: Preliminaries of CCSL}.
    In \rmn{3}, a trace satisfying a clock relation is from the second state of the trace due to Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}. %the definition of $\vDash_{ccsl}$ in Sect.~\ref{section: Preliminaries of CCSL}.
    So state $s$ itself is unrelated to $\Rel$.
    %is equivalent to the corresponding definition in FODL, but is based on traces.
    \rmn{4}-\rmn{7} are similar to the definitions in FODL~\cite{journals/sigact/HarelKT01}, except that the semantics of SEPs is based on traces.
    \rmn{4} requires that the trace must be finite, indicating that we only consider the \emph{partial correctness} of $\phi$ for the program $p$:
    it only matters whether $\phi$ holds on those states on which the program $p$ terminates.

    Fig.~\ref{figure:semantics of CDL formula} gives an illustration of $[p]\phi$ and $[p]\Rel$, where the snake arrow indicates an executing trace (which could be infinite) of the program.
    %Blue states indicate that they satisfy
    The blue states satisfy $[p]\phi$ (resp. $[p]\Rel$), while
    the red states (resp. traces) satisfy the formula $\phi$ (resp. the relation $\Rel$).
    %Some states are tagged with a formula aside that they satisfy.
    %States and  are colored red to stress that they satisfy the corresponding formulae ($\phi$, $\Rel$).

    \begin{figure}[htbp]
    \centering
    \scalebox{0.8}{
    \begin{tabular}{c c c}
        \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4,label=west:\mbox{$[p]\phi$}, fill=blue] (s1) {};
      \node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
      \node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
      \node[state4, right of=s1, draw=none, xshift=1cm] (s4) {};
      \node[state4, right of=s1, yshift=0.5cm, draw=none] (x1) {...};
      \node[state4, right of=s1, yshift=-0.5cm, draw=none] (x2) {...};
      \node[statex, draw=none, right of=s1, yshift=-0.5cm, xshift=1.5cm] (txt1) {infinite trace};
     \path
     (s1) edge [edge3] node [below,black] {$p$} (s2)
     (s1) edge [edge3] node [below, black] {$p$} (s3)
     (s1) edge [edge3] node [below, black] {$p$} (s4)
     ;

     \draw (txt1.north) -- ([xshift=-0.5cm]s4.south);
    \end{tikzpicture}
        &
        vs.
        &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4,label=west:\mbox{$[p]\Rel$}, fill=blue] (s1) {};
      \node[state4, right of=s1,yshift=-1cm, fill=red,label=east:$\phi$] (s2) {};
      \node[state4, right of=s1,yshift=1cm, fill=red,label=east:$\phi$] (s3) {};
      \node[state4, right of=s1, draw=none, xshift=1cm] (s4) {};
      \node[state4, right of=s1, yshift=0.5cm, draw=none] (x1) {...};
      \node[state4, right of=s1, yshift=-0.5cm, draw=none] (x2) {...};
      \node[statex, draw=none, right of=s1, yshift=-0.5cm, xshift=1.5cm] (txt1) {infinite trace};
     \path
     (s1) edge [edge2, red] node [above,black] {$p$} (s2)
     (s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm, xshift=-0.2cm] {$\Rel$} (s1)

     (s1) edge [edge2, red] node [above, black] {$p$} (s3)
     (s1) edge [edge2, red] node [above, black] {$p$} (s4)
     ;
     \draw (txt1.north) -- ([xshift=-0.5cm]s4.south);
    \end{tikzpicture}\\
    $([p]\phi)$ & & $([p]\Rel)$
    \end{tabular}
    }%end scalebox
        \captionsetup{font=footnotesize}
        \caption{\footnotesize{The semantics of formulae $[p]\phi$ and $[p]\Rel$}}
        \label{figure:semantics of CDL formula}
    \end{figure}

    %After the semantics of CDL is defined, we give
	
	\ifx
    \subsubsection{Satisfaction Relation}
    With the semantics of CDL we introduce the satisfaction relation of CDL logic.
    Given a state $s$ and any CDL formula $\phi$, the satisfaction relation $s\mscdl \phi$ is defined as:
    $$s\mscdl\phi \mbox{ iff } s\in val(\phi).$$
    If for all state $s$, $s\mscdl \phi$ holds, then $\phi$ is said to be `valid', denoted as $\mscdl \phi$.
    \fi
    
    \ifx
    true under the interpretation of CDL defined in Sect.~\ref{subsection: The Semantics of CDL} (or `CDL-valid'), denoted as
    $\mscdl \phi.$
    If $\phi$ is true under all interpretations, we say $\phi$ is valid, denoted as $\models \phi.$
    \fi

    \ifx
    \begin{mydef}[Healthy cDL Formula]
    A cDL formula $\phi$ is healthy if all clocks appeared in $\phi$ can be found in the SEPs in $\phi$.

    The set of healthy cDL formulae is denoted by $\bff{cDLF}^{h}$.
    \end{mydef}
    \fi
    \ifx
    \subsubsection{Satisfaction}
    The sCDL (as well as CDL) are interpreted under the conventional natural number theory $(\mbb{N}^+, 0, +, \cdot, \le)$.

    The interpretation of sCDL Calculus $\mfr{I}_{scdl}$ has the domain $\mfr{D}_{scdl}=\mbb{N}^+\cup \mcl{C}$. It interprets each constant, function and relation in $\Sigma_{afo}$ as their usual meanings, each program events and operators as in Definition~\ref{}, and each constant, function and relation in sCDL formulae as in Definition~\ref{}, ~\ref{}.

    Given an evaluation $s$ and any sCDL formula $\phi$, the satisfaction relation $\mfr{I}_{scdl}, s\models \phi$ is defined as:
    $$\mfr{I}_{scdl}, s\models \phi \mbox{ iff } tr\vDash \phi \mbox{ for any } tr \mbox{ with } tr_e=s.$$
    If for all evaluation $s$, $\mfr{I}_{scdl}, s\models \phi$ holds, then we say $\phi$ is true under the interpretation $\mfr{I}_{scdl}$ (or $\mfr{I}_{scdl}-$valid), denoted as
    $$\mfr{I}_{scdl}\models \phi.$$
    If for all interpretations $\mfr{I}$, $\mfr{I}\models \phi$ holds, then we say $\phi$ is valid, denoted as:
    $$\models \phi.$$
    \fi


    \section{The Proof System of CDL}
    \label{section: The Proof System of CDL}
    In this section we propose a proof system of CDL, which provides a modular way of transforming a CDL formula into QF-AFOL formulae.
    As indicated in Fig.~\ref{figure:An overview of CDL}, 
    the proof system of CDL is based on that of FODL~\cite{journals/sigact/HarelKT01}.
    It consists of the rules for sequential SEPs and the rewrite rules for parallel SEPs.
    The rules for sequential SEPs are mainly based on those for the program models of FODL.
    For parallel SEPs,  the rewrite rules provide an automatic way of transforming a parallel program into a sequential one.

	In \Sect~\ref{section:Sequent Calculus} we introduce a concept of \emph{sequent} that is used in the rest of the section as a logical argumentation to express proof rules. 
    In \Sect~\ref{subsection:Proof Rules for Sequential SEPs} we build the rules for sequential SEPs, then in \Sect~\ref{subsection:Rewriting Rules for Parallel SEPs} we build the rewrite rules for parallel SEPs
    and introduce the algorithms for reducing a program in parallel form into a program in sequential form.
    In \Sect~\ref{subsection:An Example} we illustrate how to use this proof system to verify CCSL specifications of synchronous systems by analyzing a simple example.

    \ifx
    In this section we propose a proof system, which forms the foundation of the verification of CDL.
    Proof system provides a modular way of transforming a CDL logic into QF-AFOL formulae.
    Our proof system is based on that of FODL~\cite{journals/sigact/HarelKT01}, which is only for sequential program models.
    For concurrent SEPs we propose rewriting rules of SEPs that can transform a concurrent program into a sequential one.
    The transformation procedure is similar to the process of expanding a parallel CCS process into a sequential one~\cite{journals/corr/abs-0904-0034}.
    We propose an algorithm for this transformation, which can be seen as a variation of the Brzozowski's algebraic method~\cite{journals/jacm/Brzozowski64}.
    \fi
	
	     \subsection{Sequent Calculus}
	     \label{section:Sequent Calculus}
	A sequent, a concept first proposed by Gentzen~\cite{gentzen1934untersuchungen}, is a form to express logical formulae and their proofs.
	A sequent is of the form $$\Gamma\Rightarrow\Delta,$$
	%defined as follows:
	%     $$\begin{aligned}\Gamma\Rightarrow \Delta\dddef&\ \bigwedge_{\phi\in \Gamma}\phi\to \bigvee_{\varphi\in \Delta}\varphi,\end{aligned}$$
	where $\Gamma, \Delta$ are two finite \emph{multi-sets} of logical formulae.
	The semantics of sequent $\Gamma\Rightarrow\Delta$ is that of formula
	$$\bigwedge_{\phi\in \Gamma}\phi\to \bigvee_{\varphi\in \Delta}\varphi,$$
	meaning that if all formulae of $\Gamma$ hold, then at least some formula of $\Delta$ holds.
	When $\Gamma$ or $\Delta$ is empty, we use $\cdot$ to denote it. 
	%We use $\cdot$ to indicate $\Gamma$ or $\Delta$ is empty.
	\ifx
	The conditions when either (both) $\Gamma$ or (and) $\Delta$ is (are) empty set(s) is (are) expressed as follows:
	(1) $\cdot \Rightarrow \Delta\dddef \mathit{tt}\to \bigvee_{\varphi\in \Delta}\varphi$; (2) $\Gamma\Rightarrow \cdot\dddef \bigwedge_{\phi\in \Gamma}\phi\to \mathit{ff}$; (3) $\cdot\Rightarrow \cdot\dddef \mathit{tt}\to \mathit{ff}$.
	$tt, \ff$ are the boolean true and boolean false.
	We use dot $\cdot$ to indicate $\Gamma$ or $\Delta$ is empty.
	\fi	
	% $\Gamma$ is usually called truth context, while $\Delta$ is usually called falsehood context.
	%It means that every formula in $\Gamma$ holds can conclude that at least one of formulae in $\Delta$ holds.
	%Usually we use $\cdot$ to represent an empty context. If the truth context is empty, then the left hand side of $\to$ is true. If the falsehood context is empty, then the right hand side of $\to$ is false. That is:
	%where we use $\cdot$ to indicate $\Gamma$ or $\Delta$ is empty.
	
	A rule in sequent calculus is of the form:
	$$\begin{aligned}\infer[]{\Gamma \Rightarrow \Delta}{\Gamma_1\Rightarrow \Delta_1&...&\Gamma_n\Rightarrow \Delta_n}.\end{aligned}$$ It means that
	if $\Gamma_1\Rightarrow \Delta_1$, ..., $\Gamma_n\Rightarrow \Delta_n$ are all true, then $\Gamma \Rightarrow \Delta$ is true.
	Each $\Gamma_i\Rightarrow \Delta_i$ in the upper part is called a \emph{premise}, while $\Gamma\Rightarrow \Delta$ in the lower part is called a \emph{conclusion}.
	%We first only consider the inference rules for healthy formulae, for those cDL formulae which are not healthy, we can transform them into healthy ones by term rewriting rules.
	\ifx We use $\begin{aligned}\infer=[]{\Gamma\Rightarrow \Delta}{\Gamma'\Rightarrow \Delta'}\end{aligned}$ represent a pair of convertible rules.
	$\begin{aligned}\infer=[]{\Gamma\Rightarrow \Delta}{\Gamma'\Rightarrow \Delta'}\end{aligned}$ means that
	both $\begin{aligned}\infer[]{\Gamma\Rightarrow \Delta}{\Gamma'\Rightarrow \Delta'}\end{aligned}$ and $\begin{aligned}\infer[]{\Gamma'\Rightarrow \Delta'}{\Gamma\Rightarrow \Delta}\end{aligned}$.
	\fi
	We use $\begin{aligned}\infer=[]{\Gamma \Rightarrow \Delta}{\Gamma' \Rightarrow \Delta'}\end{aligned}$ to represent a pair of sequent rules: 
	$\begin{aligned}\infer[]{\Gamma \Rightarrow \Delta}{\Gamma' \Rightarrow \Delta'}\end{aligned}$ and $\begin{aligned}\infer[]{\Gamma' \Rightarrow \Delta'}{\Gamma \Rightarrow \Delta}\end{aligned}$. 
	It means that $\Gamma \Rightarrow \Delta$ is true iff $\Gamma' \Rightarrow \Delta'$ is true. 
	Sometimes we write $\begin{aligned}\infer[]{\phi}{\varphi}\end{aligned}$ if for all $\Gamma$ and $\Delta$, $\begin{aligned}\infer[]{\Gamma\Rightarrow \phi,\Delta}{\Gamma\Rightarrow \varphi,\Delta}\end{aligned}$ holds. 
	It is easy to prove that $\begin{aligned}\infer[]{\phi}{\varphi}\end{aligned}$ just means $\varphi$ implies $\phi$. 
	We call $\Gamma$ and $\Delta$ the \emph{contexts} of formula $\phi$ in sequent $\Gamma\Rightarrow \phi, \Delta$ or $\Gamma,\phi\Rightarrow \Delta$.
	
	The derivation of a sequent forms a \emph{proof tree}, where each node is a sequent. 
	A \emph{derivation} can be expressed in the form: $\begin{aligned}\infer[(r)]{\zeta}{\zeta_1, ..., \zeta_n}\end{aligned}, $
	where nodes $\zeta$, $\zeta_1$,...,$\zeta_n$ are sequents, $r$ is the name of the rule. 
	We use $\begin{aligned}\infer[(r_1,...,r_m)]{\zeta}{\zeta_1, ..., \zeta_n}\end{aligned}$ to express a series of derivations of the rules 
	$r_1,...,r_m$ ($m\ge 1$). 
	It means from node $\zeta$, by applying rules $r_1,...,r_m$, we obtain nodes $\zeta_1,...,\zeta_n$. 
	
	\ifx
	A \emph{multiple derivation}  
	
	A derivation of sequent can be expressed as: 
	$$\begin{aligned}\infer[(r_1,r_2,...,r_n)]{\Gamma \Rightarrow \Delta}{\Gamma_1\Rightarrow \Delta_1&...&\Gamma_n\Rightarrow \Delta_n}.\end{aligned}, $$
	$r_1,...,r_n$ ($n\ge 1$) are 
	\fi
	
	\ifx
	We use
	$\begin{aligned}\infer[]{\Gamma \Rightarrow \phi \Rightarrow \Delta}{\Gamma' \Rightarrow \varphi \Rightarrow \Delta'}\end{aligned}$ to represent
	a pair of sequent rules:
	$\begin{aligned}\infer[]{\Gamma, \phi\Rightarrow \Delta}{\Gamma', \varphi\Rightarrow\Delta'}\end{aligned}$ and $\begin{aligned}\infer[]{\Gamma\Rightarrow \phi,\Delta}{\Gamma'\Rightarrow \varphi, \Delta'}\end{aligned}$,
	i.e., $\phi, \varphi$ can be on both sides of the sequent.
	\ifx
	both $\begin{aligned}\infer[]{\Gamma, \phi\Rightarrow \Delta}{\Gamma, \varphi\Rightarrow\Delta}\end{aligned}$ and $\begin{aligned}\infer[]{\Gamma\Rightarrow \phi,\Delta}{\Gamma\Rightarrow \varphi, \Delta}\end{aligned}$ are rules.
	\fi
	Sometimes we write $\begin{aligned}\infer[]{\phi}{\varphi}\end{aligned}$ to represent $\begin{aligned}\infer[]{\Gamma \Rightarrow \phi \Rightarrow \Delta}{\Gamma' \Rightarrow \varphi \Rightarrow \Delta'}\end{aligned}$ if $\Gamma' = \Gamma$ and $\Delta' = \Delta$.
	We call $\Gamma, \Delta$ the `context' of formula $\phi$ in sequent $\Gamma\Rightarrow \phi, \Delta$ or $\Gamma,\phi\Rightarrow \Delta$.
	\fi
	
    \subsection{Proof Rules for Sequential SEPs}
    \label{subsection:Proof Rules for Sequential SEPs}
    The proof rules for sequential SEPs consist of: (1) the special rules for combinational events and formulae of the form $[p]\Rel$; (2) the rules inherited from FODL for formulae of the form $[p]\phi$, and other FOL rules.

    \subsubsection{Special Rules for CDL}
    Table~\ref{table:Rules for path formulae} gives the special rules in CDL, where
    rules \rul{\pi[]}, \rul{\phi[]}, \rul{\pi\la\ra}, \rul{\phi\la\ra}, \rul{P?[]}, \rul{\pi\mu[]} and \rul{\mu[]} are for combinational events,
    other rules are for formulae of the form $[p]\Rel$.
    The rules for formulae of the form $\la p\ra \sim\Rel$ can be derived from the corresponding rules in Table~\ref{table:Rules for path formulae}. 
    They are given in Table~\ref{table:Rules for path formulae 2} in Appendix~\ref{subsection: The Proof of Theorem completeness}.
    

    In rule \rul{\pi[]}, we set $\alpha=(c|x:=e)$ as an example of combinational events.
    The ellipses `\ellip' mean that we omit the discussion about other signals and assignments in $\alpha$.
    Intuitively, rule \rul{\pi[]} says that under some contexts $\Gamma$ and $\Delta$, formula $[\alpha]\Rel$ holds iff
    the premise holds, where all dynamic variables ($c^n$, $c^s$,  $x$, $d^s_i$, $1\le i\le n$) are updated with new values according to $\alpha$,
    and their old values are stored in a set of new variables $V'$.
    %for any state $s$, the conclusion holds at state $s$, iff
    %there exists a state $s'$ with $ss'\in val((c|x:=e))$ s.t. the premise holds at $s'$.
    The vector equivalence $(x_1,...,x_n)=(e_1,...,e_n)$ is a shorthand for the equivalences $x_1=e_1,...,x_n=e_n$.
    $d_1,...,d_n$ are all clocks not appearing in $\alpha$.
    $\mcl{C}(\alpha)$ and $\mcl{V}(\alpha)$ represent the set of all clocks and the set of all dynamic variables in $\alpha$ respectively.
    %(resp. $\mcl{C}(p)$) to represent all clocks appeared in $\phi$ (resp. $p$),
    %and use $\mcl{V}(\phi)$ (resp. $\mcl{V}(p)$) to represent all dynamic variables appeared in $\phi$ (resp. $p$).
    $V'$ is the set of new variables corresponding to $V$ : for each variable $x\in V$, there is a new variable $x'$ (with respect to $\Gamma, [\alpha]\Rel, \Delta$) corresponding to it.
    %In $V'$, $\prime$ maps each variable $v\in V$ to a new variable $v'$.
    The function $\hbar$ (Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}) maps each clock relation to an AFOL formula which should hold at state $s'$.
    \ifx
    It is defined as follows: for any $c_1, c_2$,
    \begin{enumerate}[label=(\arabic*)]
    \item $\hbar(c_1\subseteq c_2)\dddef c^s_1=1\to c^s_2=1$.
    \item $\hbar(c_1\# c_2)\dddef c^s_1=0\vee c^s_2=0$.
    \item $\hbar(c_1\prec c_2)\dddef c^n_1=c^n_2\to c^s_2 = 0$.
    \item $\hbar(c_1\preceq c_2)\dddef c^n_1\ge c^n_2$.
    \item $\hbar(\curlywedge(Rel_1,...,Rel_n)\dddef \bigwedge_{1\le i\le n} \hbar(Rel_i)$.
    \end{enumerate}
    \fi

    Rules \rul{\pi\la\ra}, \rul{\phi[]} and \rul{\phi\la\ra} are similar to rule \rul{\pi[]}. We omit their explanations here.


    \begin{example}
    \label{example:rules for synchronous event}
    Given the program $(\sig^c|x:=x+1)$ of Example~\ref{example:semantics of sequential SEP}, consider a CCSL specification $[(\sig^c|x:=x+1)]c\preceq d$ under the contexts $\Gamma = \{c^n = 0, c^s=0, {d}^n = 0, {d}^s=0, x = 2, y = 0\}$ and $\Delta = \emptyset$,
    by applying rule \rul{\pi[]}, we have the derivation
    $$
    \infer[^{(\pi[])}]
    {
        c^n = 0, c^s=0, {d}^n = 0, {d}^s=0, x = 2, y = 0\Rightarrow [(\sig^c|x:=x+1)]c\preceq d
    }
    {
    \left\{\begin{gathered}(c^n)' = 0, (c^s)'=0,\\ {d}^n = 0, (d^s)'=0, \\ x'=2, y=0\end{gathered}\right\},
    \ \begin{gathered}c^n = (c^n)' + 1, c^s = 1, x = x'+1, \\d^s = 0\end{gathered}\Rightarrow c^n\ge d^n
    }
    $$
    where $(c^n)'$, $(c^s)'$, $(d^s)'$, $x'$ are new variables corresponding to $c^n$, $c^s$, $d^s$, $x$ respectively.
    The formulae in $\Gamma$ that depend on the old value of each variable is given in braces `$\{\}$' in the premise.
    $y$ is a static variable. By rule \rul{\pi[]}, the formula $[(\sig^c|x:=x+1)]c\preceq d$ is transformed into a set of QF-AFOL formulae in the premise.

    \end{example}

    Rule \rul{P?[]} says that under any contexts, the formula $[P?\alpha]A$ is true iff if $P$ is true, then $[\alpha]A$ is true.
    When $P$ is false, the program $P?\alpha$ reaches a deadlock, so $[P?\alpha]A$ always holds.
    Rule \rul{\pi\mu[]} says that when a program is a skip program, $[\mu]\Rel$ always holds. This is because the skip program $\mu$ neither does anything nor consumes time.
    From another perspective, $tr\vDash_{ccsl}\Rel$ always holds for a trace $tr$ with length $1$.
    Rule \rul{\mu[]} is obviously sound because the state does not change after the execution of $\mu$.

    Rules \rul{\pi[;]}, \rul{\pi[\cup]}, \rul{\pi[\lup]u} and \rul{\pi[\lup]i} for the formula $[p]\Rel$ are modular rules and they are inspired by the rules for the temporal formula $\Box \phi$ proposed 	in \cite{conf/lfcs/Platzer07}.
    %inherited from the rules for temporal formulae `$\Box \phi$' in \cite{conf/lfcs/Platzer07}.
    Rule \rul{\pi[;]} means that every trace of $p;q$ satisfies $\Rel$ iff every trace of $p$ satisfies $\Rel$, and after $p$ every trace of $q$ satisfies $\Rel$.
    Rule \rul{\pi[\cup]} says that every trace of $p\cup q$ satisfies $\Rel$ iff every trace of $p$ and $q$ satisfies $\Rel$.
    Rule \rul{\pi[\lup]u} unwinds the operator $\lup$. It means that to prove the traces of $p$ satisfy $\Rel$ we only need to show all traces with length $\ge 2$ (i.e., the traces of $p;p^\lup$) satisfy $\Rel$.
    %trace (whose length $\ge 2$) of $p^\lup$ are the trace of $p;p^\lup$.
    Rule \rul{\pi[\lup]i} states that $\Rel$ holds along all traces of $p^\lup$, iff after all times of repetitions of $p$ (i.e., again, $p^\lup$), $\Rel$ holds
    along all traces of $p$.
    Fig.~\ref{figure:Graphical illustrations of rules for CDL} gives a graphical illustration of these 4 rules,
    where red traces satisfy $\Rel$, the states are tagged with the formulae that they satisfy.	

    %The extension of the loop operator $*$ to the infinite case does not affect the rightness of the counterparts of rule \rul{\pi[*]u}, \rul{\pi[*]i}

    \begin{figure}[htbp]
        \centering
                 \noindent\makebox[\textwidth]{%
        \scalebox{0.75}{
        \begin{tabular}{|c | c | c | c|}
        \hline
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4] (s1) {};
     \node[draw=none, yshift=0.4cm,xshift=-0.25cm]{$[p;q]\Rel$};
      \node[state4, right of=s1,fill=red] (s2) {};
      \node[draw=none, right of=s1, xshift=0.3cm, yshift=-0.35cm]{$[q]\Rel$};
      \node[state4, right of=s2,fill=red] (s3) {};
      %\node[yshift=1cm] (s4) {};
     % \node[right of=s4, xshift=1.7cm] (s5) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2, red] node [above,black] {$p$} (s2)
     (s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$\Rel$} (s1)
     (s2) edge [edge2, red] node [above,black] {$q$} (s3)
     %(s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s2)
     (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [above,black] {$p;q$} (s3)
     ;
    % \draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
     %;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
     &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4, label=south:\mbox{$[p\cup q]\Rel$}] (s1) {};
      \node[state4, right of=s1,yshift=-0.5cm,fill=red] (s2) {};
      \node[state4, right of=s1,yshift=0.5cm,fill=red] (s3) {};
      %\node[yshift=-0.75cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2, red] node [below,black] {$p$} (s2)
     %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)

     (s1) edge [edge2, red] node [below, black] {$q$} (s3)
     (s1) edge [snake=brace, raise snake=0.2cm, -] node [above=0.25cm] {$\Rel$} (s3)

     (s3) edge [snake=brace, raise snake=-0.2cm, -] node [right=-0.2cm] {$p\cup q$} (s2)
     %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
     %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
     ;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
     &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4] (s1) {};
     \node[draw=none, yshift=0.4cm,xshift=-0.25cm]{$[p^\lup]\Rel$};
      \node[state4, right of=s1,xshift=-0.5cm,fill=red] (s2) {};
      \node[draw=none, right of=s1, xshift=-0.5cm, yshift=0.35cm]{$[p^\lup]\Rel$};
      \node[state4, right of=s2,xshift=0.5cm,fill=red] (s3) {};
      %\node[yshift=1cm] (s4) {};
     % \node[right of=s4, xshift=1.7cm] (s5) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2, red] node [below,black] {$p$} (s2)
     %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
     (s2) edge [edge2, red] node [above,black] {$p^\lup$} (s3)
     (s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$\Rel$} (s2)
     (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [above,black] {$p^\lup$} (s3)
     ;
     %\draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
     %;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
     &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4] (s1) {};
     \node[ draw=none, yshift=0.4cm,xshift=-0.25cm]{$[p^\lup]\Rel$};
      \node[state4, right of=s1,xshift=0.5cm,fill=red] (s2) {};
      \node[draw=none, right of=s1, xshift=0.3cm+0.5cm, yshift=-0.35cm]{$[p]\Rel$};
      \node[state4, right of=s2,xshift=-0.5cm,fill=red] (s3) {};
      %\node[yshift=1cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2, red] node [above,black] {$p^\lup$} (s2)
     (s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$\Rel$} (s1)
     (s2) edge [edge2, red] node [above,black] {$p$} (s3)
     %(s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s2)
     (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [above,black] {$p^\lup$} (s3)
     ;
     %\draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
     %;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
     \\
     \rul{\pi [;]} & \rul{\pi[\cup]} & \rul{\pi[\lup]u} & \rul{\pi[\lup]i}\\
     \hline
     \end{tabular}
    }%end of scalebox
            }%end makebox
            \captionsetup{font=footnotesize}
        \caption{Graphical illustrations of rules \rul{\pi[;]}, \rul{\pi[\cup]}, \rul{\pi[\lup]u} and \rul{\pi[\lup]i}}
        \label{figure:Graphical illustrations of rules for CDL}
    \end{figure}

    \ifx
    In Figure $(\pi[\cup])$, because any trace $tr$ of $p\cup q$ is either a trace of $p$ or a trace of $q$, so $tr$ as a trace of $p\cup q$ satisfy $\Rel$ iff $tr$ as a trace of either $p$ or $q$ satisfy $\Rel$.
    Figure $(\pi[;])$ shows that any trace $tr$ of $p;q$ satisfies $\Rel$, iff there exists a trace $tr_1$ of $p$ satisfies $\Rel$, and a trace $tr_2$ of $q$ with $tr_{2,b} = tr_{1,e}$ that satisfies $\Rel$,
    and also $tr = tr_1\circ tr_2$. Similar analysis can be given for Figure $(\pi[\lup]u)$, $(\pi[\lup]i)$.
    \fi


    \subsubsection{Rules from FODL}
    Table~\ref{table:Rules for non-path formulae} gives the rules for formulae of the form $[p]\phi$. 
    They are directly inherited from FODL~\cite{journals/sigact/HarelKT01}.
    The only slight difference is that the loop program $p^\lup$ in SEP allows $p$ to execute for infinitely many times, which is different from the program $p^*$ in FODL.
    However, the rules for $p^\lup$ share the same form as the rules for $p^*$ in FODL because 
    we only consider the partial correctness of the program $p^\lup$. 
    \ifx
    this does not affect the soundness of these rules because for $[p]\phi$ we only consider the partial correctness. 
    \fi
    In other words, it is enough to only consider finite traces of $p^\lup$. 
    
    Other rules for formulae of the form $\la p\ra \phi$ can be derived from the corresponding rules in Table~\ref{table:Rules for non-path formulae}. 
    They are given in Table~\ref{table:Rules for path formulae 2} in Appendix~\ref{subsection: The Proof of Theorem completeness}. 

    As shown in Table~\ref{table:Rules for non-path formulae},
    rule \rul{[;]} describes that $\phi$ holds after $p;q$ iff $[q]\phi$ holds after $p$.
    Rule \rul{[\cup]} says $\phi$ holds after $p\cup q$ iff $\phi$ holds after $p$, and also holds after $q$.
    %\rul{[\cup]} is just the same as \rul{\pi[\cup]}.
    Rule \rul{[\lup]u} means that $\phi$ holds after all times of repetitions of $p$, iff
    $\phi$ holds at the current state, and $\phi$ holds after $p;p^\lup$.
    Fig.~\ref{figure:Graphical illustrations of rules from FODL 1} gives a graphical illustration of rules \rul{[;]}, \rul{[\cup]} and \rul{[\lup]u}, where
    each red state satisfies the formula $\phi$.
    \ifx
    In Figure $([;])$, we see that any trace $tr$ of $p;q$ whose last state $tr_e$ satisfies $\phi$, iff
    there exists a trace $tr_1, tr_2$ with $tr = tr_1\circ tr_2$, s.t. the last state of $tr_2$ satisfies $\phi$.
    Similar analysis can be given for Figure $([\cup])$, $([\lup]u)$.
    \fi

    \begin{figure}[htbp]
        \centering
                 \noindent\makebox[\textwidth]{%
        \scalebox{0.75}{
        \begin{tabular}{|c | c | c| c|}
        \hline
        \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
         \node[state4] (s1) {};
         \node[draw=none, yshift=0.4cm,xshift=-0.25cm]{$[p;q]\phi$};
          \node[state4, right of=s1, xshift=-0.5cm] (s2) {};
          \node[draw=none, right of=s1, xshift=0.3cm, yshift=-0.35cm]{$[q]\phi$};
          \node[state4, right of=s2,xshift=0.5cm, fill=red,label=south:$\phi$] (s3) {};
          %\node[yshift=1cm] (s4) {};
         % \node[right of=s4, xshift=1.7cm] (s5) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (s1) edge [edge2] node [above,black] {$p$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
         (s2) edge [edge2] node [above,black] {$q$} (s3)
         %(s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s2)
         (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to] node [above,black] {$p;q$} (s3)
         ;
        % \draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
         %;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        &
        \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
         \node[state4, label=west:\mbox{$[p\cup q]\phi$}] (s1) {};
          \node[state4, right of=s1,yshift=-0.5cm, fill=red, label=east:$\phi$] (s2) {};
          \node[state4, right of=s1,yshift=0.5cm, fill=red, label=east:$\phi$] (s3) {};
          %\node[yshift=-0.75cm] (s4) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (s1) edge [edge2] node [below,black] {$p$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)

         (s1) edge [edge2] node [below, black] {$q$} (s3)
         %(s1) edge [snake=brace, raise snake=0.2cm, -] node [above=0.25cm] {$Rel^0$} (s3)

         (s3) edge [snake=brace, raise snake=-0.2cm, -] node [right=-0.2cm] {$p\cup q$} (s2)
         %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
         %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
         ;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        &
        \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
         \node[state4, label=south:$\phi$, fill=red] (s1) {};
         \node[state4, draw=none, yshift=0.4cm,xshift=-0.25cm]{$[p^\lup]\phi$};
          \node[state4, right of=s1,xshift=-0.5cm,fill=red] (s2) {};
          \node[state4,draw=none, right of=s1, xshift=-0.2cm, yshift=0.35cm]{$[p;p^\lup]\phi$};
          \node[state4, right of=s2,xshift=0.5cm, label=south:$\phi$, fill=red] (s3) {};
          %\node[yshift=1cm] (s4) {};
         % \node[right of=s4, xshift=1.7cm] (s5) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (s1) edge [edge2] node [below] {$p$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
         (s2) edge [edge2] node [below,black] {$p^\lup$} (s3)
         %(s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s2)
         (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to] node [above,black] {$p^\lup$} (s3)
         ;
         %\draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
         %;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}
        &
        \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
         \node[state4, label=north:\mbox{$[p^\lup]\phi$}, label=south:$\varphi$, fill=red] (s1) {};
         %\node[state4, draw=none, yshift=0.4cm,xshift=-0.25cm]{$\phi\to [p^*]\phi$};
          \node[state4, right of=s1,xshift=-0.7cm, label=south:$\varphi\to \phi$, shape=circle split, circle split part fill={blue, green}] (s2) {};
          \node[state4, xshift=2.4cm, fill=blue,label=south:$\varphi\to \phi$] (s6) {};
          \node[state4,draw=none, right of=s1, xshift=-0.3cm, yshift=0.35cm]{$\phi\to [p]\phi$};
          \node[state4, right of=s6,xshift=-0.7cm, label=south:$\phi$, fill=red] (s3) {};
          %\node[yshift=1cm] (s4) {};
         % \node[right of=s4, xshift=1.7cm] (s5) {};
          %\node[right of=s4, xshift=1.7cm] (s5) {};
         %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
         %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
         %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
         \path
         (s1) edge [edge2] node [below] {$p^\lup$} (s2)
         %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
         (s6) edge [edge2] node [above,black] {$p^\lup$} (s3)
         (s2) edge [edge2] node [below,black] {$p$} (s6)
         %(s3) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s2)
         (s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to] node [above,black] {$p^\lup$} (s3)
         ;
         %\draw  (s4) [snake=brace, -] -- node [above] {$Rel^0$} (s5);
         %;
         %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
         %;
        \end{tikzpicture}\\
        $([;])$ & $([\cup])$ & $([\lup]u)$ & $([\lup]i)$\\
        \hline
     \end{tabular}
    }%end of scalebox
        }%end of makebox
        \captionsetup{font=footnotesize}
        \caption{Graphical illustrations of rules $([;])$, $([\cup])$, $([\lup]u)$ and $([\lup]i)$}
        \label{figure:Graphical illustrations of rules from FODL 1}
    \end{figure}

    Rules \rul{[]gen} and \rul{\la\ra gen} strengthen the conclusions by extending the proposition $\phi\to \varphi$ into dynamic situations.
    Rule \rul{[]gen} (resp. \rul{\la\ra gen}) expresses that if $\phi\to \varphi$ holds under any contexts, then under the contexts $\Gamma$ and $\Delta$ after all (resp. some) executions of $p$, $\phi$ implies $\varphi$.
    Fig.~\ref{figure:Graphical illustrations of rules from FODL 2} gives an intuitive illustration of rule \rul{[]gen}, where
    the red states satisfy the formula $\phi\to \varphi$, and the blue state satisfies the formula $[p]\phi\to [p]\varphi$. %$\phi \vDash \varphi$ is a shorthand of $\infer{\varphi}{\phi}$.

    \begin{figure}[htpb]
        \centering
        \scalebox{0.8}{
        \begin{tabular}{|>{\centering}p{0.45\textwidth} >{\centering}p{0.1\textwidth} >{\centering}p{0.45\textwidth}|}
        \hline
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4,label=north:$\phi\to \varphi$, fill=red] (s1) {};
      \node[state4, right of=s1,yshift=-0.75cm,label=east:$\phi\to \varphi$, fill=red] (s2) {};
      \node[state4, right of=s1,yshift=0.75cm,label=east:$\phi\to \varphi$, fill=red] (s3) {};
      \node[state4, right of=s1,label=east:$\phi\to \varphi$, fill=red](s4) {};
      %\node[yshift=-0.75cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2] node [below,black] {} (s2)
     %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
     (s1) edge [edge2] node [below, black] {} (s3)
     (s1) edge [edge2] node [below, black] {} (s4)
     %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
     %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
     ;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
        &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4,draw=none] (s1) {$\vdash$};
     \node[state4, yshift=-0.75cm, draw=none] (s2) {};
     \node[state4, yshift=0.75cm, draw=none] (s3) {};
      %\node[yshift=-0.75cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
        &
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     \node[state4, fill=blue] (s1) {};
     \node[draw=none, yshift=0.5cm,xshift=-0.5cm]{$[p]\phi\to [p]\varphi$};
      \node[state4, right of=s1,yshift=-0.75cm,fill=red] (s2) {};
      \node[state4, right of=s1,yshift=0.75cm,fill=red] (s3) {};
      \node[state4, right of=s1,fill=red](s4) {};
      %\node[yshift=-0.75cm] (s4) {};
      %\node[right of=s4, xshift=1.7cm] (s5) {};
     %(s18.north) edge [bend left] node {$\begin{gathered}(r\paral\cup)\\ l16\end{gathered}$} (s8)
     %(s12) edge node {$\begin{gathered}(r*)\\ l11\end{gathered}$} (s19)
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     \path
     (s1) edge [edge2] node [below,black] {} (s2)
     (s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$p$} (s1)
     %(s2) edge [snake=brace, raise snake=0.2cm, -] node [below=0.2cm] {$Rel^0$} (s1)
     (s1) edge [edge2] node [below, black] {$p$} (s3)
     (s1) edge [edge2] node [below, black] {$p$} (s4)
     %(s2) edge [edge2, red] node [below,black] {$Rel^0$} node [above,black] {$q$} (s3)
     %(s1) edge [bend left=45, decoration={snake, amplitude=0.07cm}, decorate, semithick, >=to, red] node [below,black] {$Rel^0$} node [above,black] {$p;q$} (s3)
     ;
     %\draw (s1.south) [snake=snake, semithick, segment amplitude=0.07cm, -] -- (s4.mid) edge [edge2,->] node [below] {$p;q\equiv p$} (s5.west)
     %;
    \end{tikzpicture}
     \tabularnewline
     \hline
     $\cdot \Rightarrow \phi\to \varphi$ & $\vdash$ & $\Gamma \Rightarrow [p]\phi\to [p] \varphi, \Delta$\tabularnewline
      \hline
     \end{tabular}
    }%end of scalebox
        \captionsetup{font=footnotesize}
        \caption{Graphical illustrations of rule \rul{[]gen}}
        \label{figure:Graphical illustrations of rules from FODL 2}
    \end{figure}


    Rule \rul{[\lup]ind} is the mathematical induction by the number of repetitions of the program $p$:
    to prove $\phi$ holds after all repetitions (including $0$) under the given contexts $\Gamma$ and $\Delta$, we need to prove that under any contexts, if $\phi$ holds, then it also holds after $p$.
    Rule \rul{\la \lup\ra con} is from the Harel's convergence rule in \cite{journals/sigact/HarelKT01} where the integer $x$ indicates the existing number of the repetitions of $p$.
    Its meaning is similar to rule \rul{[\lup]ind} and we omit it here.
    Rules \rul{[\lup]i} and \rul{\la \lup\ra i} are for eliminating the star operator $\lup$ in practical verification.
    They can be derived by rules \rul{[\lup]ind} and \rul{\la \lup\ra con} with the generalization rules \rul{[]gen} and \rul{\la \ra gen} (see \cite{journals/sigact/HarelKT01,books/daglib/0025392}).
    $\varphi$ is a loop invariant of $p$. %and must be chosen by users in advance. [...such procedure can in fact be automatic].
    Rule \rul{[\lup]i} says that to prove $\phi$ holds after all repetitions of $p$ under the given contexts $\Gamma$ and $\Delta$, we need to prove that there exists an invariant $\varphi$ such that:
    \rmn{1} $\varphi$ holds under the contexts $\Gamma$ and $\Delta$. \rmn{2} Under any contexts, if $\varphi$ holds, then $\varphi$ holds after $p$ as well. \rmn{3} Under any contexts, $\varphi$ implies $\phi$.
    %Fig.~\ref{figure: Graphical illustrations of pphi pRel0 and some proof rules} gives a graphical illustration of rule \rul{[\cup]}, \rul{[;]}, \rul{[\lup]u}, \rul{[\lup]ind}, \rul{\la \lup\ra con}.
    Figure $([\lup]i)$ of Fig.~\ref{figure:Graphical illustrations of rules from FODL 1} gives a graphical illustration of rule \rul{[\lup]i},
    where the red states satisfy the formula $\phi$, the blue states satisfy the formula $\varphi\to \phi$, the green state satisfies the formula $\phi\to [p]\phi$.
    The explanation of rule \rul{\la \lup\ra i} is similar to rule \rul{[\lup]i},
    where we need a number $x$ to indicate the number of repetitions of $p$ before it terminates. 
    Without $x$ the premise might become too strong so that its falsehood does not imply the falsehood of the conclusion. 
    We omit its explanation here.
    
    %\begin{tiny}
    \begin{table}[p]
         \begin{center}
         \scalebox{1.0}{
         \begin{tabular}[htp]{|c c c c|}
         \hline
         %\multicolumn{2}{l}{rules for atomic programs (where $[\!\la\cdot \ra\!]$ indicates $[\cdot]$ or $\la \cdot \ra$, $e^v$ is the signal variable of $v$):}  \\
         & & & \\
         \multicolumn{4}{|c|}{$\infer=[^{(\pi[])}]
         {\begin{aligned}&\Gamma\Rightarrow \hpseq{[\alpha]\Rel}{h}, \Delta\end{aligned}}
         {\begin{gathered}\Gamma[V'/ V], c^n=(c^n)'+1, c^s=1, x=e'[V'/ V], \ellip, (d^s_1,...,d^s_n)=\underbrace{(0,...,0)}_{n}\\
         \Rightarrow \hbar(\Rel), \Delta[V'/ V]\end{gathered}}$
         }\\
         \multicolumn{4}{|c|}{$\begin{gathered}\mbox{where }\alpha = (\sig^c!e\ |\ x:=e'\ |\ellip).\ \{d_1,...,d_n\}=\mcl{C}-\mcl{C}(\alpha).\ V=\dvar(\alpha),\\
         V'\mbox{ is the set of new variables (w.r.t. }\Gamma, [\alpha]\Rel, \Delta\mbox{) corresponding to }V.\end{gathered}$}\\
         %&\\
         %&\\
         \hline
         & & & \\
         \multicolumn{4}{|c|}{$\infer=[^{(\phi[])}]
         {\begin{aligned}&\Gamma\Rightarrow \hpseq{[\alpha]\phi}{h}, \Delta\end{aligned}}
         {\begin{gathered}\Gamma[V'/V], c^n=(c^n)'+1, c^s=1, x=e'[V'/V], \ellip, (d^s_1,...,d^s_n)=\underbrace{(0,...,0)}_{n}\\
         \Rightarrow \phi, \Delta[V'/V]\end{gathered}}$
         }\\
         \multicolumn{4}{|c|}{$\begin{gathered}\mbox{where }\alpha = (\sig^c!e\ |\ x:=e'\ |\ellip).\ \{d_1,...,d_n\}=\mcl{C}-\mcl{C}(\alpha).\ V=\dvar(\alpha),\\
         V'\mbox{ is the set of new variables (w.r.t. }\Gamma, [\alpha]\Rel, \Delta\mbox{) corresponding to }V.\end{gathered}$}\\
         %&\\
         %&\\
         \hline
         & & & \\
              %\multicolumn{2}{l}{rules for atomic programs (where $[\!\la\cdot \ra\!]$ indicates $[\cdot]$ or $\la \cdot \ra$, $e^v$ is the signal variable of $v$):}  \\
         \multicolumn{4}{|c|}{$\infer=[^{(\pi\la\ra)}]
         	{\begin{aligned}&\Gamma\Rightarrow \hpseq{\la\alpha\ra\nneg\Rel}{h}\Rightarrow \Delta\end{aligned}}
         	{\begin{gathered}\Gamma[V'/ V], c^n=(c^n)'+1, c^s=1, x=e'[V'/ V], \ellip, (d^s_1,...,d^s_n)=\underbrace{(0,...,0)}_{n}\\
         		\Rightarrow \neg\hbar(\Rel)\Rightarrow \Delta[V'/ V]\end{gathered}}$
         }\\
         \multicolumn{4}{|c|}{$\begin{gathered}\mbox{where }\alpha = (\sig^c!e\ |\ x:=e'\ |\ellip).\ \{d_1,...,d_n\}=\mcl{C}-\mcl{C}(\alpha).\ V=\dvar(\alpha),\\
         	V'\mbox{ is the set of new variables (w.r.t. }\Gamma, \la\alpha\ra\Rel, \Delta\mbox{) corresponding to }V.\end{gathered}$}\\
         \hline
         & & &\\
         \multicolumn{4}{|c|}{$\infer=[^{(\phi\la\ra)}]
         	{\begin{aligned}&\Gamma\Rightarrow \hpseq{\la\alpha\ra\phi}{h}, \Delta\end{aligned}}
         	{\begin{gathered}\Gamma[V'/V], c^n=(c^n)'+1, c^s=1, x=e'[V'/V], \ellip, (d^s_1,...,d^s_n)=\underbrace{(0,...,0)}_{n}\\
         		\Rightarrow \phi, \Delta[V'/V]\end{gathered}}$
         }\\
         \multicolumn{4}{|c|}{$\begin{gathered}\mbox{where }\alpha = (\sig^c!e\ |\ x:=e'\ |\ellip).\ \{d_1,...,d_n\}=\mcl{C}-\mcl{C}(\alpha).\ V=\dvar(\alpha),\\
         	V'\mbox{ is the set of new variables (w.r.t. }\Gamma, \la\alpha\ra\Rel, \Delta\mbox{) corresponding to }V.\end{gathered}$}\\
         \hline
         & & &\\
         \multicolumn{2}{|c}{$\begin{aligned}\infer=[^{(P?[])}]
         {\hprel \sep \hpseq{[P?\alpha]A}{h}}
         {\hprel \sep \hpseq{P\to [\alpha]A}{h}}\end{aligned}
         $
         }
         &
         $\begin{aligned}\infer=[^{(\pi\mu[])}]
         {\hprel \sep \hpseq{[\mu]\Rel}{h}}
         {\hprel \sep tt}\end{aligned}
         $
         &
         $\infer=[^{(\mu[])}]
         {\hprel \sep \hpseq{[\mu]\phi}{h}}
         {\hprel \sep \phi}
         $\\
         \multicolumn{4}{|c|}{
         where $A\in \{\Rel, \phi\}$
         }\\
         \hline
         & & & \\
          $\infer=[^{(\pi[;])}]
         {\hprel \sep \hpseq{[p;q]\Rel}{h}}
         {\hprel \sep \hpseq{[p]\Rel\wedge [p][q]\Rel}{h}}$
         &
         $\infer=[^{(\pi[\cup])}]
          {\hprel \sep \hpseq{[p\cup q]\Rel}{h}}
          {\hprel \sep \hpseq{[p]\Rel\wedge [q]\Rel}{h}}$
          &
          $\infer=[^{(\pi[\lup]u)}]
          {\hprel \sep \hpseq{[p^\lup]\Rel}{h}}
          {\hprel \sep \hpseq{[p;p^\lup]\Rel}{h}}$
          &
          $\infer=[^{(\pi[\lup]i)}]
         {\hprel \sep \hpseq{[p^\lup]\Rel}{h}}
         {\hprel \sep \hpseq{[p^\lup][p]\Rel}{h}}$\\
         \hline
          \end{tabular}
              }%end of scalebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rules for combinational events and formulae $[p]\Rel$}}
          \label{table:Rules for path formulae}
    \end{table}
    %\end{tiny}

    \begin{table}[tb]
         \begin{center}
                  \noindent\makebox[\textwidth]{%
         \scalebox{1.0}{
         \begin{tabular}[htp]{|c c c c|}
         \hline
         & & &\\
         \multicolumn{2}{|c}{
         $\infer=[^{([;])}]
          {\hprel\sep \hpseq{[p;q]\phi}{h}}
          {\hprel\sep \hpseq{[p][q]\phi}{h}}$
          }
          &
          $\infer=[^{([\cup])}]
          {\hprel\sep \hpseq{[p\cup q]\phi}{h}}
          {\hprel\sep \hpseq{[p]\phi\wedge [q]\phi}{h}}$
          &
          $\infer=[^{([\lup]u)}]
          {\hprel\sep \hpseq{[p^\lup]\phi}{h}}
          {\hprel\sep \hpseq{\phi\wedge [p;p^\lup]\phi}{h}}$\\
          %& \\
          \hline
          & & &\\
          \multicolumn{2}{|c}{$\infer[^{([]gen)}]
          {\hprel\sep \Gamma\Rightarrow \hpseq{[p]\phi\to [p]\varphi}{h},\Delta }
          {\sep \cdot\Rightarrow \hpseq{\phi\to \varphi}{h}}$}
          &
          \multicolumn{2}{c|}{$\infer[^{(\la\ra gen)}]
          {\hprel\sep \Gamma\Rightarrow\hpseq{\la p\ra\phi\to \la p\ra\varphi}{h},\Delta}
          {\sep \cdot \Rightarrow \hpseq{\phi\to \varphi}{h}}$}\\
         % \multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\phi$, $\varphi$. }\\
          %& \\
          & & &\\
          \multicolumn{2}{|c}{
          $\infer[^{([\lup]ind)}]
          {\hprel\sep \Gamma\Rightarrow \hpseq{\phi\to [p^\lup]\phi}{h},\Delta}
          {\sep \cdot \Rightarrow \hpseq{\phi\to [p]\phi}{h}}$
          }
          &
          \multicolumn{2}{c|}{
          $\infer[^{(\la \lup\ra con)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\exists x\ge 0.\phi (x)\to \exists x\le 0.\la p^\lup\ra\phi(x)}{h},\Delta}
          {\sep\cdot\Rightarrow \hpseq{\forall x> 0.(\phi(x)\to \la p\ra\phi(x-1))}{h}}$
          }\\
          %\multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\phi$. }\\
          \hline
          & & &\\
          \multicolumn{4}{|c|}{
          $\infer[^{([\lup]i)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{[p^\lup]\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\varphi}{h},\Delta
          &
          \sep\cdot \Rightarrow \hpseq{\varphi\to [p]\varphi}{h}
          &
          \sep\cdot\Rightarrow \hpseq{\varphi\to \phi}{h}}$
          }
          \\
          & & &\\
          \multicolumn{4}{|c|}{
          $\infer[^{(\la \lup\ra i)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\la p^\lup\ra\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\exists {x\ge 0}.\varphi(x)}{h},\Delta
          &
          \sep\cdot\Rightarrow \hpseq{\forall x>0.(\varphi(x)\to \la p\ra \varphi(x-1))}{h}
          &
          \sep\cdot\Rightarrow \hpseq{\exists x\le 0.\varphi(x)\to \phi}{h}}$
          }\\
           %\multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\varphi$, $\vec c'',\vec z''$ are new w.r.t. $\Gamma$, $\Delta$, $\varphi$, $\phi$. }\\
         \hline
          \end{tabular}
          }%end of scalebox
            }%end of makebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rules for formulae $[p]\phi$ inherited from FODL}}
          \label{table:Rules for non-path formulae}
    \end{table}

    \ifx
    \begin{tiny}
         \begin{table}[htb]
         \begin{center}
         \scalebox{0.75}{
         \begin{tabular}[htp]{c c c c}
         \toprule
         \multicolumn{4}{c}{$\infer[^{(\phi)}]
         {\begin{aligned}&\Gamma\Rightarrow \hpseq{[c!v\ |\ x:=e\ |...]\phi}{h}\Rightarrow \Delta\end{aligned}}
         {\begin{aligned}&\Gamma[V'\sub V], c^n=(c^n)'+1, c^s=1, x=e[V'\sub V], (d^s_1,...,d^s_n)=\underbrace{(0,...,0)}_{n}, ...\Rightarrow \phi\Rightarrow \Delta[V'\sub V]\end{aligned}}$
         }\\
         \multicolumn{4}{c}{$\begin{gathered}\mbox{where }\{d_1,...,d_n\}=\mcl{C}-\mcl{C}(\alpha).\ V=\dvar(c!v\ |\ x:=e\ |...),\ V'\mbox{ is the set of new variables corresponding to }V.\end{gathered}$}\\
        \\
        $\infer[^{(\mu)}]
         {\hprel \sep \hpseq{[\mu]\phi}{h}}
         {\hprel \sep \phi}
         $
         &
         $\infer[^{([;])}]
          {\hprel\sep \hpseq{[p;q]\phi}{h}}
          {\hprel\sep \hpseq{[p][q]\phi}{h}}$
          &
          $\infer[^{([\cup])}]
          {\hprel\sep \hpseq{[p\cup q]\phi}{h}}
          {\hprel\sep \hpseq{[p]\phi\wedge [q]\phi}{h}}$
          &
          $\infer[^{([*]u)}]
          {\hprel\sep \hpseq{[p^*]\phi}{h}}
          {\hprel\sep \hpseq{\phi\wedge [p;p^*]\phi}{h}}$\\
          %& \\
          \\
          \multicolumn{2}{c}{$\infer[^{([]gen)}]
          {\hprel\sep \Gamma\Rightarrow \hpseq{[p]\phi\to [p]\varphi}{h},\Delta }
          {\sep \cdot\Rightarrow \hpseq{\phi\to \varphi}{h}}$}
          &
          \multicolumn{2}{c}{$\infer[^{(\la\ra gen)}]
          {\hprel\sep \Gamma\Rightarrow\hpseq{\la p\ra\phi\to \la p\ra\varphi}{h},\Delta}
          {\sep \cdot \Rightarrow \hpseq{\phi\to \varphi}{h}}$}\\
         % \multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\phi$, $\varphi$. }\\
          %& \\
          \\
          \multicolumn{2}{c}{
          $\infer[^{([*]ind)}]
          {\hprel\sep \Gamma\Rightarrow \hpseq{\phi\to [p^*]\phi}{h},\Delta}
          {\sep \cdot \Rightarrow \hpseq{\phi\to [p]\phi}{h}}$
          }
          &
          \multicolumn{2}{c}{
          $\infer[^{(\la *\ra con)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\exists x\ge 0.\phi (x)\to \exists x\le 0.\la p^*\ra\phi(x)}{h},\Delta}
          {\sep\cdot\Rightarrow \hpseq{\forall x> 0.(\phi(x)\to \la p\ra\phi(x-1))}{h}}$
          }\\
          %\multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\phi$. }\\
          \\
          \multicolumn{2}{c}{
          $\infer[^{([*]i)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{[p^*]\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\varphi}{h},\Delta
          &
          \sep\cdot \Rightarrow \hpseq{\varphi\to [p]\varphi}{h}
          &
          \sep\cdot\Rightarrow \hpseq{\varphi\to \phi}{h}}$
          }
          &
          \multicolumn{2}{c}{
          $\infer[^{(\la *\ra i)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\la p^*\ra\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\exists {x\ge 0}.\varphi(x)}{h},\Delta
          &
          \sep\cdot\Rightarrow \hpseq{\forall x>0.(\varphi(x)\to \la p\ra \varphi(x-1))}{h}
          &
          \sep\cdot\Rightarrow \hpseq{\exists x\le 0.\varphi(x)\to \phi}{h}}$
          }\\
           %\multicolumn{4}{c}{where $\vec c=\mcl{C}(p)$, $\vec z=\mcl{V}(p)$, $\vec c', \vec z'$ are new w.r.t. $\Gamma$, $\Delta$, $\varphi$, $\vec c'',\vec z''$ are new w.r.t. $\Gamma$, $\Delta$, $\varphi$, $\phi$. }\\
         \bottomrule
          \end{tabular}
          }%end of scalebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rules for non-path formulae}}
          \label{table:Rules for non-path formulae}
          \end{table}
    \end{tiny}
    \fi


    \subsubsection{Other FOL Rules}
    Other FOL rules are listed in Table~\ref{table: Rules for first order logic}.
    As indicated in Fig.~\ref{figure:Verification framework of CDL}, after a QF-AFOL formula is obtained we can adopt SMT-checking procedure to check its validity.
    Since the SMT-checking procedure is independent from the CDL proof system itself,
    we propose an \emph{oracle rule} \rul{o} in our proof system to indicate the termination of the proof.
    We assume that the validity of this QF-AFOL formula can be checked in a ``black box'' through an SMT-checking procedure.
    Other rules comes from the traditional FOL and we omit their explanations.

    \begin{table}[htb!]
         \begin{center}
                                    \noindent\makebox[\textwidth]{%
         \scalebox{1.0}{
         \begin{tabular}[htp]{|c c c|}
         \hline
         & &\\
         \multicolumn{3}{|c|}{
         $\infer[^{(o)}]
         {\Gamma \Rightarrow \Delta}
         {\mcdl \bigwedge_{\phi\in \Gamma} \phi \to \bigvee_{\varphi\in \Delta} \varphi}$}\\
         \multicolumn{3}{|c|}{
         $\Gamma, \Delta$ are multi-sets of \QQFAFOL \ formulae.
         }\\
         \hline
         & &\\
         \multicolumn{3}{|c|}{
         $\infer[^{(ax)}]
         {\Gamma,\phi\Rightarrow \phi,\Delta}
         {}$
         \ \ \ \ \ \ \ \ \ \
         $\infer[^{(cut)}]
         {\Gamma\Rightarrow\Delta}
         {\Gamma\Rightarrow \phi,\Delta\ \ \ \Gamma, \phi \Rightarrow \Delta}$}\\
         \hline
         & &\\
         $\infer[^{(\neg r)}]
         {\Gamma\Rightarrow \phi,\Delta}
         {\Gamma,\neg\phi\Rightarrow\Delta}$
         &
         $\infer[^{(\neg l)}]
         {\Gamma,\phi\Rightarrow\Delta}
         {\Gamma\Rightarrow\neg \phi,\Delta}$
         &
         $\infer[^{(\wedge r)}]
         {\Gamma\Rightarrow \phi\wedge \varphi,\Delta}
         {\Gamma\Rightarrow \phi,\Delta\ \ \ \Gamma\Rightarrow \varphi,\Delta}$\\
         & &\\
         $\infer[^{(\wedge l)}]
         {\Gamma, \phi\wedge \varphi\Rightarrow\Delta }
         {\Gamma, \phi,\varphi\Rightarrow\Delta }$
         &
         $\infer[^{(\forall r)}]
          {\Gamma\Rightarrow \forall x\phi,\Delta}
          {\Gamma\Rightarrow \phi[x'/x],\Delta}$
          &
          $\infer[^{(\forall l)}]
          {\Gamma, \forall x\phi\Rightarrow\Delta}
          {\Gamma, \forall x\phi, \phi[E/x]\Rightarrow\Delta}$\\
          & &\\
          $\infer[^{(\vee r)}]
         {\Gamma\Rightarrow \phi\vee \varphi, \Delta}
         {\Gamma\Rightarrow \phi, \varphi, \Delta}$
         &
         $\infer[^{(\vee l)}]
         {\Gamma ,\phi\vee \varphi\Rightarrow \Delta}
         {\Gamma,\phi\Rightarrow\Delta\ \ \ \Gamma, \varphi\Rightarrow \Delta}$
         &
         $\infer[^{(\to r)}]
         {\Gamma\Rightarrow \phi\to \varphi, \Delta}
         {\Gamma,\phi\Rightarrow \varphi, \Delta}$\\
         & &\\
         $\infer[^{(\to l)}]
         {\Gamma ,\phi\to \varphi\Rightarrow \Delta}
         {\Gamma\Rightarrow\phi,\Delta \ \ \ \Gamma, \varphi\Rightarrow \Delta}$
         &
         $\infer[^{(\exists r)}]
          {\Gamma\Rightarrow \exists x\phi,\Delta}
          {\Gamma\Rightarrow \phi[E/x],\Delta}$
          &
          $\infer[^{(\exists l)}]
          {\Gamma, \exists x\phi\Rightarrow\Delta}
          {\Gamma, \exists x\phi, \phi[x'/x]\Rightarrow \Delta}$\\
          \multicolumn{3}{|c|}{where $x'$ is new w.r.t. $\Gamma, \phi$ and $\Delta$, $\phi[E/x]$ is admissible.}\\
         \hline
          \end{tabular}
          }%end of scalebox
           }%end makebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{FOL Rules}}
          \label{table: Rules for first order logic}
    \end{table}

    \ifx
    \begin{tiny}
         \begin{table}[htb]
         \begin{center}
         \scalebox{0.725}{
         \begin{tabular}[htp]{c c c c}
         \toprule
         \multicolumn{4}{c}{
         $\infer[^{(o)}]
         {\hprel\sep \Gamma \Rightarrow \Delta}
         {\mscdl \bigwedge_{\phi\in \Gamma} \phi \to \bigvee_{\varphi\in \Delta} \varphi}$
         }\\
         \multicolumn{4}{c}{
         $\Gamma, \Delta$ are multi-sets of QF-AFOL formulae.
         }\\
         \\
         \multicolumn{2}{c}{
         $\infer[^{(ax)}]
         {\hprel\sep\Gamma,\hpseq{\phi}{h}\Rightarrow \hpseq{\phi}{h},\Delta}
         {}$}
         &
         \multicolumn{2}{c}{
         $\infer[^{(cut)}]
         {\hprel\sep\Gamma\Rightarrow\Delta}
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi}{h},\Delta & \hprel\sep\Gamma, \hpseq{\phi}{h} \Rightarrow \Delta}$}\\
         \\
         $\infer[^{(\neg r)}]
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi}{h},\Delta}
         {\hprel\sep\Gamma,\hpseq{\neg\phi}{h}\Rightarrow\Delta}$
         &
         $\infer[^{(\neg l)}]
         {\hprel\sep\Gamma,\hpseq{\phi}{h}\Rightarrow\Delta}
         {\hprel\sep\Gamma\Rightarrow\hpseq{\neg \phi}{h},\Delta}$
         &
         $\infer[^{(\wedge r)}]
         {\hprel\sep \Gamma\Rightarrow \hpseq{\phi\wedge \varphi}{h},\Delta}
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi}{h},\Delta & \hprel\sep\Gamma\Rightarrow \hpseq{\varphi}{h},\Delta}$
         &
         $\infer[^{(\wedge l)}]
         {\hprel\sep\Gamma, \hpseq{\phi\wedge \varphi}{h}\Rightarrow\Delta }
         {\hprel\sep\Gamma, \hpseq{\phi}{h},\hpseq{\varphi}{h}\Rightarrow\Delta }$\\
         \\
         $\infer[^{(\forall r)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\forall x.\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\phi[x'/x]}{h},\Delta}$
          &
          $\infer[^{(\forall l)}]
          {\hprel\sep\Gamma, \hpseq{\forall x.\phi}{h}\Rightarrow\Delta}
          {\begin{aligned}\hprel\sep &\Gamma, \hpseq{\forall x.\phi}{h}, \hpseq{\phi[tn/x]}{h}\Rightarrow\Delta\end{aligned}}$
          &
          $\infer[^{(\vee r)}]
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi\vee \varphi}{h}, \Delta}
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi}{h}, \hpseq{\varphi}{h}, \Delta}$
         &
         $\infer[^{(\vee l)}]
         {\hprel\sep\Gamma ,\hpseq{\phi\vee \varphi}{h}\Rightarrow \Delta}
         {\hprel\sep\Gamma,\hpseq{\phi}{h}\Rightarrow\Delta & \hprel\sep\Gamma, \hpseq{\varphi}{h}\Rightarrow \Delta}$\\
         %\multicolumn{4}{c}{ where $x'$ is new w.r.t. $\Gamma, \phi, \Delta$, $\phi[tn/x]$ is admissible.} \\
         \\
         $\infer[^{(\to r)}]
         {\hprel\sep\Gamma\Rightarrow \hpseq{\phi\to \varphi}{h}, \Delta}
         {\hprel\sep\Gamma,\hpseq{\phi}{h}\Rightarrow \hpseq{\varphi}{h}, \Delta}$
         &
         $\infer[^{(\to l)}]
         {\hprel\sep\Gamma ,\hpseq{\phi\to \varphi}{h}\Rightarrow \Delta}
         {\hprel\sep\Gamma\Rightarrow\hpseq{\phi}{h},\Delta & \hprel\sep\Gamma, \hpseq{\varphi}{h}\Rightarrow \Delta}$
         &
         $\infer[^{(\exists r)}]
          {\hprel\sep\Gamma\Rightarrow \hpseq{\exists x.\phi}{h},\Delta}
          {\hprel\sep\Gamma\Rightarrow \hpseq{\phi[tn/x]}{h},\Delta}$
          &
          $\infer[^{(\exists l)}]
          {\hprel\sep\Gamma, \hpseq{\exists x.\phi}{h}\Rightarrow\Delta}
          {\begin{aligned}\hprel\sep&\Gamma, \hpseq{\exists x.\phi}{h}, \hpseq{\phi[x'/x]}{h}\Rightarrow \Delta\end{aligned}}$\\
          \\
          \multicolumn{4}{c}{where $x'$ is a new variable, $\phi[tn/x]$ is admissible.}\\
         \bottomrule
          \end{tabular}
              }%end of scalebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rules of first order logic}}
          \label{table:Rules for first order logic}
          \end{table}
    \end{tiny}
    \fi


    \subsection{Rewrite Rules for Parallel SEPs}
    \label{subsection:Rewriting Rules for Parallel SEPs}
    For parallel SEPs, %since there might be interactions between programs executing concurrently,
    generally if no additional information about the interaction between parallel SEPs is provided, the only way for proving the specifications of parallel SEPs is to first reduce a parallel SEP into a sequential one,
    then apply the rules for sequential SEPs given in \Sect~\ref{subsection:Proof Rules for Sequential SEPs}.
    We propose rewrite rules for parallel SEPs, which associate algorithms to provide an automatic mechanism for program reductions in the proof procedure.
    %This allows choosing an effectively proof strategy in the actual proof works for parallel SEPs.


    \begin{table}[htb!]
         \begin{center}
         \scalebox{1.0}{
         \begin{tabular}[htp]{|l l l l|}
         \hline
         & & &\\
         %$(rRed)$ & $\begin{aligned}\infer[^{}]{\phi\{\pcd{N}{I}\}}{\phi\{O\}}\end{aligned}\IF \pcd{N}{I}\ded^* O$
         %&
         $(r)$ & \multicolumn{3}{c|}{$\begin{aligned}\infer=[]
          {\phi\{p\}}
          {\phi\{q\}}\end{aligned}\mbox{ if } p\red q$}\\
          & & &\\
         $(r\paral \alpha)$ & \multicolumn{3}{c|}{$\begin{aligned}\paral(p_1,...,p_n)\red &\ \communicate(\paral(p_1,...,p_n))\end{aligned}$}\\
         &\multicolumn{3}{c|}{$\mbox{where all }p_i(1\le i\le n)\mbox{ are not in the form }q^\lup\mbox{ or }q^\lup;r$}\\
          & & &\\
          $(r\paral \lup 1)$ & \multicolumn{3}{c|}{$\begin{aligned}&\paral(p_1,...,q^\lup,...,p_n)\red \Exp(\paral(p_1,...,\star(q^\lup),...,p_n))\end{aligned}$}\\
          & & &\\
          $(r\paral \lup 2)$ & \multicolumn{3}{c|}{$\begin{aligned}&\paral(p_1,...,q^\lup;r,...,p_n)\red \Exp(\paral(p_1,...,\star(q^\lup);r,...,p_n))\end{aligned}$}\\
         %${(r\paral)}$ & \multicolumn{3}{l}{$\paral (...,p_i,...,p_j,...)\red \paral (...,p_j,...,p_i,...)$}\\
         \hline
          \end{tabular}
          }%end of scalebox
          \end{center}
          %\captionsetup{font=footnotesize}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rewrite rules for parallel SEPs}}
          \label{table:Rewriting rules for parallel SEP}
    \end{table}

    \subsubsection{Rewrite Rules}
    The rewrite rules for parallel SEPs are given in Table~\ref{table:Rewriting rules for parallel SEP}.
    The rewrite relation $p\red q$ is read as ``$p$ can be reduced to $q$''.
    The soundness of the rewrite relation means that if $p\red q$, then $p\equiv q$.
    %$\IF$' represents high-level implication relation between rule conditions and logic rules.
    %$R\IF C$ means that rule $R$ can be derived \emph{if} condition $C$ holds, where $C$ is often described as a predicate.

    \ifx
    \begin{definition}[Rewriting Relation$\red$]
    The rewriting relation between SEPs is defined as:
    $$p\red q \IF C, $$
    meaning that $p$ can be reduced to $q$, provided that condition $C$ is true.
    %其中$R\IF C$表示规则$R$可被推导, 如果条件$C$为真. 条件$C$常常用一个命题来表示.
    \end{definition}
    \fi

    Rule \rul{r} shows how rewrite rules can be applied in the derivation of CDL formulae. It means that if $p$ can be reduced to $q$, then it does not change the meaning of the formula $\phi$ by replacing $p$ with $q$ in $\phi$.
    A \emph{program hole} $\phi\{\place\}$ is defined as follows:
    $$\begin{aligned}
    \phi\{\place\}\ddef &[p\{\place\}]\Rel\ |\ [p\{\place\}]\varphi\ |\ \neg \phi\{\place\}\ |\ \phi\{\place\}\wedge \varphi\ |\ \varphi\wedge \phi\{\place\}\ |\ \forall x.\phi\{\place\},
    \end{aligned}$$
     where $\varphi$ is a CDL formula, $p\{\place\}$ is defined as:
    $$\begin{aligned}
    p\{\place\}\ddef \ &\place\ |\ \varrho\& P?p\{\place\}\ |\ q;p\{\place\}\ |\ p\{\place\};q\ |\ q\cup p\{\place\}\ |\ p\{\place\}\cup q\ |\ \\
    &(p\{\place\})^\lup\ |\ \paral (q_1,...,p\{\place\},...,q_n).
    \end{aligned}$$
    `$\place$' represents a place that can be filled by a program.

    Rule \rul{r\paral \alpha} transforms a parallel SEP into a sequential one. %an SEP in sequential form, i.e., a program not in the form of $\paral(p_1,...,p_n)$. %which is sequential at current time.
    It requires that in the parallel SEP, all programs $p_1,...,p_n$ must not be in the forms $q^\lup$ and $q^\lup;r$.
    Procedure $\communicate$ is for computing the current executable event (Def.~\ref{defnition:Executable Event}) of the parallel SEP.

    \begin{example}
    Given a parallel SEP $p = \paral((\sig_r;q_1), (\hat{\sig_r}?\alpha_1;q_2))$, we consider a sequent $\varphi \Rightarrow [p]c_r\prec c_o$.
    Since $\communicate(p) = (\sig_r|\alpha_1);\paral(q_1,q_2)$, so by applying rule \rul{r\paral \alpha} we can make the derivation
    $$
    \infer[^{(r \paral \alpha, r)}]
    {\varphi\Rightarrow [p]c_r\prec c_o}
    {\varphi\Rightarrow [(\sig_r|\alpha_1);\paral(q_1,q_2)]c_r\prec c_o}
    $$
    where we reduce $p$ into a sequential program $(\sig_r|\alpha_1);\paral(q_1,q_2)$.
    \end{example}

    During the proof of a parallel SEP specification, when there exists loop programs of the forms $q^\lup$ and $q^\lup;r$ appearing in the parallel SEP,
    the proof procedure might not terminate if we do not eliminate the loop operator $\lup$ of programs $q^\lup$ and $q^\lup;r$ in the reduction procedure (as shown in Example~\ref{example:infinite proof sequence} below).
    Therefore, we propose rules \rul{r\paral \lup 1} and \rul{r\paral \lup 2} to handle this problem.
    Rules \rul{r\paral \lup 1} and \rul{r\paral \lup 2} deal with the situations where some program among the programs $p_1,...,p_n$ is of the form $q^\lup$ or $q^\lup;r$. %of $q^\lup$ and $q^\lup;r$ respectively.
    In these two rules, an
    expansion procedure ($\Exp$) is built to eliminate the loop operator $\lup$ (tagged by a symbol $\star$).
    It returns an equivalent sequential SEP which does not contain the loop programs $q^\lup$ and $q^\lup;r$.

    \begin{example}
    \label{example:infinite proof sequence}
    Consider a sequent $\Gamma \Rightarrow [\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)]c_1\prec c_2$, since
    $$\communicate(\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)) = \sig^{c_1};(\sig^{c_1})^\lup\cup \sig^{c_2};(\sig^{c_2})^\lup\cup (\sig^{c_1}|\sig^{c_2});\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup), $$
    by applying rule \rul{r\paral \alpha}, we have the derivation as follows:
    \begin{center}
    \scalebox{0.7}{
    $$\infer[^{(r\paral \alpha, r)}]
    {\circled{1}\ \Gamma \Rightarrow [\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)]c_1\prec c_2}
    {
        \infer[^{([\cup])}]
        {\Gamma \Rightarrow [\sig^{c_1};(\sig^{c_1})^\lup\cup \sig^{c_2};(\sig^{c_2})^\lup\cup (\sig^{c_1}|\sig^{c_2});\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)]c_1\prec c_2}
        {
            \Gamma\Rightarrow [\sig^{c_1};(\sig^{c_1})^\lup]c_1\prec c_2
            &
            \Gamma\Rightarrow [\sig^{c_2};(\sig^{c_2})^\lup]c_1\prec c_2
            &
            \infer[^{(\pi[;], \wedge r)}]
            {\Gamma\Rightarrow [(\sig^{c_1}|\sig^{c_2});\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)]c_1\prec c_2}
            {
                \Gamma\Rightarrow [(\sig^{c_1}|\sig^{c_2})]c_1\prec c_2
                &
                \circled{2}\ \Gamma\Rightarrow [\paral((\sig^{c_1})^\lup, (\sig^{c_2})^\lup)]c_1\prec c_2
            }
        }
    }
    $$
    }
    \end{center}
    where in this proof tree the formulae at node $\circled{2}$ and node $\circled{1}$ are the same.
    Thus the proof procedure will never terminate.
    \end{example}



    \ifx
    \begin{tiny}
         \begin{table}[htb]
         \begin{center}
         \scalebox{0.75}{
         \begin{tabular}[htp]{l l l l l l l l}
         \toprule
         %$(rRed)$ & $\begin{aligned}\infer[^{}]{\phi\{\pcd{N}{I}\}}{\phi\{O\}}\end{aligned}\IF \pcd{N}{I}\ded^* O$
         %&
         ${(r;\halt 1)}$ & $\halt; p\red \halt$
         &
         ${(r;\halt 2)}$ & $\alpha;\halt\red \halt$
         &
         ${(r;\mu)}$ & $\mu;p\red p$
         &
         ${(r;;)}$ &  $\rwt{(p;q);r}\red p;q;r$\\
         \\
         ${(r; \els 1)}$ & $(\varrho?p\els q); r\red \varrho?p;r\els q;r$
         &
         ${(r; \els 2)}$ & $(\varrho?p); q\red \varrho?p;q$
         &
         ${(r ; P? )}$ & $(P?p);q\red P?p;q$
         &
         ${(r\cup )}$ & $p\cup q\red q\cup p$\\
         \\
         ${(r\cup \halt)}$ & $p\cup \halt\red p$
         &
         ${(r\cup \mu)}$ & $\mu \cup \mu \red \mu$
         &
         ${(r\cup ;)}$ &  $\rwt{(p\cup q); r}\red p;r \cup q;r$
         &
         ${(r*\halt)}$ & $\halt^*\red \halt$\\
         \\
         ${(r*\mu)}$ & $\mu^*\red \mu$
         &
         ${(r*)}$ & $p^*\red p;p^*\cup \mu$
         &
         ${(r\paral)}$ & \multicolumn{3}{l}{$\paral (...,p_i,...,p_j,...)\red \paral (...,p_j,...,p_i,...)$}\\
         \\
         ${(r\paral \halt)}$ & $\paral(p_1,..., \halt, ...,p_n) \red \halt$
         &
         ${(r\paral \mu)}$ & \multicolumn{5}{l}{$\paral(p_1,..., p_i=\mu, ...,p_n) \red \paral(p_1,...,p_{i-1},p_{i+1},...,p_n)$}\\
         \\
          ${(r\paral 1)}$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(\alpha_1;p_1,..., \alpha_n; p_n)\red \mmerge(\alpha_1,...,\alpha_n); \paral (p_1,...,p_n)
          \ \mbox{where }\alpha_i\neq \mu, 1\le i\le n.\end{aligned}$}\\
          \\
         ${(r\paral 2)}$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(p_1,...,p_i,...,p_n)\red \paral (p_1,...,\ssub(q_1,\alpha, \varrho),...,p_n)\IF \match(\alpha, \varrho)\\
         &\mbox{where }p_i (1\le i\le n)\mbox{ is of the form }\varrho?q_1\els q_2 \mbox{ or }\varrho?q_1.\ \end{aligned}$}\\
         \\
          ${(r\paral 3)}$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(...,p_{k_l},...,r_j,...)\red \paral(...,p_{k_l},...,r'_j,...) \IF \neg \match(\alpha, \varrho_1)\wedge ...\wedge \neg \match(\alpha, \varrho_s)\\
          &\mbox{where there exists a }r_i (1\le i\le s)\mbox{ s.t. }r_i=\varrho_i?q_{i,1}\els q_{i,2}.\ \mbox{For all }1\le j\le s, r_j \mbox{ is of the form }\varrho_j?q_{j,1} \mbox{ or }\varrho_j?q_{j,1}\els q_{j,2}, \\
          &r'_j= \varrho_j?q_{j,1}\mbox{ if }r_j=\varrho_j?q_{j,1}.\ r'_j=q_{j,2}\mbox{ if }r_j=\varrho_j?q_{j,1}\els q_{j,2}.\end{aligned}$}\\
         \\
         ${(r\paral 4)}$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(...,p_{k_l},...,r_j,...)\red \alpha;\paral(...,p'_{k_l},...,r_j,...) \IF \neg \match(\alpha, \varrho_1)\wedge ...\wedge \neg \match(\alpha, \varrho_s)\\
          &\mbox{where for all }1\le j\le s, r_j=\varrho_j?q_{j,1}.\\
          \end{aligned}$}\\
          \multicolumn{8}{l}{$\begin{aligned}&\mbox{In rule \rul{r\paral 2}-\rul{r\paral 4}},\ p_{k_1}=\alpha_{k_1};p'_{k_1},...,p_{k_m}=\alpha_{k_m};p'_{k_m} \mbox{ are all programs of the form }\alpha;p \mbox{ among }p_1,...,p_n, \\ &\alpha_{k_l}\neq \mu \mbox{ for any }1\le l\le m.\
          \alpha=\mmerge(\alpha_{k_1},...,\alpha_{k_m}).\ \{r_1,...,r_s\}=\{p_1,...,p_n\}-\{p_{k_1},...,p_{k_m}\}.\ 1\le l\le m.\end{aligned}$}\\
          \\
         ${(r\paral \cup)}$ & \multicolumn{7}{l}{$\paral (p_1,...,p_i=p_{i,1}\cup p_{i,2},...,p_n)\red \paral(p_1,...,p_{i_1},...,p_n)\cup \paral (p_1,...,p_{i_2},...,p_n)$}\\
         \\
         %${(r\paral 4)}$ & \multicolumn{1}{l}{$\begin{aligned}\alpha;p\paral \varrho? q \red (\alpha;p)\paral q[\ssub(\alpha, \varrho)]\IF \match(\alpha, \varrho)\end{aligned}$}
         %&
         %${(r\paral 5)}$ & \multicolumn{1}{l}{$\begin{aligned}\alpha;p\paral \varrho? q \red \alpha; (p\paral \varrho?q)\IF \neg \match(\alpha, \varrho)\end{aligned}$}\\
         %\\
         ${(r\paral P?)}$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(p_1,...,P_1?p'_1,...,P_m?p'_m,...,p_n) \red P_1\wedge...\wedge P_m?\paral (p_1,...,p'_1,...,p'_m,...,p_n)\\
         &\mbox{where }P_1?p'_1,...,P_m?p'_m \mbox{ are all programs of the form }P?p' \mbox{ among }p_1,...,p_n.\end{aligned}$}\\
         \\
          $(r\paral * )$ & \multicolumn{7}{l}{$\begin{aligned}&\paral(p_1,...,p_i=q^*;r,...,p_n)\red Exp(\paral(p_1,...,\star(q^*);r,...,p_n))\ \ \mbox{where }p_i\not \red \halt \mbox{ for any }1\le i\le n.\end{aligned}$}\\
          \\
          $(r \locv{x})$ & $\begin{aligned}
          &\locv{x}p\red p[x'/x]\\
          &\mbox{where }x' \mbox{ is a new variable}
          \end{aligned}$
          &
        $(r)$ & $\begin{aligned}\infer[]
          {\phi\{p\}}
          {\phi\{q\}}\end{aligned}\IF p\red q$\\
         \bottomrule
          \end{tabular}
          }%end of scalebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Rewriting rules for SEPs}}
          \label{table:Rewriting rules for parallel SEPs}
          \end{table}
    \end{tiny}
    \fi


    \subsubsection{Algorithms in Rewrite Rules}
    The algorithms we present are in pseudo-code style where we freely use abstract variables and data structures such as sets, functions, etc.
    We use control statements in bold type like \textbf{if}...\textbf{then}...\textbf{else}..., \textbf{return}..., \textbf{continue}... and so on.
    We use `$\leftarrow$' to mean the assignment, and `$=$' to mean the logical judgment that two objects are equivalent or not.
    ``$/*...*/$'' denotes the remarks.
    For example, in \Algo~\ref{alg: Interaction Algorithm} below, $p\leftarrow \paral(p_1,...,p_n)$ means that a program $\paral(p_1,...,p_n)$ is assigned to a program variable named $p$;
    In \Algo~\ref{alg:Exp} below, we use $\Cur\leftarrow \Cur-\{q\}$ to express removing the element $q$ from the set $\Cur$.

    %And we freely use abstract variables like variables of programs, data structures such as sets, functions, etc, and other symbols or notions that have already appeared in this paper.
    %e.g., in Algo.~\ref{} below, $p\leftarrow \paral(p_1,...,p_n)$ means a program $\paral(p_1,...,p_n)$ is assigned to an abstract variable named $p$;
    %$\alpha\leftarrow \mmerge(\alpha_{k_1},...,\alpha_{k_m})$ means assigning the result of $\mmerge(\alpha_{k_1},...,\alpha_{k_m})$ to variable $\alpha$;
    %in Algo.~\ref{} below, we use $\Cur\leftarrow \Cur-\{q\}$ to express removing element $q$ in set $\Cur$.

    \begin{algorithm}[b]
    \begin{algorithmic}[1]	
    \Procedure{\Acommunicate}{$p=\paral(u_1,...,u_n)$}
    \State let $p_1\leftarrow \Call{\ATransf}{u_1}$, ..., $p_n\leftarrow \Call{\ATransf}{u_n}$, $p\leftarrow \paral(p_1,...,p_n)$
    %\If {there is an $r$ s.t. $p=\paral(p_1,...,p_{i-1},r,p_{i+1},...,p_n)$ and $r=\mu$}
    %    \State \textbf{return} \Call{\Acommunicate}{$\paral(p_1,...,p_{i-1},p_{i+1},...,p_n)$}
    \If {there is an $r$ such that $p=\paral(p_1,...,r,...,p_n)$ and $r=p_{i,1}\cup p_{i,2}$}
        \State \textbf{return} \Call{\Acommunicate}{$\paral(p_1,...,p_{i,1},...,p_n)$}$\cup$\Call{\Acommunicate}{$\paral(p_1,...,p_{i,2},...,p_n)$}
    \Else\ /*all $p_i$($1\le i\le n$) are of the form $\alpha;q$ or $\varrho\& P?\alpha;q$*/
        %\State solve $ddd(\paral(p_1,...,p_n))$ and get the solution $(b_\sig)_{\sig\in \Sig(\paral(p_1,...,p_n))}$
        %\State let $Sg\leftarrow \{\sig\ |\ b_\sig = tt\}$
        \State find all $p_{k_1},...,p_{k_m}$ in $p_1,...,p_n$ such that $p_{k_1} = a_{k_1};p'_{k_1},...,p_{k_m}=a_{k_m};p'_{k_m}$ ($a_{k_j}\in \{\alpha_{k_j}, P_{k_j}?\alpha_{k_j}\}$, $1\le j\le m$)
        %\State let $A \leftarrow \{p_{k_1},...,p_{k_m}\}$
        \State let $a\leftarrow \mmerge(a_{k_1},...,a_{k_m})$
        \State \textbf{return} \Call{\ACommu}{$\paral(p_1,...,p_n), a$}
    \EndIf
    \EndProcedure
    \end{algorithmic}
    \captionsetup{font=footnotesize}
    \caption{\footnotesize{Procedure \Acommunicate}}
    \label{alg: Interaction Algorithm}
    \end{algorithm}

    The main function of the procedure $\communicate$ is to transform a parallel SEP into a sequential one.
    As \Algo~\ref{alg: Interaction Algorithm} shows, procedure $\communicate$ is mainly based on the synchronous communication mechanism defined in Def.~\ref{definition:Semantics of Parallel trecs}.
    The main idea behind procedure $\communicate$ is as follows:
    \rmn{1} (line 2) We first apply procedure $\Transf$ to each sub program of $u_1,...,u_n$, and reduce them into one of the forms $\mu$, $p\cup q$, $\alpha;q$ or $\varrho\&P?\alpha;q$;
    \rmn{2} (lines 2 - 3) if there exists a program of the form $p\cup q$ after the transformation, then we transform the program according to the distributive law of $\paral$ in Prop.~\ref{proposition:equivalent relations};
    \rmn{3} (lines 5 - 8) if all programs are of the form $\mu$, $\alpha;q$ or $\varrho\&P?\alpha;q$, then like what we did in Def.~\ref{definition:Semantics of Parallel trecs} we
    set $a$ as the current observed event of the program $p$ and return the result of procedure $\Commu$.

    \begin{algorithm}[htb!]
    \begin{algorithmic}[1]
    \Procedure{\ATransf}{$p$}
    %\If {$p=\alpha$ or $p=\mu$} \textbf{return} $p$
    \If {$p=\mu ;q$} \textbf{return} \Call{\ATransf}{$q$}
    %\ElsIf {$p=\mu \cup q$ or $p=q\cup \mu$} \textbf{return} \Call{\Transf}{$q$}
    \ElsIf {$p=\mu^\lup$} \textbf{return} $\mu$
    \ElsIf {$p=(p_1;p_2);p_3$} \textbf{return} \Call{\ATransf}{$p_1;p_2;p_3$}
    \ElsIf {$p=(p_1\cup p_2);p_3$} \textbf{return} $p_1;p_3\cup p_2;p_3$
    \ElsIf {$p=q^\lup$ (or $p=q^\lup;r$)}
        \State \textbf{return} $\mu \cup q;q^\lup$ (or $r\cup q;q^\lup;r$)
    \ElsIf {$p=\paral(p_1,...,p_n)$ (or $p=\paral(p_1,...,p_n);q$)}
        \State $p\leftarrow \Call{\Acommunicate}{\paral(p_1,...,p_n)}$, \textbf{return} $p$ (or \Call{\ATransf}{$p;q$})
    \Else\ /*$p$ is of the form $\alpha$, $\mu$, $\alpha;q$ or $\varrho\& P?\alpha;q$*/
        \State \textbf{return} $p$
    \EndIf
    \EndProcedure
    \end{algorithmic}
    %\captionsetup{font=footnotesize}
    \caption{Procedure \ATransf}
    \label{alg:Interaction Transf Algorithm}
    \end{algorithm}

    Procedures $\Transf$ and $\Commu$ are given in \Algo~\ref{alg:Interaction Transf Algorithm} and \ref{alg: Interaction rec Algorithm} respectively.
    The main function of procedure $\Transf$ is to reduce a program into one of the forms $\mu$, $p\cup q$, $\alpha;q$ or $\varrho\&P?\alpha;q$ by applying the laws in Prop.~\ref{proposition:equivalent relations}.
    In \Algo~\ref{alg:Interaction Transf Algorithm}, lines 2-3, line 4, line 5 and lines 6-7 correspond to the laws \rmn{1}, \rmn{2}, \rmn{4} and \rmn{5} of Prop.~\ref{proposition:equivalent relations} respectively.
    If the program is of the form $\paral(p_1,...,p_n)$ or $\paral(p_1,...,p_n);q$ (lines 8-9), then we need to call another procedure $\communicate$ to further deal with the parallel part.

    \begin{algorithm}[pbt]
    \begin{algorithmic}[1]
    \Procedure{\ACommu}{$\paral(p_1,...,p_n), a$}
    %\State find all $p_{l_1},...,p_{l_o}$ in $p_1,...,p_n$ s.t. $p_{l_1}=P_1?\alpha_{1};q_{1},...,p_{l_o}=P_o?\alpha_o\& q_{o}$
    %\State let $A\leftarrow \{p_{l_1},...,p_{l_o}\}$
    %\State let $B\leftarrow \{p_1,...,p_n\} - (\{p_{k_1},...,p_{k_m}\}\cup \{p_{l_1},...,p_{l_o}\})$\ /*$B$ equals the set of programs of the form $\varrho?\alpha;q$ or $\varrho\& P?\alpha;q$*/
    \If {there is an $r=p_i$ ($1\le i\le n$) in $p_1,...,p_n$ such that $r=\mu$}
        %\State let $p\leftarrow \paral(p_1,...,p_{i-1},p_{i+1},...,p_n)$ /*remove $r$ from $p_1,...,p_n$*/
        \State \textbf{return} \Call{\ACommu}{$\paral(p_1,...,p_{i-1},p_{i+1},...,p_n), a$}\ /*remove $r$ from $p_1,...,p_n$*/
    \ElsIf {there exist $r_1,...,r_m$ in $p_1,...,p_n$ such that $r_k = \varrho_k\& P_k?\beta_k;q_k$ ($1\le k\le m$)}
        \If {$\match(a, \varrho_k)$ holds for all $1\le k\le m$}
            \For {each $k$}
                let $r'_k\leftarrow P_k?\ssub(\beta_k,a,\varrho_k);\ssub(q_k, a,\varrho_k)$
            \EndFor
            \State let $a'\leftarrow \mmerge(P_1?\ssub(\beta_1,a,\varrho_1), ..., P_m?\ssub(\beta_m,a,\varrho_m), a)$
            \State \textbf{return} \Call{\ACommu}{$\paral(p_1,...,r'_1,...,r'_m,...,p_n), a'$}
        \Else\ /*there exists $1\le k\le m$ such that $\neg \match(a, \varrho_k)$ holds*/
            \State \textbf{return} $\halt$ /*the program reaches a deadlock*/
        \EndIf
        %\State \textbf{return} $\alpha;\paral(q_1,...,q_n)$
    \Else\ /*for all $p_1,...,p_n$, $p_1=a_1;p'_1$,...,$p_n=a_n;p'_n$ ($a_j\in \{\alpha_j, P_j?\alpha_j\}$, $1\le i\le n$)*/
    \State \textbf{return} $a;\paral(p'_1,...,p'_n)$
    \EndIf
    \EndProcedure
    \end{algorithmic}
    %\captionsetup{font=footnotesize}
    \caption{Procedure \ACommu}
    \label{alg: Interaction rec Algorithm}
    \end{algorithm}

    Procedure $\Commu$ in \Algo~\ref{alg: Interaction rec Algorithm} is just an implementation of the function $\Commu$ defined in Def.~\ref{definition:Semantics of Parallel trecs}.
    Lines 2-3, lines 5-8, lines 9-10 and lines 11-12 correspond to the conditions \rmn{1}, \rmn{2}(1), \rmn{2}(2) and \rmn{3} in Def.~\ref{definition:Semantics of Parallel trecs} respectively.
    The main difference is when the program reaches a deadlock, procedure $\Commu$ returns the miracle program $\halt$, whose semantics corresponds to an empty set $\emptyset$. 

    \begin{example}
    \label{example:alg 1}
    Consider the digital filter program $\DF$ in Example~\ref{example:Digital Filter System}, write $\Fil$ and $\Fee$ as: $\Fil = (\sig_r;p_1)^\lup;\halt$ and $\Fee = (\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt$,
    where $p_1 = \hat{\sig_p}?\epsilon;\hat{\sig_p}?\epsilon;\hat{\sig_e}?\sig_o$, $q_1 = (P_1?\alpha_2\cup P_2\alpha_3)^\lup;f=1?\sig_e$.
    The execution procedure of $\communicate(\DF)$ is shown below:
    %the process of how program $DF$ evolves in $\communicate$ is shown as follows:
    $$
    \begin{aligned}
    \communicate: \DF =&\ \paral((\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)\\
    \longrightarrow_{l2, I}&\ \paral(\Transf((\sig_r;p_1)^\lup;\halt), \Transf((\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))\\
    \longrightarrow_{l6-7, T}&\ \paral(\halt\cup (\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, \halt\cup (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)\\
    \longrightarrow_{l4, I}&\ \communicate(\paral(\halt,\halt))\cup \communicate(\paral(\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))\cup &(1)\\
            &\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, \halt))\cup \\
            &\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))\\
    \longrightarrow... \longrightarrow&\ H(\halt)\cup a';\paral(p_1;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)&(2)
    \end{aligned}
    $$
    where the execution procedure of $\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))$ is as follows:
    %the procedure of $\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))$ is as follows:
    $$
    \begin{aligned}
    \communicate:&\ \paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)\\
        \longrightarrow_{l2, I}&\ \paral(\Transf((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt), \Transf((\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))\\
        \longrightarrow_{l4, T}&\ \paral(\sig_r;p_1;(\sig_r;p_1)^\lup;\halt, \hat{\sig_r}?\alpha_1;q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)\\
        \longrightarrow_{l5-8, I}&\ \Commu(\paral(\sig_r;p_1;(\sig_r;p_1)^\lup;\halt, \hat{\sig_r}?\alpha_1;q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt), a)&(3)\\
        \longrightarrow_{l5-8, C}&\ \Commu(\paral(\sig_r;p_1;(\sig_r;p_1)^\lup;\halt, \alpha_1;q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt), a')&(4)\\
        \longrightarrow_{l11-12, C}&\ a';\paral(p_1;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)\\
        \longrightarrow&\ a';\paral(p_1;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)
    \end{aligned}
    $$

    The flow $F: X_1\longrightarrow X_2\longrightarrow ...\longrightarrow X_n$ explains how a data $X_1$ evolves as the procedure $F$ executes.
    %the evolution of the input data $X_1$ as the execution of a procedure.
    $X \longrightarrow_{lx-y, F} Y$ ($F\in \{I, T, C\}$) means that from $X$, by executing the code from line $x$ to line $y$ of the procedure $F$, we obtain $Y$.
    The symbols $I, T, C$ stand for procedures $\communicate$, $\Transf$ and $\Commu$ respectively.
    For example, from $(3)$, by lines 5-8 of procedure $\Commu$, we obtain $(4)$, where $a=\sig_r$ and $a' = (\sig_r|\alpha_1)$.
    At $(1)$ we see that the program $\DF$ is split into 4 parts, linked by $\cup$.
    From $(1)$, after several steps of executing $\communicate$ recursively, we obtain $(2)$ as the final result.
    Here we only focus on the detailed procedure of the last part $\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))$,
    since other 3  parts: $\communicate(\paral(\halt,\halt))$, $\communicate(\paral(\halt, (\hat{\sig_r}?\alpha_1;q_1);(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))$ and 
    $\communicate(\paral((\sig_r;p_1);(\sig_r;p_1)^\lup;\halt, \halt))$
    return miracle programs as they all begin with a program of the form $\ff?\alpha$.
    For example, for the first part, we have $\communicate(\halt, \halt) = \halt$. 
    Generally, we denote any miracle program as $H(\halt)$.
    %Actually, all programs that will halt have the same semantics in CDL, i.e., there is $H(\halt)\equiv \halt$.
    \end{example}

    \begin{algorithm}[ptb]
    \begin{algorithmic}[1]
    \Procedure{Exp}{$p$} /*$p = \paral(q_1,...,p_i=\star(q^\lup);r,...,q_n)$*/
    %\State $f_p\leftarrow
    \State $\Ptn\leftarrow \emptyset$ /*programs already treated*/
    \State $\Cur\leftarrow p$ /*programs remained to be treated*/
    \State $\Equ\leftarrow \emptyset$ /*the set of equations*/
    %\State $\Ptn\leftarrow p$ /*state already created*/
    %\State $\Auto, \Init, \Final, \Trans \leftarrow \{p\}, p, \emptyset, \emptyset$ /*intializing automaton*/
    %\State $N\leftarrow 1$ /*state number*/
    %\State $\Init\leftarrow p, \Auto\leftarrow p$
    \While{$\Cur\neq \emptyset$}
        \State choose a program $q\in \Cur$, $\Cur\leftarrow \Cur-\{q\}$, $\Ptn\leftarrow \Ptn\cup \{q\}$
        %\State $R\leftarrow \emptyset$
        \State $q'\leftarrow \Call{\Acommunicate}{q}$\ /*$q'=t_1\cup ...\cup t_n$ $(n\ge 1)$, each $t_i$ is of the form $a$ or $a;q''$, where $a\in \{\alpha, \varrho\& P?\alpha\}$*/
        %\State $N\leftarrow N+1$
        \State $\Equ \leftarrow \Equ \cup \{q \equiv q'\}$\ /*build equation and add it to $\Equ$*/
        \For {each $t_i$ in $q' = t_1\cup...\cup t_n$ ($1\le i\le n$)}
            \If {$t_i = a;q''\wedge \Tag(q'')\wedge q''\notin \Ptn$}
            \State $\Cur \leftarrow \Cur\cup \{q''\}$ /*further reduce other programs not treated before*/
            \EndIf
        \EndFor
    \EndWhile
    \State \textbf{return} \Call{\ASolv}{$\Equ$}
    \EndProcedure
    \end{algorithmic}
    %\captionsetup{font=footnotesize}
    \caption{Procedure \AExp}
    \label{alg:Exp}
    \end{algorithm}

    Procedure $\Exp$ (in \Algo\ref{alg:Exp}) is mainly based on the Brzozowski's method for transforming a regular language into an equivalent finite automaton~\cite{journals/jacm/Brzozowski64}.
    It continuously reduces the parallel program until a set of equations is formed.
    By solving this equations using Arden's rule (Prop.~\ref{prop:ardens rule} below), procedure $\Exp$ returns the sequential program in which the target loop operator (tagged by $\star$) has been eliminated.

    The main idea behind $\Exp$ is as follows:
    \rmn{1} (lines 2-4) We initialize the sets $\Ptn$, $\Cur$ and $\Equ$;
    \rmn{2} (lines 6-8) we reduce the current program $q$ into the form $q' = t_1\cup ...\cup t_n$ by procedure $\communicate$, and we build an equation $q\equiv q'$;
    \rmn{3} (lines 9-11) for any $t_i$ of the form $a;q''$, if $q''$ still contains the target loop operator inside and has not been reduced yet, we further reduce $q''$;
    \rmn{4} (line 12) we solve the set of equations $\Equ$ in procedure $\Solv$.
    The function $\Tag(p)$ returns $true$ if the target loop program is in $p$.

    \begin{example}
    \label{example:alg 2}
    Following Example~\ref{example:alg 1}, we consider the execution procedure of $\Exp(\DF)$ (where $\DF = \paral(\star(\sig_r;p_1)^\lup;\halt, (\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)$) as follows:
    $$
    \begin{aligned}
    \Exp:&\ \emptyset \\
    \longrightarrow_{l5-11, E}&\ w_1\equiv H_1(\halt)\cup (\sig_r|\alpha_1);w_2\\
    \longrightarrow_{l5-11, E}&\ w_2 \equiv H_2(\halt)\cup P_1?\alpha_2;w_3\cup P_2?\alpha_3;w_3\\
    \longrightarrow_{l5-11, E}&\ w_3 \equiv \halt\cup P_1?\alpha_2;w_4\cup P_2?\alpha_3;w_4\\
    \longrightarrow_{l5-11, E}&\ w_4 \equiv H_3(\halt)\cup f=1?(\sig_o|\sig_e);w_1
    \end{aligned}
    $$
    where programs $w_1,w_2, w_3, w_4$ are listed in the following table:
    \begin{center}
    \scalebox{0.9}{
    \begin{tabular}{| l | l |}
    \hline
    $w_1 = \DF$ & $w_2 = \paral(p_1;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)$\\
    \hline
    $w_3 = \paral(\sig_p?\epsilon;\hat{\sig_e}?\sig_o;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)$ & $w_4 = \paral(\hat{\sig_e}?\sig_o;(\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt)$\\
    %\hline
    %$w_5 = \paral((\sig_r;p_1)^\lup;\halt, q_1;(\hat{\sig_r}?\alpha_1;q_1)^\lup;\halt))$ &\\
    \hline
    \end{tabular}
    }%end scalebox
    \end{center}

    In the flow above, at each step the data represents the equation $\Exp$ generated at the current loop. The symbol $E$ stands for $\Exp$.
    For example, at the first step, by executing lines 5-11 of procedure $\Exp$, we obtain the equation $w_1\equiv H_1(\halt)\cup (\sig_r|\alpha_1);w_2$.
    The program $H_1(\halt)\cup (\sig_r|\alpha_1);w_2$ is just the result returned by $\communicate(\DF)$ in Example~\ref{example:alg 1}.
    The explicit structure of the miracle programs $H_1(\halt)$, $H_2(\halt)$ and $H_3(\halt)$ are omitted because their semantics are just equivalent to $\halt$.
    \end{example}

    \begin{algorithm}[ptb]
    \begin{algorithmic}[1]
    \Procedure{Solv}{$\Equ$}
    %\State $(\Auto', \eqc{\Init}, \Final', \Trans')\leftarrow \Call{Sim}{\Auto, \Init, \Final, \Trans}$ /*simplifying the automaton as a DFA by removing $\mu$ transitions.*/
    \State equations in $\Equ$ are listed below, where $p_{ij}$  ($1\le i, j\le n$) is of the form $a_1\cup...\cup a_o$, $a_k\in \{\alpha, P?\alpha\}$ ($1\le k\le o$):
        $$\begin{aligned}
    \state_1&\equiv\gamma_1\cup p_{11};\state_1\cup p_{12};\state_2\cup...\cup p_{1n};\state_n &(1)\\
    \state_2&\equiv\gamma_2\cup p_{21};\state_1\cup p_{22};\state_2\cup...\cup p_{2n};\state_n &(2)\\
    &...\\
    \state_n&\equiv\gamma_n\cup p_{n1};\state_1\cup p_{n2};\state_2\cup...\cup p_{nn};\state_n &(n)
    \end{aligned}$$
    \For{each $k$, $k = n, n-1, ..., 2, 1$}
        \State substitute $\state_{k+1},...,\state_{n}$ in equation $(k)$ and transform it into the form $\state_k\equiv p\cup q;\state_k$.
        \State
        apply Arden's rule, eliminate $\state_k$ on the right side of $\state_k\equiv p\cup q;\state_k$ and get $\state_k\equiv q^\lup ;p$.
    \EndFor
    %\State removing $\mu$ in $w_1$ by the rule $\mu;p=p;\mu=p$.
    \State \textbf{return} $w_1$
    \EndProcedure
    \end{algorithmic}
    \captionsetup{font=footnotesize}
    \caption{\footnotesize{Procedure $Solv$}}
    \label{alg:Solv}
    \end{algorithm}

    Procedure $\Solv$ describes the process of solving the equations obtained from procedure $\Exp$.
    It turns out to be a standard procedure for solving the algebra equations using Arden's rule~\cite{conf/focs/Arden61}.
    In SEP, Arden's rule can be stated as the following proposition.

    \begin{proposition}[Arden's Rule in SEP]
    \label{prop:ardens rule}
    Given any SEPs $p$ and $q$ with $q\not\equiv \mu$,
    $$X\equiv q^\lup;p\mbox{ is the only solution of }X\equiv p\cup q;X.$$
    \end{proposition}

    \begin{proof}[Proof Sketch]
    The proof of Prop.~\ref{prop:ardens rule} is quite straight forward because according to the syntax of SEPs (Def.~\ref{definition: Synchronous Event Program}),
    SEP is in fact a sub-language of an \emph{omega language} whose syntax is just the same as the syntax of SEPs except that we define $p^*$ and $p^\omega$ instead of $p^\lup$.
    $p^*$ is the finite loop program as we saw in FODL while the infinite word $p^\omega$ represents the program that executes $p$ for infinite times.
    With $p^*$ and $p^\omega$, the infinite loop program $p^\lup$ in SEP can be expressed as: $p^\lup = p^*\cup p^\omega$. 
    The omega language follows the theory of the omega algebra proposed in~\cite{conf/RelMiCS/LaurenceS11-omegaAlgebra},
    %In the theory of omega algebra~\cite{conf/RelMiCS/LaurenceS11-omegaAlgebra}, 
    according to which it is not hard to see that the programs $q^*;p$ and $(q^*\cup q^\omega);p$ are the least and greatest solutions of the equation $X\equiv p\cup q;X$.
    Thus except for $q^\lup;p$ (note that $q^\lup\equiv q^*\cup q^\omega$), we cannot find other solutions between $q^*;p$ and $(q^*\cup q^\omega);p$ in SEPs.
    \end{proof}

    \begin{example}
    \label{example:alg 5}
    Continuing the Example~\ref{example:alg 2}, the flow of solving the equations obtained in $\Exp(\DF)$ is described as follows:
    $$
    \begin{aligned}
    \Solv:&\ \emptyset, k=5\\
    \longrightarrow_{l4-5, S}&\ w_4 \equiv H_3\cup u_1;w_1, k=4 &(1)\\
    \longrightarrow_{l4-5, S}&\ w_3 \equiv \halt\cup (a_1\cup a_2);H_3\cup (a_1\cup a_2);u_1;w_1, k=3 &(2)\\
    \longrightarrow_{l4-5, S}&\ w_2 \equiv H_4 \cup (a_1\cup a_2);(a_1\cup a_2);u_1;w_1, k=1\\
    \longrightarrow_{l4-5, S}&\ w_1 \equiv H_1\cup u_2;H_4\cup u_2;(a_1\cup a_2);(a_1\cup a_2);u_1;w_1, k=0 &(3)\\
    \longrightarrow_{l4-5, S}&\ w_1\equiv (u_2;(a_1\cup a_2);(a_1\cup a_2);u_1)^\lup;(H_1\cup u_2;H_4), k=0 &(4)
    %\longrightarrow&\ w_1\equiv (u_2;(a_1\cup a_2);(a_1\cup a_2);u_1)^\lup;\halt
    \end{aligned}
    $$
    where $a_1 = P_1?\alpha_2$, $a_2 = P_2?\alpha_3$, $u_1 = (f=1)?(\sig_o|\sig_e)$, $u_2 = (\sig_r|\alpha_1)$, $H_4 = H_2\cup (a_1\cup a_2);\halt\cup (a_1\cup a_2);(a_1\cup a_2);H_3$.

    The flow shows the value of $k$  and the equation dealt with in each loop on lines $3-6$ in $\Solv$.
    The symbol $S$ stands for $\Solv$.
    For example, from (1) to (2), after executing lines 4-5 of $\Solv$, we obtain the equation $w_3\equiv ...$ by substituting $w_4$ with $H_3\cup u_1;w_1$.
    From (3) to (4), we obtain the final program $w_1$ by applying Arden's rule (Prop.~\ref{prop:ardens rule}) to (3).
    Note that $H_1\cup u_2;H_4$ is a miracle program, since $H_1\cup u_2;H_4\equiv \halt$. The program can be further simplified before returned, and we finally get
    $$\Exp(\DF) = (u_2;(a_1\cup a_2);(a_1\cup a_2);u_1)^\lup;\halt.$$
    \end{example}


     \subsection{An Example}
    \label{subsection:An Example}
    At the end of this section, we give a complete example of verifying a CCSL specification of a synchronous system in CDL.
    In the digital filter system given in Example~\ref{example:Digital Filter System}, consider a CCSL specification expressed in a CDL formula as follows:
    $$I\to [\DF]c_r\prec c_o. $$
    It means that if $I$ holds, then all executing traces of the program $\DF$ satisfy the clock relation $c_r\prec c_o$.
    $I$ is the initial condition of clock-related variables of the program,
    %By Prop.~\ref{}, we restrict to only consider the satisfaction $tr\vDash_{ccsl}c_r\prec c_o$ of all initial traces $tr$ of $DF$ by
    let $$I = \bigwedge_{c\in \{c_e, c_p, c_r, c_o\}}(c^n=0\wedge c^s=0).$$
    This specification is illustrated as the red arrows in Fig.~\ref{figure:The schedule of system Sdf}, which means only after the ``Ready'' message has been sent, the output can be generated through port $o$.
    It is a simple unbounded CCSL specification, which captures an important safety property in synchronous systems.
    %as its corresponding automaton has infinite number of states.

    \begin{figure}[htb]
        \centering
        \scalebox{0.8}{
    \begin{tikzpicture}[->,>=stealth', node distance=1.7cm]
     % Position of QUERY
     % Use previously defined 'state' as layout (see above)
     % use tabular for content to get columns/rows
     % parbox to limit width of the listing
     %\node[state, initial] (w0) {$\eqc{p_1}$};
     %\node[]
     \ifx
     \node[state, draw=none] (ctx3)
     {
     $\infer[]
     {\circled{8}\ \Gamma_2,P_1\Rightarrow [\alpha_2][p_2;u_1]c_r\prec c_o}
     {}
     $
     };%end node
     \fi

     \node[state, draw=none] (ctx2)
     {
        $\infer[^{(\pi[;], \wedge r)}]
        {\circled{9}\ \varphi_1\Rightarrow [(\sig_r|\alpha_1);p_2;p_2;u_1]c_r\prec c_o}
        {
            \infer[^{(\pi[])}]
            {\varphi_1\Rightarrow [(\sig_r|\alpha_1)]c_r\prec c_o}
            {
                \infer[^{(o)}]
                {\Gamma_2\Rightarrow \hbar(c_r\prec c_o)}
                {\bigwedge_{\varphi\in \Gamma_2}\varphi \to \hbar(c_r\prec c_o)}
            }
            &
            \infer[^{(\phi[])}]
            {\varphi_1\Rightarrow [(\sig_r|\alpha_1)][p_2;p_2;u_1]c_r\prec c_o}
            {
                \infer[^{(\pi[;], \wedge r)}]
                {\Gamma_2\Rightarrow [p_2;p_2;u_1]c_r\prec c_o}
                {
                    \infer[^{(\pi[\cup], \wedge r)}]
                    {\circled{13}\ \Gamma_2\Rightarrow [p_2]c_r\prec c_o}
                    {
                        \infer[]
                        {\Gamma_2\Rightarrow [a_1]c_r\prec c_o}
                        {\circled{10}\ ...}
                        &
                        \infer[^{(P?[], \to r)}]
                        {\Gamma_2\Rightarrow [a_2]c_r\prec c_o}
                        {
                            \infer[^{(\pi[])}]
                            {\Gamma_2, P_2\Rightarrow [\alpha_3]c_r\prec c_o}
                            {
                                \infer[^{(o)}]
                                {\Gamma_3\Rightarrow \hbar(c_r\prec c_o)}
                                {\circled{12}\ \bigwedge_{\varphi\in \Gamma_3}\varphi \to \hbar(c_r\prec c_o)}
                            }
                        }
                    }
                    &
                    \infer[^{}]
                    {\Gamma_2\Rightarrow [p_2][p_2;u_1]c_r\prec c_o}
                    {\circled{11}\ ...}
                }
            }
        }
        $
     };

     \node[state, below of=ctx2, yshift=-0.25cm, anchor=north, draw=none] (ctx1)
     {
        $\infer[^{(\to r, \wedge l)}]
         {\circled{1}\ \cdot \Rightarrow I\to [\paral(\Fil, \Fee)]c_r\prec c_o}
         {
            \infer[^{(r\paral \lup 2, r)}]
            {\circled{2}\ \Gamma_1\Rightarrow [\paral(\Fil, \Fee)]c_r\prec c_o}
            {
                \infer[^{(\pi[;], \wedge r)}]
                {\circled{3}\ \Gamma_1\Rightarrow [p^\lup_1;\halt]c_r\prec c_o}
                {
                    \infer[^{(\pi[\lup]i)}]
                    {\circled{4}\ \Gamma_1\Rightarrow [p^\lup_1]c_r\prec c_o}
                    {
                        \infer[^{([\lup]i)}]
                        {\circled{6}\ \Gamma_1\Rightarrow [p^\lup_1][p_1]c_r\prec c_o}
                        {
                            \infer[^{(o)}]
                            {\Gamma_1\Rightarrow \varphi_1}
                            {\bigwedge_{\varphi\in \Gamma_1}\varphi\to \varphi_1}
                            &
                            \infer[]
                            {\cdot\Rightarrow \varphi_1\to [p_1]\varphi_1}
                            {\circled{8}\ ...}
                            &
                            \infer[^{(\to r)}]
                            {\cdot\Rightarrow \varphi_1\to [p_1]c_r\prec c_o}
                            {
                                \circled{9}
                            }
                        }
                    }
                    &
                    \infer[]
                    {\circled{5}\ \Gamma_1\Rightarrow [p^\lup_1][\halt]c_r\prec c_o}
                    {\circled{7}\ ...}
                }
            }
         }
        $
     };
     % draw the paths and and print some Text below/above the graph
     %\draw[dashed, thick, rounded corners, red] ([xshift=-0.25cm, yshift=0.3cm]1.mid -| 1.west) rectangle ([yshift=-1cm-0.25cm,xshift=0.25cm]s13.south -| s13.east);
     \path
     %(1) edge node [right] {$\begin{gathered}\alpha_1\\ l22\end{gathered}$} (s1)
     ;
    \end{tikzpicture}
	    }%end scalebox

    \scalebox{0.87}{
    \begin{tabular}{|l|}
    \hline
    $P_1 = (x=2\wedge f=0)$, $P_2=(x<2\wedge f=0)$, $\alpha_1 = (x:=1|f:=0)$, $\alpha_2 = (\sig_p|f:=1)$, $\alpha_3=(\sig_p|x:=x+1)$ \\
    $p_1 = (\sig_r|\alpha_1);(P_1?\alpha_2\cup P_2?\alpha_3);(P_1?\alpha_2\cup P_2?\alpha_3);f=1?(\sig_o|\sig_e)$, $p_2 = P_1?\alpha_2\cup P_2?\alpha_3$\\
    $a_1 = P_1?\alpha_2$, $a_2 = P_2?\alpha_3$, $u_1 = (f=1)?(\sig_o|\sig_e)$\\
    \hline
    $\varphi_1 = c^n_r\ge c^n_o$, $\hbar(c_r\prec c_o) = c^n_r = c^n_o \to c^s_o = 0$\\
    $(c^n_r)', (c^s_r)', (c^s_e)', (c^n_p)', (c^s_p)', (c^s_o)', x'$ are new variables of $c^n_r$, $c^s_r$, $c^n_e$, $c^n_p$, $c^s_p$, $c^s_o$, $x$ \\
    \hline
    $\Gamma_1 : c^n_e=0, c^s_e=0, c^n_p=0, c^s_p=0, c^n_r=0, c^s_r=0, c^n_o=0, c^s_o=0$\\
    \hline
    $\Gamma_2 : \left\{(c^n_r)'\ge c^n_o\right\}, \begin{gathered}c^n_r = (c^n_r)' + 1, c^s_r = 1, x = 1, f = 0, \\ c^s_e=0, c^s_p=0, c^s_o=0\end{gathered}$\\
    \hline
    $\Gamma_3 : \left\{\begin{gathered}(c^n_r)'\ge c^n_o, c^n_r = (c^n_r)' + 1, (c^s_r)' = 1, x'=1, f=0\\ (c^s_e)'=0, (c^s_r)'=0, (c^s_o)'=0, x'<2\wedge f=0\end{gathered}\right\}$,
        $\begin{gathered}c^n_p = (c^n_p)' + 1, c^s_p = 1, x = x' + 1\\ c^s_e=0, c^s_r=0, c^s_o=0\end{gathered}$\\
    \hline
    \end{tabular}
    }%end scalebox
        \captionsetup{font=footnotesize}
        \caption{The deduction procedure of $I\to [\DF]c_r\prec c_o$}
        \label{figure:The deduction of CDL2}
    \end{figure}

    The deduction procedure of this specification is illustrated in Fig.~\ref{figure:The deduction of CDL2}.
    Starting from the root node (the node $\circled{1}$), the procedure answers ``yes'' iff every leave node of the proof tree returns a valid QF-AFOL formula,
    which can be checked through an SMT-checking procedure.
    %Inference rules with a `double line' indicate that there are more than one deductions between the premises and the conclusion,
    %and rules they are based on are listed on the right side.
    %For example, at node $\circled{3}$, by applying rules \rul{\pi[;]} and \rul{\wedge r} in sequence, we obtain two premises: nodes $\circled{4}$ and $\circled{5}$.
    The meanings of some symbols and the contexts $\Gamma_1, \Gamma_2, \Gamma_3$ are explained in the table of Fig.~\ref{figure:The deduction of CDL2},
    where as in Example~\ref{example:rules for synchronous event},  the formulae in $\Gamma_1$, $\Gamma_2$, $\Gamma_3$ that depend on the old value of each variable are given in braces `$\{\}$'.
    %Note that variables of the form like `$(c^n_r)^1$' is a new general variable (corresponding to $c^n_r$), not a clock-related variable.

    Due to space limitations in Fig.~\ref{figure:The deduction of CDL2}, we omit the details of some branches (the nodes $\circled{7}$, $\circled{8}$, $\circled{10}$, $\circled{11}$).
    From the node $\circled{2}$ to the node $\circled{3}$ rule \rul{r\paral \lup 2} is applied. The procedure of computing $\Exp(\DF)$ has already been shown in Example~\ref{example:alg 1}, \ref{example:alg 2}, \ref{example:alg 5} above.
    At the node $\circled{6}$, we apply rule \rul{[\lup]i} to eliminate the loop operator $\lup$.
    %This is the essential difference between inference method we adopt and model checking.
    This is the only place in the whole proof where user interactions are needed. 
    Here we need to manually decide the loop invariant $\varphi_1$.
    The selection of a suitable invariant is done according to the loop body (here $p_1$) and the formulae we want to verify after the loop program (here $[p_1]c_r\prec c_o$).
    Here we have to guarantee that $c^n_r\ge c^n_o$ always holds during each execution of $p_1$, otherwise $[p_1]c_1\prec c_2$ may not hold for some state after the execution of $p^\lup_1$.
    %`$C_1\vee C_2$' is to make sure that $n, f$ can only be `reasonable values' during the execution of $p_1$.
    %The methods of efficiently and automatically deciding loop invariants is definitely out of the scope of this paper.
    It is not hard to see that each leave node is a valid QF-AFOL formula. For example, at the node $\circled{12}$,
    from $(c^n_r)'\ge c^n_o$ and $c^n_r = (c^n_r)'+1$ in $\Gamma_3$, we can conclude that $(c^n_r)'+1>c^n_o$ holds. So $c^n_r>c^n_o$ holds, and therefore $\hbar(c_r\prec c_o)$ holds.


    %clearly from $\Gamma_4$, we have $C_2$ holds. In $\Gamma_4$, since $z_1=0\wedge z_2=0$(in $P_1[z_1,z_2/n,y]$), there is $(c^n_r)^3-(c^n_o)^3>1$(from $\varphi_1[\vec \vv^3,z_1,z_2/\vec \vv,n,f]$).
    %Because $c^n_r=(c^n_r)^3$, $c^n_o=(c^n_o)^3+1$, so $c^n_r>c^n_o$ holds.


    \section{The Encoding of CCSL Specifications in CDL}
    \label{section: The Encoding of CCSL Specification in CDL}
    In \Sect~\ref{subsection:An Example}, we have seen how to verify a simple CCSL specification $c_r\prec c_o$ of the synchronous model $\DF$ in CDL.
    However, in general, not all CCSL specifications can be directly expressed in the form $I\to [p]\Rel$.
    As indicated in Fig.~\ref{figure:An overview of CDL},
    when a CCSL specification contains clock definitions, we need to first encode them as program observers since they can generate new clocks while observing existing clocks from the systems~\cite{Andre:2009:SVT:1542452.1542475,6380695}.
    Fig.~\ref{figure:observers} shows clock definition $c\triangleq c_1 + c_2$, as a program observer, interacts with the system program: at each instant, it observes clocks $c_1$ and $c_2$  from the system program, and triggers clock $c$ if either clock $c_1$ or clock $c_2$ ticks. %the certain condition meets.
    In this section, we mainly propose an encoding of clock definitions as SEPs.

    \begin{figure}[htb]
        \centering
        %\begin{minipage}[htp]{.475\linewidth}
        %\centering
        \fontsize{18pt}{18pt}\selectfont
        \scalebox{0.5}{\input{./figures/observer2.pdf_tex}}
        \captionsetup{font=footnotesize}
        \caption{\footnotesize{Clock definition $c\triangleq c_1+c_2$ as a program observer}}
        \label{figure:observers}
        %\end{minipage}
        %\hfill
    \end{figure}

    CDL provides a natural way to express clock definitions as SEPs since it contains signals as primitives.
    Table~\ref{table:Encoding of Clock Definitions} lists the encoding for each clock definition $cdf$, denoted as $cdf^E$.
    %We use $Cdf^E$ to represent the encoding of definition $Cdf$.
    Generally, the program observer has the form: $$\alpha_1;p^\lup;\alpha_2,$$ where
    %The structure of the program observers can be divided into three parts: 
   $\alpha_1$ is an initial event that initializes local variables used in the observer,
    $p$ is the main loop body responsible for modeling the semantics of the clock definition,
    $\alpha_2$ is called a \emph{final event} of the program. %as an end closes the program.
    %The program of the form $p^\lup;\halt$ expresses an infinite loop and amounts to the command `while $true$ do $p$' in common imperative programs.

    The syntactic sugar $p_{wait} = \waitcase \varrho_1\& P_1 \ddo (\alpha_1;p_1) \ccase \varrho_2\& P_2\ddo (\alpha_2;p_1)\ccase... \ccase \varrho_n\& P_n\ddo (\alpha_n;p_n)$
    is defined as $$p_{wait} \dddef (\varrho?\epsilon)^\lup;(\varrho_1\&P_1?\alpha_1;p_1\cup \varrho_2\& P_2?\alpha_2;p_2\cup...\cup \varrho_n\&P_n?\alpha_n;p_n),$$
    where $\varrho\dddef \negf(\varrho_1\oor ...\oor \varrho_n)$, the function $\negf(\varrho)$ returns the negation of the condition $\varrho$, which is given as:
    \begin{enumerate}[label=(\arabic*)]
    \item $\negf(\hat{\sig}) \dddef \bar{\sig}$, $\negf(\bar{\sig})\dddef \hat{\sig}$;
    \item $\negf(\varrho_1\wedge \varrho_2)\dddef \negf(\varrho_1)\aand \negf(\varrho_2)$;
    \item $\negf(\varrho_1\vee \varrho_2) \dddef \negf(\varrho_1)\oor \negf(\varrho_2)$.
    \end{enumerate}
    The program $p_{wait}$ says that at each instant, it checks whether one of the conditions $\varrho_1\&P_1$,...,$\varrho_n\& P_n$ holds and executes the corresponding branches $\alpha_1;p_1$,...,$\alpha_n;p_n$.
    If none of these conditions hold, then the program simply waits for a unit of time and continues the judgement at the next instant.
    %If more than one conditions are satisfied, then the choice of which one to proceed is non-deterministic.
    The syntactic sugar $p_{ite} = \iif \varrho_1 \& P_1 \then (\alpha_1;p_1) \els (\beta;q)$ is defined as
    $$p_{ite} \dddef \varrho_1 \& P_1?\alpha_1;p_1 \cup P?\beta;q,$$
    where $P=\neg (P_1\vee...\vee P_n)$.
    It says that if the condition $\varrho_1\& P_1$ holds, then $\alpha_1;p_1$ proceeds, otherwise $\beta;q$ proceeds.

    \begingroup
    \centering
    \begin{table}[ptb]
         \begin{center}
         \noindent\makebox[\textwidth]{%
         \scalebox{0.9}{
         \renewcommand{\arraystretch}{1.5}
         \begin{tabular}[htp]{|l l l l|}
         \hline
         %$1.$
         %&
         %\multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'}:=\epsilon;(c'?\A)^*;\halt\end{aligned}$}
         %& (Atom)\\
        $1.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1+c_2}\dddef\epsilon;(\waitcase\hat{\sig^{c_1}}\oor \hat{\sig^{c_2}}\ddo \sig^c)^\lup;\halt\end{aligned}$}
        & (Union)\\
        \hline
        $2. $
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1*c_2}\dddef\epsilon;(\waitcase\hat{\sig^{c_1}}\aand \hat{\sig^{c_2}}\ddo\sig^c)^\lup;\halt\end{aligned}$}
        & (Intersection)\\
        \hline
        $3.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\blacktriangleright c_2} & \dddef\epsilon;(\waitcase\hat{\sig^{c_1}}\ddo \epsilon; \waitcase \hat{\sig^{c_2}}\ddo \sig^c)^\lup;\halt\end{aligned}$}
        & (Strict Sample)\\
        \hline
        $4.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\vartriangleright c_2} &\dddef \epsilon;(\waitcase\hat{\sig^{c_1}}\aand \bar{\sig^{c_2}}\ddo q \ccase \hat{\sig^{c_1}}\aand \hat{\sig^{c_2}}\ddo \sig^c )^\lup;\halt \mbox{ where}\\
        q&= \epsilon;\waitcase \hat{\sig^{c_2}}\ddo \sig^c
        \end{aligned}$}
        & (Sample)\\
        \hline
        $5.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\curvearrowright c_2}& \dddef x:=0; (\waitcase \hat{\sig^{c_1}}\aand\bar{\sig^{c_2}}\& x=0\ddo \sig^c\\
        &\ccase \hat{\sig^{c_2}}\& x = 0\ddo x:=1)^\lup;x=1?\epsilon
        \end{aligned}$}
        & (Interruption)\\
        \hline
        $6.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'\varpropto n}& \dddef x:=n;(\waitcase\hat{\sig^{c'}}\& x=0 \ddo (\sig^{c}|x:=n)\\
        &\ccase \hat{\sig^{c'}}\& x>0\ddo x:=x-1)^\lup;\halt\end{aligned}$} %\mbox{ where}\\
        %q_1& \ddef (\sig^{c}|x:=n),\ q_2\ddef x:=x-1\end{aligned}$}
        & (Periodicity)\\
        \hline
        $7.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'\ddollar n}& \dddef x:=n;(\waitcase\hat{\sig^{c'}}\& x=0\ddo \sig^c\ccase \hat{\sig^{c'}}\& x > 0\ddo x:=x-1)^\lup;\halt\end{aligned}$}%\mbox{ where}\\
        %q_1& :=x=0?c,\ q_2:=x>0?x:=x-1\end{aligned}$}
        & (Delay)\\
        \hline
        %\multicolumn{4}{l}{where $|V|=n$.}\\
        $8.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\wedge c_2}&\dddef x:=0;(\waitcase \hat{\sig^{c_1}}\aand \bar{\sig^{c_2}}\ddo q_1\ccase \hat{\sig^{c_1}}\aand \hat{\sig^{c_2}}\ddo \sig^c\\
        &\ccase \bar{\sig^{c_1}}\aand \hat{\sig^{c_2}}\ddo q_2))^\lup;\halt  \mbox{ where}\\
        q_1&= \iif x\ge 0\then (\sig^c | x:=x+1)\els x:=x+1,\\
        q_2&= \iif x\le 0\then (\sig^c | x:=x-1)\els x:=x-1
        \end{aligned}$}
        & (Infimum)\\
        \hline
        $9.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\vee c_2}&\dddef x:=0;(\waitcase \hat{\sig^{c_1}}\aand\bar{\sig^{c_2}}\ddo q_1\ccase \hat{\sig^{c_1}}\aand \hat{\sig^{c_2}}\ddo \sig^c \\
        &\ccase \bar{\sig^{c_1}}\aand \hat{\sig^{c_2}} \ddo q_2)^\lup;\halt \mbox{ where}\\
        q_1&= \iif x\le 0\then (\sig^c | x:=x+1)\els x:=x+1, \\
        q_2&= \iif x\ge 0\then (\sig^c | x:=x-1)\els x:=x-1
        \end{aligned}$}
        & (Supremum)\\
         \hline
          \end{tabular}
          }%end of scalebox
          }%end makebox
          \end{center}
          %\captionsetup{font=footnotesize}
          \caption{Encoding of clock definitions in CDL}
          \label{table:Encoding of Clock Definitions}
    \end{table}
    \endgroup

    \ifx
    \begin{tiny}
         \begin{table}[htb]

         \begin{center}
         \scalebox{0.75}{
         \begin{tabular}[htp]{l l l l}
         \toprule
         %$1.$
         %&
         %\multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'}:=\epsilon;(c'?\A)^*;\halt\end{aligned}$}
         %& (Atom)\\
        $1.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1+c_2}:=\epsilon;(c_1\oor c_2?\A)^*;\halt\end{aligned}$}
        & (Union)\\
        \\
        $2. $
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1*c_2}:=\epsilon;(c_1\aand c_2?\A)^*;\halt\end{aligned}$}
        & (Intersection)\\
        \\
        $3.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\blacktriangleright c_2} & := \epsilon;(c_1?\epsilon; c_2?c)^*;\halt\end{aligned}$}
        & (Strict Sample)\\
        \\
        $4.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\vartriangleright c_2} &:= \epsilon;(c_1\aand \bar{c_2}?(\epsilon;c_2?c)\els c_1\aand c_2?c)^*;\halt\end{aligned}$}
        & (Sample)\\
        \\
        $5.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\curvearrowright c_2}& := \locv{x}(x:=0; (x=0?\bar{c_2}\aand c_1?c\els c_2?x:=1)^*;x=1?\epsilon)\end{aligned}$}
        & (Interruption)\\
        \\
        $6.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'\varpropto n}& :=\locv{x}(x:=n;(c'?(q_1\cup q_2))^*;\halt) \mbox{ where}\\
        q_1& :=x=0?(c|x:=n),\ q_2:=x>0?x:=x-1\end{aligned}$}
        & (Periodicity)\\
        \\
        $7.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c'\$ n}& :=\locv{x}(x:=n;c'?(q_1\cup q_2)^*;\halt)\mbox{ where}\\
        q_1& :=x=0?c,\ q_2:=x>0?x:=x-1\end{aligned}$}
        & (Delay)\\
        \\
        %\multicolumn{4}{l}{where $|V|=n$.}\\
        $8.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\vee c_2}&:=\locv{x}(x:=0;(c_1\aand\bar{c_2}?q_1\els c_1\aand c_2?\A \els \bar{c_1}\aand c_2?q_2)^*;\halt) \mbox{ where}\\
        q_1&:=x\le 0?(\A | x:=x+1)\cup x>0?x:=x+1, \\
        q_2&:=x\ge 0?(\A | x:=x-1)\cup x<0?x:=x-1
        \end{aligned}$}
        & (Infimum)\\
        \\
        $9.$
        &
        \multicolumn{2}{l}{$\begin{aligned}\Encode{c\triangleq c_1\wedge c_2}&:=\locv{x}(x:=0;(c_1\aand \bar{c_2}?q_1\els c_1\aand c_2?c\els \bar{c_1}\aand c_2?q_2)^*;\halt ) \\
        q_1&:=x\ge 0?(\A | x:=x+1)\cup x<0?x:=x+1,\\
        q_2&:=x\le 0?(\A | x:=x-1)\cup x>0?x:=x-1
        \end{aligned}$}
        & (Supremum)\\
         \bottomrule
          \end{tabular}
          }%end of scalebox
          \end{center}
          \captionsetup{font=footnotesize}
          \caption{\footnotesize{Encoding of Clock Definitions}}
          \label{table:Encoding of Clock Definitions}
          \end{table}
    \end{tiny}
    \fi


	As shown in Table~\ref{table:Encoding of Clock Definitions}, 
    the program of Union (resp. Intersection) checks if the signal $\sig^{c_1}$ or (resp. and) $\sig^{c_2}$ emits (resp. emit   ) at each instant, if so, it emits the signal $\sig^c$, otherwise it waits for a unit of time.
    The program of Strict Sample first waits for the signal $\sig^{c_1}$, then it produces $\sig^{c}$ while the signal $\sig^{c_2}$ emits.
    The program of Sample behaves as Strict Sample, except that if the signals $\sig^{c_1}$ and $\sig^{c_2}$ emit simultaneously, the signal $\sig^c$ emits immediately.
    In the program of Interruption we need a local variable $x$ to indicate when the loop ends. When the signal $\sig^{c_1}$ emits and the signal $\sig^{c_2}$ does not, the program emits $\sig^c$.
    Once the signal $\sig^{c_2}$ emits, $x$ is set to $1$ and the loop ends.
    In the program of Periodicity,
    %describes signal $\sig^{c}$ occurs periodically based on the occurrence of $\sig^{c'}$.
    the variable $x$ is used to record the remaining times of the occurrences of $\sig^{c'}$ before the occurrence of $\sig^c$. It is initialized by $n$.
    At each instant when the signal $\sig^{c'}$ emits, $x$ is decreased by $1$.
    When $x=0$, the program emits $c$.
    In the program of Delay,
    %describes that signal $\sig^{c}$ occurs according to the frequency of $\sig^{c'}$, but it is delayed for $n$ occurrences of $\sig^{c'}$.
    $x$ is used to keep the remaining times of the occurrences of $\sig^{c'}$ before an occurrence of $\sig^c$.
    At the beginning when the signal $\sig^{c'}$ emits, $x$ is decreased by 1.
    When $x=0$, $\sig^c$ emits whenever $\sig^{c'}$ emits.
    %is almost the same as that of `Periodicity', except that after $x$ reaches $0$, it will never be reset to $n$.
    The program of Infimum and the program of Supremum are symmetrical.
    In the program of Infimum, we need a local variable $x$ to record the difference between the number of the occurrences of $\sig^{c_1}$ and $\sig^{c_2}$.
    %It is set to $0$ at the beginning.
    At each instant the signal $\sig^{c}$ emits iff the signal that occurs slower emits.
    For example, if the number of the occurrences of $\sig^{c_1}$ is more than that of $\sig^{c_2}$ (i.e., $x\ge 0$), %which means $\sig^{c_2}$ occurs slower than $\sig^{c_1}$,
    then
    $\sig^c$ emits in $q_2$ when $\sig^{c_2}$ emits.
    The situation for the program of Supremum is similar.
    We omit the details here. 

    At last, as indicated in Fig.~\ref{figure:Verification framework of CDL}, we show that any general CCSL specification can be fully captured by a CDL formula of the form
    $I\wedge I_c\to [\paral(p,q_1,...,q_n)]\Rel$.

\begin{definition}[Representation of CCSL specifications in \CDLP]
\label{definition: CDL Formulae Expressing CCSL Specifications}
Given an \SEPP\ $p$ and a CCSL specification $\la \mcl{C}, \cdf, \rel\ra$ where $\cdf=\{\ccdf_1,...,\ccdf_m\}$, $\rel=\{\RRel_1,...,\RRel_n\}$,
%without the lose of generality let $\mcl{C}(p)\subseteq \mcl{C}$,
then the verification problem of whether $p$ satisfies this specification can be expressed as a \CDLP\ formula:
$$\phi = I\wedge I_c\to [\paral (\epsilon; p, \ccdf^E_1,...,\ccdf^E_m)]\curlywedge (\RRel_1,..., \RRel_n), $$
%where clock set $\mcl{C}'=\mcl{C}\cup \mcl{C}(p)$.
%Denote the set of formulae of this form as $\CDLP_{Spec}$.
where $\displaystyle I = \bigwedge_{c\in \mcl{C}(p)}(c^n=0\wedge c^s=0)$ is an initial condition of the clock-related variables of the program $p$,
$\displaystyle I_c = \bigwedge_{c\in \mcl{C}}(c^n=0\wedge c^s=0)$ is an initial condition of the clock-related variables of the specification $\la \mcl{C}, \cdf, \rel\ra$.
Because of the initial event in $\ccdf^E_i$, we add an idle event $\epsilon$ before $p$.
\end{definition}

The initial condition $I\wedge I_c$ restricts us to only consider the satisfaction of $\rel$ by all initial traces of $\paral (\epsilon; p, \ccdf^E_1,...,\ccdf^E_m)$.
%According to Prop.~\ref{proposition:relation beween CCSL cr and CDL cr} and the encoding from CCSL specifications into SEPs discussed above, it is not hard to see that 
The proof of the formula $\phi$ reflects the satisfaction of the CCSL specification by all behaviours of $p$.
Note that in Def.~\ref{definition: CDL Formulae Expressing CCSL Specifications}, actually $\displaystyle I\wedge I_c = \bigwedge_{c\in \mcl{C}(p)\cup \mcl{C}}(c^n=0\wedge c^s=0)$.

\begin{example}
Consider another specification of the program $\DF$ in Example~\ref{example:Digital Filter System}: $$\la \mcl{C}, \{c_1\triangleq c_r\ddollar 1, c_2\triangleq c_p\varpropto 1\}, \{c_2\prec c_1\}\ra, $$
where $\mcl{C} = \{c_p, c_r, c_1, c_2\}$, $c_1$ and $c_2$ are new clocks generated by the clock definitions.
It means that only after receiving two pixels, the new ``Ready'' message is sent (as indicated as blue arrows in Fig.~\ref{figure:The schedule of system Sdf}).
In CDL, this specification can be encoded as the following formula:
$$\bigwedge_{c\in \mcl{C}\cup \mcl{C}(\DF)}(c^n=0\wedge c^s=0)\to [\paral (\epsilon;\DF, (c_1\triangleq c_r\ddollar 1)^E, (c_2\triangleq c_p\varpropto 1)^E]c_1\prec c_2, $$
where $\mcl{C}(\DF) = \{c_e, c_o, c_p, c_r\}$.
%Here we only need to consider the initial condition of the specification since $\mcl{C}(DF)\subseteq \mcl{C}$.
\end{example}


\ifx
Given a CCSL specification $Spec:=\la \mcl{C}, \cdf, \rel\ra$ and a program model $p$,
the verification problem that if $p$ satisfies specification $Spec$ can be expressed in CDL as:
$$\mscdl \bigwedge_{c\in \mcl{C}'}(c^n=0\wedge c^s=0)\to [\paral (\epsilon; p, cdf^E_1,...,cdf^E_m)]\curlywedge (Rel_1,..., Rel_n)$$,
where $\mcl{C}'=\mcl{C}\cup \mcl{C}(\paral (\epsilon; p, cdf^E_1,...,cdf^E_m))$, $\cdf=\{cdf_1,...,cdf_m\}$, $\rel=\{Rel_1,...,Rel_n\}$. The idle event $\epsilon$ before program $p$ is for synchronizing with the initial events in the SEPs of clock definitions.
It means that `given $c^n=0, c^s=0$ as initial conditions for each clock $c\in \mcl{C}$, all paths of executions of program $\paral (\epsilon; p, cdf^E_1,...,cdf^E_m)$ satisfy $\curlywedge (Rel_1,..., Rel_n)$'.
\fi

\ifx
\begin{figure}[!hptb]
    \centering
    %\begin{minipage}[htp]{.475\linewidth}
    %\centering
    \fontsize{18pt}{18pt}\selectfont
    \scalebox{1}{\input{./figures/df.pdf}}
    \captionsetup{font=footnotesize}
    \caption{\footnotesize{Digital Filter Feeder}}
    \label{figure:Digital Filter Feeder}
    %\end{minipage}
    %\hfill
    \end{figure}
\fi


\section{Soundness and Relative Completeness of CDL}
\label{section: Soundness and Relative Completeness of CDL Proof System}
In this section we analyze the soundness and relative completeness of the proof system of CDL.
As an extension of FODL, except for the rules for the special primitives in CDL, other rules are mainly inherited from FODL and traditional FOL.
We mainly focus on the soundness of those rules special in CDL.
%As a variation of dynamic logic,
The proof of the relative completeness of CDL is mainly inspired from that of FODL in \cite{journals/sigact/HarelKT01,books/sp/Harel79},
where a main theorem forms the proof skeleton, while the conditions of the main theorem describe the technical details of the proof.
In the proof of CDL we propose a similar main theorem (\Theo~\ref{theorem: Completeness of scdl}) with a set of modified conditions (the conditions \rmn{1} - \rmn{4} in \Theo~\ref{theorem: Completeness of scdl}). 
In the following we mainly analyze the critical points of the proof that are different from that of FODL,
and we leave the details in Appendix~\ref{section:The Proof of Soundness and Relative Completeness of CDL}.



%The main difference is the detail of the proof where we need to develop some theories to tackle the particularities of CDL different from FODL.
%In the following we mainly analyze the key points of the proof, and leave the details in Appendix.~\ref{subsection: The Proof of Theorem completeness}.

Before the analysis we first introduce the notion of \emph{deductive relation} in CDL.
    For a CDL formula $\phi$ and a multi-set $\Phi$ of formulae, $\Phi\dcdl \phi$ iff the sequent $\Phi\Rightarrow \phi$ can be derived using rules in Table~\ref{table:Rules for path formulae}, \ref{table:Rules for non-path formulae}, \ref{table: Rules for first order logic} and \ref{table:Rewriting rules for parallel SEP}.
    If $\Phi$ is empty, we also write $\dcdl \phi$.


    \subsection{Soundness}
\label{subsection:Soundness}
The soundness of the proof system of CDL is stated as the following theorem.
\begin{theorem}[Soundness of $\vdash_{cdl}$]
\label{theorem: Soundness of scdl}
Given any CDL formula $\phi$, if $\vdash_{cdl}\phi$, then $\mscdl \phi$.
\end{theorem}
To prove this theorem, we need to show that each rule $\begin{gathered}\infer[]{\Gamma\Rightarrow \Delta}{\Gamma_1\Rightarrow \Delta_1&...&\Gamma_n\Rightarrow \Delta_n}\end{gathered}$ in the proof system is sound in the sense that: $$\begin{gathered}\mbox{if }\mscdl \bigwedge_{\varphi_1\in \Gamma_1}\varphi_1\to \bigvee_{\varphi_2\in \Delta_1}\varphi_2,...,\mscdl \bigwedge_{\varphi_1\in \Gamma_n}\varphi_1\to \bigvee_{\varphi_2\in \Delta_n}\varphi_2, \mbox{ then }\\
\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1\to \bigvee_{\varphi_2\in \Delta}\varphi_2.\end{gathered}$$
%For each rewriting rules $p\red q$, we need to show that $\mscdl p$ iff $\mscdl q$.
%The proof of Theorem~\ref{theorem: Soundness of scdl} is technical but not difficult. We omit the detail but only give an analysis for each rule.

%Only rules in Table~\ref{table:Rules for path formulae}, rule \rul{\phi}, \rul{\mu} and \rul{r} need to be considered since others are directly inherited from traditional logics.

For the rules for sequential SEPs,
in \Sect~\ref{subsection:Proof Rules for Sequential SEPs} we have given an intuitive meaning for each rule and their relations to the corresponding rules in FODL.
The soundness of all FOL rules in Table~\ref{table: Rules for first order logic} is straightforward.
The key to prove rules \rul{\pi[;]}, \rul{\pi[\cup]}, \rul{\pi[\lup]u} and \rul{\pi[\lup]i} is to prove a temporal property possessed by clock relations (see Prop.~\ref{prop:Rel property} in Appendix~\ref{section:The Proof of Soundness}).
The proofs of rules \rul{\pi[\lup]u}, \rul{\pi[\lup]i}, \rul{[\lup]u}, \rul{[\lup]ind}, \rul{\la \lup\ra con}, \rul{[\lup]i} and \rul{\la \lup\ra i} are inspired from their counterparts in FODL.
%For the rules \rul{\pi[\lup]u}, \rul{\pi[\lup]i}, \rul{[\lup]u}, \rul{[\lup]ind}, \rul{\la \lup\ra con}, \rul{[\lup]i} and \rul{\la \lup\ra i},
As we have discussed in \Sect~\ref{subsection:Proof Rules for Sequential SEPs}, since we consider only partial correctness of the program, $[p^\lup]\phi$ actually means the same thing as $[p^*]\phi$ in FODL (see Prop.~\ref{lemma:relationship between sepp and rsepp} in Appendix~\ref{subsection: The Proof of Theorem completeness}).
The soundness of other rules can be directly obtained by the semantics of CDL, some of their proofs are given in Appendix~\ref{section:The Proof of Soundness}.

In the rules of parallel SEPs, rule \rul{r} can be proved by induction on the structure of the program hole $p\{\place\}$.
The correctness of the program reductions in procedure $\communicate$ can be directly proved according to the semantics of parallel SEPs (Def.~\ref{definition:Semantics of Parallel trecs} and \ref{definition: Semantics for parallel SEP}) and the equivalence relations between programs (Prop.~\ref{proposition:equivalent relations}). 
%The preservation of program equivalences in procedure $\communicate$ can be directly obtained from the semantics of parallel SEPs defined in Def.~\ref{definition:Semantics of Parallel trecs} and \ref{definition: Semantics for parallel SEP}, and the equivalence relations given in Prop.~\ref{proposition:equivalent relations}.
As for $\Exp$, to prove $p\equiv \Exp(p)$ we only need to prove Arden's rule in SEPs (Prop.\ref{prop:ardens rule}), which is straight forward as analyzed in \Sect~\ref{subsection:Rewriting Rules for Parallel SEPs}.

\subsection{Relative Completeness}
%We omit the detail for most of them but only give an example for some types of them in Appendix~\ref{section:The Proof of Soundness and Completeness}.
%an analysis for each rule.

As CDL contains AFOL in itself, which is generally incomplete due to G\"odel's incompleteness theorem~\cite{Goedel1931}, we consider the completeness of CDL relative to AFOL. 
%The notion of relative completeness was first introduced in \cite{journals/siamcomp/Cook78}.
In the analysis of the relative completeness we assume that the proof system contains all tautologies in the traditional AFOL.
We use $\Phi\dcdlf \phi$ to mean that $\Phi\Rightarrow \phi$ can be derived in the system that consists of all rules in Table~\ref{table:Rules for path formulae}, \ref{table:Rules for non-path formulae}, \ref{table: Rules for first order logic} and \ref{table:Rewriting rules for parallel SEP}, and all tautologies in AFOL as axioms.

%We augment the CDL proof system to also contain all tautologies in traditional AFOL and denote it by $\dscdlf$.
The proof skeleton of the relative completeness of CDL is stated as the following theorem.
It mainly follows the main theorem of \cite{books/sp/Harel79}, but is extended with the condition \rmn{4}, which describes a similar property as the condition \rmn{2} for formulae of the forms $[p]\Rel$ and $\la p\ra \nneg \Rel$.

%mainly follows the core idea of the proof for traditional FODL in \cite{books/sp/Harel79}.
%The difference is that we also consider formula of the form $[p]Rel^0$ where $Rel^0$ is a temporal formula, and to deal with concurrent SEPs.

We sometimes write $\varphi^\flat$ to stress that $\varphi$ is an AFOL formula.

\begin{theorem}[Relative Completeness of $\dcdl$]
\label{theorem: Completeness of scdl}
For any formula $\phi$, if $\mscdl \phi$, then $\dcdlf\phi$ holds if the following conditions are true:
\begin{enumerate}[label=(\roman*)]
\item For any CDL formula $\phi$, $\phi$ is expressible in AFOL.
 \item For any AFOL formulae $\varphi^\flat$ and $\phi^\flat$, if $\ISCDL\mscdl \varphi^\flat\to \mathop{op} \phi^\flat$, then $\dcdlf \varphi^\flat\to \mathop{op} \phi^\flat$.
\item For any formulae $\varphi$ and $\phi$, if $\dcdlf\varphi\to \phi$ then $\dcdlf \mathop{op}\varphi\to \mathop{op}\phi$.
\item For any AFOL formulae $\varphi^\flat$ and $\phi^\flat$, if $\ISCDL\mscdl \varphi^\flat\to [p] \Rel$, then $\dcdlf \varphi^\flat\to [p] \Rel$; if $\ISCDL\mscdl \varphi^\flat\to \la p\ra \nneg \Rel$, then $\dcdlf\varphi^\flat\to \la p\ra \nneg \Rel$.
\end{enumerate}
where $\mathop{op}\in \{[p], \la p\ra, \forall x, \exists x\}$, $x\in \Var$.
\end{theorem}

The proofs of the main body and each condition of \Theo~\ref{theorem: Completeness of scdl} are given in Appendix~\ref{subsection: The Proof of Theorem completeness}.
Having the conditions $\rmn{1} - \rmn{4}$, the proof of the main body of \Theo~\ref{theorem: Completeness of scdl} is direct and mainly follows \cite{books/sp/Harel79}.
In condition \rmn{1}, to prove the expressibility of CDL formulae, we need to first prove the expressibility of formulae of the form $[p]\phi^\flat$ (see Lemma~\ref{lemma: Expressibility of}).
In FODL, the expressibility of a formula $[p]\phi^\flat$ can be obtained by the expressibility of the program $p$ and induction on the syntactic structure of the formula.
However in CDL, SEP is not a regular language, it contains the infinite loop operator $\lup$ and the parallel operator $\paral$, which makes it difficult to prove its expressibility in a direct way.
To solve this problem we introduce a finite fragment of SEPs called \emph{\RSEPP s} (see Def.~\ref{definition:Finite SEP}). In order to show formula $[p]\phi^\flat$ (with an SEP $p$) is expressible, we first show that all \RSEPP s are expressible (see Lemma~\ref{lemma: Construction of Ap}),
then show how the case of an SEP can be reduced to the case of its corresponding \RSEPP\ based on the relation between SEPs and \RSEPP s (see Prop.~\ref{lemma:relationship between sepp and rsepp}).
\ifx
The detail of the proof of condition \rmn{1} is different from \cite{books/sp/Harel79} as the semantics of SEP is based on traces.
In the proof of \rmn{1}, directly proving dynamic formula $[p]\Rel$ is expressible in AFOL is not easy.
The main reason is that SEP contains operator $\lup$ that is able to express `infinite loop' behaviour and the parallel operator $\paral$.
%simply applying the proof for the regular program of FODL does not work for SEP.
%The main problem is that directly proving dynamic formula $[p]\Rel$ is expressible in AFOL is not easy.
To solve this problem we introduce a finite fragment of SEP called `\RSEPP'. In order to show SEP is expressible, we firstly show any \RSEPP\ is expressible,
then show how the case for SEP can be reduced to the case of the corresponding \RSEPP\ base on the relation between SEP and \RSEPP\ (Prop.~\ref{lemma:relationship between sepp and rsepp}).
\fi
The core idea behind the proof of condition \rmn{2} is mainly based on \cite{journals/sigact/HarelKT01,books/sp/Harel79}. It proceeds by induction on the syntactic structure of program.
Condition \rmn{3} is straightforward according to the proof system of CDL.
The proof of condition \rmn{4} is similar to that of \rmn{2}, %where we consider the formulae of the form $\varphi^\flat\to [p]\Rel$ and $\varphi^\flat\to \la p\ra \nneg \Rel$.
except that the special forms $[p]\Rel$ and $\la p\ra \nneg\Rel$ need to be treated in a special way.


\ifx
In the proof of $\rmn{1}$, changes need to be made to adapt the trace semantics of SEPs, the semantics of $p^\lup$ and the semantics of concurrent SEPs in CDL.

The proof of Theorem~\ref{theorem: Completeness of scdl} is given in Appendix~\ref{subsection: The Proof of Theorem completeness}, here we only give a general analysis.
Given $\rmn{1}, \rmn{2}, \rmn{3}$ hold, the proof is direct and mainly follows \cite{books/sp/Harel79}.
In the proof of $\rmn{1}$, changes need to be made to adapt the trace semantics of SEPs, the semantics of $p^*$ and the semantics of concurrent SEPs in CDL.
Condition \rmn{1} is restated as Lemma~\ref{lemma:Expressbility of CDL Formula} (in Appendix~\ref{subsection: The Proof of Theorem completeness}). To prove it we firstly build AFOL expressions for regular SEP programs (Def.~\ref{definition:Regular SEP}, Lemma~\ref{lemma: Construction of Ap}), based on which we then are able to show all dynamic formulae $[p]\phi^\flat$ are expressible in AFOL (Lemma~\ref{lemma: Expressibility of}).
%As can be seen in Appendix~\ref{subsection: The Proof of Theorem completeness},
%They are stated as Lemma~\ref{lemma: Construction of Ap} and Lemma~\ref{lemma: Expressibility of} respectively.
%The construction of AFOL formula for a regular SEP is stated as Lemma~\ref{lemma: Construction of Ap} (in Appendix~\ref{subsection: The Proof of Theorem completeness}).
%With this lemma it is easy to express formula $[p]\phi^\flat$ as an AFOL formula: $\forall \vec x(A_p(\vec v, \vec x)\to \phi^\flat[\vec x\sub \vec v])$.
\rmn{1} can be proved by induction on the structure of CDL formulae based on Lemma~\ref{lemma: Construction of Ap} and Lemma~\ref{lemma: Expressibility of}.
The proof of \rmn{2} and \rmn{3} (stated as Lemma~\ref{}, \ref{}) mainly follows \cite{books/sp/Harel79}, but we need to consider the formulae of the form $\varphi^\flat\to [p]Rel^0$ and $\varphi^\flat\to \la p\ra \neg Rel^0$.
The proof proceeds by the induction on the structure of program $p$. %, where we need to consider the case of concurrent SEPs as well.

To deal with concurrent SEPs in the proof of \rmn{1}, \rmn{2}, \rmn{3}, we can simply find an equivalent sequential program according to the soundness of rules in Table~\ref{table:Rewriting rules for parallel SEPs}.
Then the proof situation for concurrent SEPs can be transformed into the situation for sequential SEPs.
\fi

\ifx
\begin{definitiion}[Soundness of rules]
\label{definition: Soundness of rules}
Given a Kriple structure $(S, val)$, any rule $\begin{gathered}\infer[^{(...)}]{\Gamma\Rightarrow \Delta}{\Gamma_1\Rightarrow \Delta_1&...&\Gamma_n\Rightarrow \Delta_n}\end{gathered}$ is sound iff
if $\mscdl \bigwedge_{\varphi_1\in \Gamma_1}\varphi_1\to \bigvee_{\varphi_2\in \Delta_1}\varphi_2$,...,$\mscdl \bigwedge_{\varphi_1\in \Gamma_n}\varphi_1\to \bigvee_{\varphi_2\in \Delta_n}\varphi_2$, then $\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1\to \bigvee_{\varphi_2\in \Delta}\varphi_2$.
\end{definition}
\fi

\section{The Mechanization of CDL in Coq}
\label{section:Mechanization of CDL in Coq}

In this section we discuss the mechanization of CDL in Coq. 
%from which we can see the potential of the proposed CDL used in the verification of synchronous systems in practice.  
Currently, we only consider the mechanization of a fragment of CDL, which consists of all formulae that contain no parallel SEPs and all rules for sequential SEPs (i.e., the rules in Table~\ref{table:Rules for path formulae}, \ref{table:Rules for non-path formulae} and \ref{table: Rules for first order logic}). 
In the discussion below, we call this fragment of CDL \emph{sequential CDL} (\SeqCDL).
The implementation of the rewrite rules for parallel SEPs (i.e., the rules in Table~\ref{table:Rewriting rules for parallel SEP}) in Coq is our future work. 


The main idea behind the mechanization is to use Coq as a programming language to define the language of \SeqCDL\ as its types and functions and to implement the proof rules of \SeqCDL\ as its theorems. 
Currently, we have not considered implementing the semantics of \SeqCDL.  
We only define the syntax of \SeqCDL\ and define the proof rules of \SeqCDL\ as axioms in Coq without proving the their validity. 
These axioms act as a translator that transforms a given \SeqCDL\ formula into a set of QF-AFOL formulae by applying suitable proof tactics in Coq, just 
as the procedure of the deduction shown in \Sect~\ref{subsection:An Example}. 

In the following subsections we give a brief introduction to the mechanization of \SeqCDL\ in Coq. 
We mainly give the ideas and show some crucial points in the mechanization process. 
We give some critical definitions but omit the details of others. 
We have posted our current implementation on the website \url{https://github.com/antitaboo/CDL}, where interested readers can find more details about it. 

%In Sect.~\ref{} we first give a brief introduction to Coq, 
%Given a \SeqCDL\ formula, we can conduct the proofs in Coq 

\subsection{A Brief Introduction to Coq}
In this section we give a brief introduction to the theorem prover Coq. 
We only give informal explanations for some primitives of the language in Coq which is necessary for understanding the Coq code presented in this paper. 
%We only introduce the knowledge that is necessary for understanding the Coq code presented in this paper. 
Readers can refer to~\cite{series/txtcs/BertotC04} for a more comprehensive introduction. 

\subsubsection{The language of Coq}
\label{section:The language of Coq}
%Coq consists of a typed functional programming language called `\emph{Gallina}' for building programs and an auxiliary command language called `\emph{Vernacular}' for conducting the type inference in \textit{Gallina}. 
The core language of Coq (called \emph{Gallina}) is based on the theory of a typed $\lambda-$calculus called \emph{Calculus of Inductive Constructions}. 
It is a type of higher-order functional programming languages provided with the ability to define inductive types. 
%The type system of Coq consists of the \emph{simple type} inherited from the typed $\lambda-$calculus and a special type 

The expression in Coq mainly consists of identifiers, function applications and $\lambda-$abstractions.  
Since in the Coq code of this paper only identifiers and function applications are involved, we omit the introduction to $\lambda-$abstractions. 
Identifiers are simple names declared in Coq. 
For example, %the identifiers \setsf{x}, \setsf{f}, \setsf{e}, \setsf{p}, \setsf{r}, \setsf{o} are declared in Table~\ref{table:The definition of program p2 in Coq} below. 
%the statement \setsf{Definition x : nat := 1} declares a local identifier \setsf{x} as integer $1$. 
we can declare an identifier \setsf{x} to express the integer number $1$ (see \Sect~\ref{section:Some Commands in Coq} below). 
In Coq, the identifiers \setsf{0}, \setsf{1}, \setsf{2}, ... are predefined to represent natural numbers $0, 1, 2, ...$. 
%The non-negative numbers \setsf{0}, \setsf{1}, \setsf{2}, ... are also identifiers predefined in Coq. 
Function applications has the form: \setsf{func a}, where parameter \setsf{a} is applied to function \setsf{func}. 
The application is left associative, so term \setsf{func a b c} is read as \setsf{((func a) b) c}. 
For example, we can have a function \setsf{add 1 2} to express the addition of two numbers $1$ and $2$. 
%If \setsf{a : A} and \setsf{func : A $->$ B}, then \setsf{(func a) : B}. 
%Abstraction is a notation for functions that are originally used in the $\lambda-$calculus in the form: $\lambda x. e$. 
%We omit its explanation here. 
%An abstraction has the form: \setsf{fun (x1 : T1) ... (xn : Tn) $=>$ t}, where \setsf{fun} is a keyword, \setsf{x1},...,\setsf{xn} are the parameters of the function, 
%\setsf{t} is the body of the function. 	

In Coq, every term has a unique type. 
We use \setsf{t : A} to represent that a term \setsf{t} has a type \setsf{A}. 
A \emph{simple type} can be an \emph{atomic type}, or an \emph{arrow type} of the form \setsf{A $\arw$ B}, where \setsf{A} and \setsf{B} are simple types. 
Atomic types are made of single identifiers, such as \setsf{nat} and \setsf{Prop} as explained below in \Sect~\ref{section:Type nat and Prop}. 
\setsf{nat $\arw$ nat} and \setsf{nat $\arw$ Prop} are simple types.  
Arrow types are needed when we perform function application. For example, if \setsf{a : A} and \setsf{func : A $\arw$ B}, then we have \setsf{(func a) : B}. 

In Coq, we also consider a more general type, called \emph{dependent type}, of the form \setsf{forall (x : A), t}, where \setsf{t : B}, \setsf{A} and \setsf{B} are simple or dependent types. 
It means that for all \setsf{x} of the type \setsf{A}, \setsf{t} has the type \setsf{B}. 
\setsf{t} is an arbitrary term in which \setsf{x} might or might not appear. 
For example, \setsf{forall (x : nat), (x = 2) $\arw$ (x $>$ 1)} is a dependent type in Coq, where \setsf{(x = 2) $\arw$ (x $>$ 1)} has the type \setsf{Prop}. 
If \setsf{x} does not appear in \setsf{t}, then the type \setsf{A} and \setsf{B} are independent and \setsf{forall (x : A), t} is equivalent to \setsf{A $\arw$ B}. 


\ifx
a \emph{simple type} is constructed based on \emph{atomic types} through the arrow `$->$', formally, 
\begin{enumerate}[label=(\arabic*)]
	\item any atomic types are simple types, and
	\item if \setsf{A} and \setsf{B} are simple types, then \setsf{A $->$ B} is a simple type. 
\end{enumerate}
The atomic types are made of single identifiers, such as \setsf{nat} and \setsf{Prop}, as explained below in Sect.~\ref{section:Type nat and Prop}. 
%which are also predefined types in Coq. 
%\setsf{nat} represents the set of non-negative integer numbers $\{0,1,2,...\}$, while
%\setsf{Prop} means the set of all predicates in Coq. 
In Coq, every term must have a type, but can only have one type.  
`A term \setsf{t} has type \setsf{A}' is denoted by \setsf{t : A}. 
Except for the simple type, in Coq there is a more general type called `\emph{dependent type}', which is constructed through the expression of the form `\setsf{forall ..., ...}': 
\begin{center}
	if \setsf{A} and \setsf{B} are types, then \setsf{forall (x : A), t} (where \setsf{t : B}) is a dependent type. 
\end{center}
\setsf{forall (x : A), t(x)} means that for all \setsf{x} of the type \setsf{A}, \setsf{t} has the type \setsf{B}. 
\setsf{t} is an arbitrary term in which \setsf{x} might or might not appear. 
\fi

%Dependent type is more general and can subsume the arrow type. An arrow type \setsf{A $->$ B} is in fact a dependent type \setsf{forall (x : A), B} when \setsf{x} 



\subsubsection{Types \setsf{nat} and \setsf{Prop}}
\label{section:Type nat and Prop}
\setsf{nat} and \setsf{Prop} are predefined types in Coq.  

The type \setsf{nat} represents the set of natural numbers $\{0,1,2,...\}$. 
We often use identifiers \setsf{0}, \setsf{1}, \setsf{2}, ... to express the elements of \setsf{nat}. 
The arithmetic operators, such as the addition (\setsf{$+$}), the substitution (\setsf{$-$}) and the multiplication (\setsf{$*$}), and the relations, such as 
less-than relation (\setsf{$<$}), less-than-or-equal-to relation (\setsf{$<=$}) and equal-to relation (\setsf{$=$}) are predefined
as functions  in Coq. 
For example, in Coq we can have terms \setsf{1 + 2}, \setsf{2 $*$ x} and \setsf{1 $<$ 2}. 


The type \setsf{Prop} represents the set of all propositions in Coq. 
Propositions can be expressed by a higher-order logic with logical connectives such as negation ($\sim$), 
conjunction ($/\backslash$), disjunction ($\backslash /$), implication ($\arw$), 
universal quantifier (\setsf{forall}) and existential quantifier (\setsf{exists}). 
For example, we can have a proposition \setsf{forall (x : nat), (x = 2) $\arw$ (x $>$ 1)} in Coq, where \setsf{x = 2} and \setsf{x $>$ 1} are two propositions of the type \setsf{Prop}. 
Note that the universal quantifier \setsf{forall} and the implication $\arw$ are just the same symbols for constructing arrow types and dependent types introduced above. 

\ifx
In Coq, propositions are defined as dependent types. 
The implication $->$ and the universal quantifier \setsf{forall} are just the symbols for constructing the arrow types and dependent types. 
Therefore, whenever we consider a term of the type \setsf{Prop}, we also consider a proposition. 
For example, the proposition \setsf{forall (x : nat), 1 $<$ 2 $/\backslash$ x = 5} is also a dependent type as discussed in Sect.~\ref{section:The language of Coq}. 
\fi

\subsection{Proof and Proof Tactics}
\label{section:Proof and Proof Tactics}

In Coq, theorem proving and type inference are the same thing. 
Propositions are expressed as dependent types. 
For example, the dependent type \setsf{forall (x : nat), (x = 2) $\arw$ (x $>$ 1)} in \Sect~\ref{section:The language of Coq} are also a proposition as indicated in \Sect~\ref{section:Type nat and Prop}.
Given a type \setsf{T : Prop}, which is also a proposition, the process of proving \setsf{T} is in fact the process of finding an instance \setsf{a} such that \setsf{a : T} by applying type inference rules. 
\setsf{a} is also called a proof of the proposition \setsf{T}. 
When \setsf{a : T} is declared in Coq by the command \setsf{Definition} or \setsf{Inductive} (discussed below in \Sect~\ref{section:Some Commands in Coq}), 
\setsf{a} is also called an \emph{axiom}. 
We use the command \setsf{Theorem} to define a proposition to be proved, in the form \setsf{Theorem p : t}, where \setsf{p} is the name of the theorem, \setsf{t} has the type \setsf{Prop}.
For example, \setsf{Theorem Reflexivity : forall (x : nat), x = x}. 

The process of proving a proposition can be implemented in Coq by using proof tactics. 
Different tactics correspond to using different type inference rules and proof strategies.
Tactic \setsf{apply} is a basic tactic. Given an axiom \setsf{a : A $\arw$ B}, if we want to prove the proposition \setsf{B}, by applying the command \setsf{apply a} we only need to prove the proposition \setsf{A}. 
Tactic \setsf{split} is for eliminating the conjunction connective $/\backslash$. 
If we want to prove a proposition \setsf{A $/\backslash$ B}, by applying the command \setsf{split} we only need to prove the propositions \setsf{A} and \setsf{B}. 
Tactic \setsf{intros N} is for eliminating the universal quantifier \setsf{forall}. 
If we want to prove a proposition \setsf{forall (x : T), t}, by applying the command \setsf{intros a}, we obtain a new identifier \setsf{a : T} and only need to prove the proposition \setsf{t[a/x]}. 
Here \setsf{t[a/x]} means the term obtained by the substitution of \setsf{x} by \setsf{a}. 
Tactic \setsf{omega} is for automatically solving a Presburger arithmetic formula. 




\subsubsection{Commands \setsf{Definition}, \setsf{Inductive} and type \setsf{list}}
\label{section:Some Commands in Coq}

In Coq, to declare an identifier in the local environment we can use the command \setsf{Definition}. 
We can write \setsf{Definition (x : A) := t} to declare an identifier \setsf{x} as a term \setsf{t} of type \setsf{A}.
For example, \setsf{Definition (x : nat) := 1} declares an identifier \setsf{x} as the integer number \setsf{1}. 

In Coq, a type can be inductively defined with the command \setsf{Inductive}. 
%We often call the inductively defined type as `inductive type'. 
%With this command, we define a type by showing how its elements can be constructed in an inductive way.
The general form of this command is: 
\begin{center}
$\begin{aligned}
\mbox{\setsf{Inductive}} &\mbox{\setsf{ T (x1 : T1) ... (xn : Tn) : O := }}\\
&\mbox{\setsf{$|$ C1 : t1}}\\
&\mbox{...}\\
&\mbox{\setsf{$|$ Cm : tm.}}
\end{aligned}$
\ \ or\ \ 
$\begin{aligned}
\mbox{\setsf{Inductive}} &\mbox{\setsf{ T : T1 $\arw$ ... $\arw$ Tn $\arw$ O := }}\\
&\mbox{\setsf{$|$ C1 : t1}}\\
&\mbox{...}\\
&\mbox{\setsf{$|$ Cm : tm.}}
\end{aligned}$
\end{center}
where \setsf{T} is the type to be defined, its type is \setsf{T1 $\arw$ ... $\arw$ Tn $\arw$ O}. 
\setsf{C1}, ..., \setsf{Cm} are the \emph{constructors} of the type \setsf{T}, while \setsf{t1}, ..., \setsf{tm} are their types.  
The constructors tell how the type can be constructed in an inductive way. 

For example, the type \setsf{nat} can be defined as Fig.~\ref{figure:Examples of inductive types} (a), 	where the type of \setsf{nat} is the type \setsf{Set}. 
The definition says that 
\rmn{1} the number \setsf{0} has the type \setsf{nat}, and 
\rmn{2} if any number \setsf{n} has the type \setsf{nat}, then \setsf{S n} has the type \setsf{nat}. 
\ifx
It means that the \setsf{nat} is defined inductively as follows:
\begin{enumerate}[label=(\roman*)]
	\item The identifier \setsf{0} is an element of \setsf{nat}. 
	\item If any \setsf{n} is an element of \setsf{nat}, then \setsf{S n} is an element of \setsf{nat}. 
\end{enumerate}
\fi

\begin{figure}[htpb]
	\begin{center}
		\scalebox{0.8}{
	\begin{tabular}{c c c}
	$\begin{aligned}
	\mbox{\setsf{Inductive}} &\mbox{\setsf{ nat : Set := }}\\
	&\mbox{\setsf{$|$ 0 : nat}}\\
	&\mbox{\setsf{$|$ S : nat $\arw$ nat.}}
	\end{aligned}$
	&
	$\begin{aligned}
	\mbox{\setsf{Inductive}} &\mbox{\setsf{ list (A : Type) : Set := }}\\
	&\mbox{\setsf{$|$ nil : list A}}\\
	&\mbox{\setsf{$|$ cons : A $\arw$ list A $\arw$ list A.}}
	\end{aligned}$
	&
	$\begin{aligned}
	\mbox{\setsf{Inductive}} &\mbox{\setsf{ ev : nat $\arw$ Prop := }}\\
	&\mbox{\setsf{$|$ ev\_0 : ev 0}}\\
	&\mbox{\setsf{$|$ ev\_SS : forall (n : nat), (ev n) $\arw$ (ev (n + 2)).}}
	\end{aligned}$	
	\\
	\\
	(a)
	&
	(b)
	& 
	(c)\\
	\end{tabular}
}%end scalebox
	\end{center}
\captionsetup{font=footnotesize}
\caption{\footnotesize{Examples of inductive types}}
\label{figure:Examples of inductive types}
\end{figure}

%With the command \setsf{Inductive} one can even define more complex types, i.e., the types whose type is an arrow type. 

Another example is the type \setsf{list} (shown as  Fig.~\ref{figure:Examples of inductive types} (b)), whose type is the arrow type \setsf{Type $\arw$ Set}. 
The type \setsf{list} is a \emph{polymorphic type}, it receives a parameter \setsf{A} of the type \setsf{Type} and returns a type \setsf{list A}. 
The definition of the type \setsf{list} says that given any \setsf{A} of the type \setsf{Type}, the type \setsf{list A} can be defined by the constructors \setsf{nil} and \setsf{cons} in the following way: \rmn{1} the empty list \setsf{nil} has the type \setsf{list A}; \rmn{2} given any element \setsf{a} of the type \setsf{A} and a list \setsf{l}, then \setsf{cons a l} is a list of the type \setsf{list A}. 
In Coq, we often use the notation \setsf{a1 :: a2 :: ... :: an :: nil} to express a list \setsf{cons a1 (cons a2 ( ... (cons an nil)))}. 

With the command \setsf{Inductive} one can also define a predicate of the type \setsf{T1 $\arw$ ... $\arw$ ... Tn $\arw$ Prop}. 
When defining a predicate, the constructors \setsf{C1}, ..., \setsf{Cm} of the types \setsf{t1}, ..., \setsf{tm} can also be understood as axioms according to \Sect~\ref{section:Proof and Proof Tactics}. 
Fig.~\ref{figure:Examples of inductive types} (c) shows an example, where we define a predicate \setsf{ev : nat $\arw$ Prop} in an inductive way: 
\rmn{1} \setsf{ev 0} holds, and \rmn{2} if \setsf{ev n} holds for any \setsf{n : nat}, then \setsf{ev (n + 2)} holds. 
Here \setsf{ev\_0} and \setsf{ev\_SS} are two axioms. 
The proposition \setsf{ev n} describes that $n$ is an even number. 








\subsection{The Mechanization of \SeqCDL\ in Coq}

Our mechanization consists of two steps: 
(1) first we define the syntax of \SeqCDL\ in Coq; 
(2) then we define the proof system of \SeqCDL\ in Coq. 

The main idea behind the mechanization is that:
each expression in \SeqCDL\ is defined as an inductive type (introduced in \Sect~\ref{section:Some Commands in Coq}); 
the whole proof system of \SeqCDL\ is constructed through defining sequent as a predicate type, where each constructor corresponds to a rule of the proof system. 



\subsubsection{The Syntax of \SeqCDL\ in Coq}
From the discussion above in \Sect~\ref{section:Mechanization of CDL in Coq}, we know that in SCDL formulae no parallel SEPs are considered. Therefore we consider a subset of SEPs where no parallel operators appear, we call them \emph{pure sequential SEPs} (\psSEP s). Since there is no parallel operators in \psSEP s, 
we neither need to consider the signal test condition $\varrho$ because it can only appear in a parallel program according to Def.~\ref{definition: Synchronous Event Program}. 
The syntax of \psSEP s is defined just as Def.~\ref{definition: Synchronous Event Program} but with `$\varrho\& P?\alpha$' replaced by `$P ? \alpha$' and with `$\paral(p_1,...,p_n)$' being removed. 


\begin{table}[htpb]
	\begin{center}
\begin{minipage}[htp]{0.99\textwidth}
\begin{tabularlstlisting}[multicols=3, frame=tlrb, numbers=left]
(* variable name*)
Inductive Var := var : nat -> Var.

(* expression e *)
Inductive e_exp := 
	enumC : nat -> e_exp | 
	evarC : Var -> e_exp | 
	eplusC : e_exp -> e_exp -> e_exp |
	eminusC : e_exp -> e_exp -> e_exp |
	emulC : e_exp -> e_exp -> e_exp |
	edivC : e_exp -> e_exp -> e_exp.

(* condition P *)
Inductive P_exp := 
	PtrueC : P_exp |
	PlteC : e_exp -> e_exp -> P_exp |
	PnegC : P_exp -> P_exp |
	PandC : P_exp -> P_exp -> P_exp |
	(*unnecesarry expression*)
	PfalseC : P_exp |
	PltC : e_exp -> e_exp -> P_exp |
	PgtC : e_exp -> e_exp -> P_exp |
	PgteC : e_exp -> e_exp -> P_exp |
	PeqC : e_exp -> e_exp -> P_exp |
	PorC : P_exp -> P_exp -> P_exp |
	PimpC : P_exp -> P_exp -> P_exp.

(* event element *)
Inductive EvtElement := 
	sigC : Var -> e_exp -> EvtElement |
	assC : Var -> e_exp -> EvtElement.

(* event *)
Definition Evt := list EvtElement.

(* syntax of SEP *)
Inductive SEP_exp : Type := 
	skip : SEP_exp | 
	evtC : Evt -> SEP_exp | 
	tstC : P_exp -> Evt -> SEP_exp | 
	seqC : SEP_exp -> SEP_exp -> SEP_exp | 
	choC : SEP_exp -> SEP_exp -> SEP_exp | 
	loopC : SEP_exp -> SEP_exp.

(* idle event *)
Definition idle : Evt := nil.
\end{tabularlstlisting}
\end{minipage}
\end{center}
%\vspace{0.25cm}
\begin{center}
	\noindent\makebox[\textwidth]{
\scalebox{0.8}{
	\begin{tabular}{| c | c | c || c | c | c |}
		\toprule
		Term & Notation in Coq & Meaning in SCDL & 
		Term & Notation in Coq & Meaning in SCDL \\
		\hline
		\setsf{var n} & \setsf{x}, \setsf{y}, \setsf{z}, \setsf{c},... & names $x,y,z,c$... & 
		\setsf{enumC n} & \setsf{n} & integer $n$ in $e$ \\
		\hline
		\setsf{evarC v} & \setsf{v} & a variable in $e$ & 
		\setsf{eplusC e1 e2} & \setsf{e1 '$+$ e2} & expression $e_1 + e_2$ in $e$  \\
		\hline
		\setsf{PtrueC} & \setsf{'tt} & formula $\mathit{tt}$ in $P$ &
		\setsf{PlteC e1 e2} & \setsf{e1 '$<=$ e2} & expression $e_1 \le e_2$ in $e$ \\
		\hline
		\setsf{PnegC P} & \setsf{'$\sim$ P} & formula $\neg P$ in $P$ &
		\setsf{PandC P1 P2} & \setsf{P1 '$/\backslash$ P2} & formula $P_1 \wedge P_2$ in $P$\\
		\hline
		\setsf{sigC s e} & \setsf{s ! e} & signal $\sig ! e$ & 
		\setsf{assC x e} & \setsf{x :=' e} & assignment $x := e$ \\
		\hline
		\setsf{skip} & & skip program $\mu$ & 
		\setsf{evtC (b1 :: ... :: bn :: nil)} & \setsf{@$\{$b1 $|$ ... $|$ bn$\}$} & combinational event $\{\mathit{Cmb}_1,...,\mathit{Cmb}_n\}$ \\
		\hline
		\setsf{tstC P a} & \setsf{P ? a} & test event $P?a$ &
		\setsf{seqC p1 p2} & \setsf{p1 ; p2} & program $p_1 ; p_2$\\
		\hline
		\setsf{choC p1 p2} & \setsf{p1 U p2} & program $p_1\cup p_2$ &
		\setsf{loopC p} & \setsf{p **} & program $p^\lup$\\
		\bottomrule
	\end{tabular}
}%end scalebox
}%end makebox
\end{center}
\captionsetup{font=footnotesize}
\caption{\footnotesize{The definition of the syntax of \psSEP s in Coq}}
\label{table:The definition of the syntax of SEP in Coq}
\end{table}

Table~\ref{table:The definition of the syntax of SEP in Coq} shows the definition of the syntax of \psSEP s in Coq. 
It is defined as an inductive type \setsf{SEP\_exp}~\footnote{For the convenience of extending our programs in the future, we still name \psSEP\ as `SEP' in our Coq code.  } (line 37) in the Coq code. 
The syntax of other components of \psSEP s, 
i.e., the expression $e$, the condition $P$ and the combinational event $\alpha$, are defined as inductive types \setsf{e\_exp} (line 5), \setsf{P\_exp} (line 14) and \setsf{Evt} (line 34) respectively. 
The diagram in the below of Table~\ref{table:The definition of the syntax of SEP in Coq} gives the correspondences between the constructors of these inductive types in Coq and their meanings in SCDL. For most constructors we define notations to improve their readabilities, in forms as close as possible to the forms of their correspondences in SCDL. 
%We define these notations in forms as close as possible to the forms of the correspondences of  

%As indicated in Table~\ref{table:The definition of the syntax of SEP in Coq}, 
As indicated in Table~\ref{table:The definition of the syntax of SEP in Coq}, 
the set of all general variable names and all clock names in SCDL are defined as the inductive type \setsf{Var} in Coq, 
whose elements are constructed by the constructor \setsf{var} with natural numbers (\setsf{nat}). 
For simplicity, currently we do not distinguish general variable names and clock names in the Coq code.  
One advantage of using natural numbers instead of using strings to define names is that it becomes much easier to generate new names. 
%By default, in Coq we use notations \setsf{x}, \setsf{y}, \setsf{z} and \setsf{c} as 
By default, in Coq we use notations \setsf{x}, \setsf{y}, \setsf{z} and \setsf{k} as shorthands for terms \setsf{var 1}, \setsf{var 2}, \setsf{var 3} and \setsf{var 4} respectively. 
They denote the general variable names $x$, $y$, $z$, $k$ in SCDL respectively. 
We use notations \setsf{c}, \setsf{d}, \setsf{c1} - \setsf{c4} as shorthand for terms \setsf{var 5}, \setsf{var 6}, \setsf{var 7} - \setsf{var 10} respectively. 
They denote the clock names $c$, $d$, $c_1$ - $c_4$ in SCDL respectively. 
For simplicity we also do not distinguish clock names and signal names and consider that they are the same thing in the Coq code. Actually, due to Def.~\ref{definition: Clock History,  Clock Ticking} we assume there is always a bijection $\SigMap$ between them. 

In the type \setsf{e\_exp}, terms \setsf{enumC n} and \setsf{evarC v} express a number $n$ and a variable in the expression $e$ respectively. 
They can be simply written as \setsf{n} and \setsf{v} in Coq respectively. 
For example, term \setsf{evarC (var 1)} expresses the variable $x$ in $e$, it can be simply written as \setsf{x} in Coq, where \setsf{x} is a shorthand of variable \setsf{var 1}
as discussed above. 

\ifx
In the diagram of Table~\ref{table:The definition of the syntax of SEP in Coq} we omit the explanations for constructors \setsf{eminusC}, \setsf{emulC} and \setsf{edivC} in \setsf{e\_exp} and all constructors for unnecessary expressions in \setsf{P\_exp}, such as \setsf{PfalseC}, \setsf{PltC}, etc. 
Readers can refer to ... for more details. 
\fi

In the inductive type \setsf{P\_exp}, for convenience of expressing we also define the constructors for unnecessary expressions (such as false $\mathit{ff}$, the less-than expression $e_1\le e_2$, etc) (lines 20 - 26) which can be expressed by the expressions in $P$ defined in Def.~\ref{definition: Synchronous Event Program}. 
In the diagram of Table~\ref{table:The definition of the syntax of SEP in Coq} we omit the explanations for their constructors (such as \setsf{PfalseC}, \setsf{PltC}, etc). 
We also omit the explanations for the constructors \setsf{eminusC}, \setsf{emulC} and \setsf{edivC} in \setsf{e\_exp} (lines 9 - 11). 
%Readers can refer to \url{https://github.com/antitaboo/CDL} for more details. 
%For the notations of some terms such as \setsf{'+}, \setsf{'$<=$} and \setsf{'$/\backslash$}, we add a small prime `\setsf{'}' in front of or at the back of the symbols in order to distinguish them from the default notations in Coq. 

In the inductive type \setsf{Evt}, the type \setsf{list} is defined in \Sect~\ref{section:Some Commands in Coq}. 

	

\begin{table}[h]
	\begin{center}
		\begin{minipage}[htp]{1.0\textwidth}
			\begin{tabularlstlisting}[multicols=3, frame=tlrb, numbers=left]
(* CCSL clock relation *)
Inductive CRel := 
	crSubClC : Var -> Var -> CRel |
	crExclC : Var -> Var -> CRel |
	crPrecC : Var -> Var -> CRel |
	crCausC : Var -> Var -> CRel.
	
(* clock-relation term in SCDL formulae *)
Inductive rel := 
	rRelC : CRel -> rel |
	rConjC : list CRel -> rel.

(* expression E *)	
Inductive E_exp :=
	EvarC : Var -> E_exp |
	ECntClkC : Var -> E_exp |
	EStClkC : Var -> E_exp |
	EnumC : nat -> E_exp |
	EplusC : E_exp -> E_exp -> E_exp |
	(* unecessary expression *)
	EmulC : E_exp -> E_exp -> E_exp |
	EminusC : E_exp -> E_exp -> E_exp |
	EdivC : E_exp -> E_exp -> E_exp.
	
(* syntax of SCDL formula *)
Inductive CDL_exp := 
	cdl_trueC : CDL_exp |
	cdl_lteC : E_exp -> E_exp -> CDL_exp |
	cdl_box1C : SEP_exp -> rel -> CDL_exp |
	cdl_box2C : SEP_exp -> CDL_exp -> CDL_exp |
	cdl_negC : CDL_exp -> CDL_exp |
	cdl_andC : CDL_exp -> CDL_exp -> CDL_exp |
	cdl_forallC : Var -> CDL_exp -> CDL_exp |
	(*unnecessary expressions*)
	cdl_falseC : CDL_exp |
	cdl_ltC : E_exp -> E_exp -> CDL_exp |
	cdl_gtC : E_exp -> E_exp -> CDL_exp |
	cdl_gteC : E_exp -> E_exp -> CDL_exp |
	cdl_eqC : E_exp -> E_exp -> CDL_exp |
	cdl_dia1C : SEP_exp -> rel -> CDL_exp |
	cdl_dia2C : SEP_exp -> CDL_exp -> CDL_exp |
	cdl_orC : CDL_exp -> CDL_exp -> CDL_exp |
	cdl_impC : CDL_exp -> CDL_exp -> CDL_exp |
	cdl_existsC : Var -> CDL_exp -> CDL_exp.
			\end{tabularlstlisting}
		\end{minipage}
	\end{center}
	%\vspace{0.25cm}
	\begin{center}
		\noindent\makebox[\textwidth]{
		\scalebox{0.8}{
			\begin{tabular}{| c | c | c || c | c | c |}
				\toprule
				Symbol & Notation in Coq & Meaning in SCDL & 
				Symbol & Notation in Coq & Meaning in SCDL \\
				\hline
				\setsf{crSubClC c1 c2} & \setsf{c1 sub c2} & clock relation $c_1\subseteq c_2$ & 
				\setsf{crExclC c1 c2} & \setsf{c1 \# c2} & clock relation $c_1 \ssharp c_2$ \\
				\hline
				\setsf{crPrecC c1 c2} & \setsf{c1 $<<$ c2} & clock relation $c_1\prec c_2$ & 
				\setsf{crCausC c1 c2} & \setsf{e1 $<<=$ e2} & clock relation $e_1\preceq e_2$ \\
				\hline
				\setsf{rRelC r} & \setsf{r} & a clock relation in formulae &
				\setsf{rConjC (r1 :: ... :: rn :: nil)} & \setsf{$/\backslash \{$r1,...,rn$\}$}  & term $\curlywedge(\RRel_1,...,\RRel_n)$ \\
				\hline
				\setsf{EvarC v} & \setsf{v} & a variable in $E$ &
				\setsf{ECntClkC c} & \setsf{n(c)} & variable $c^n$ in $E$\\
				\hline
				\setsf{EStClkC c} & \setsf{s(c)} & variable $c^s$ in $E$ & 
				\setsf{EnumC n} & \setsf{n} & integer $n$ in $E$ \\
				\hline
				\setsf{EplusC e1 e2} & \setsf{e1 $+$' e2} & expression $e_1 + e_2$ in $E$ & 
				\setsf{cdl\_trueC} & \setsf{tt'} & true $tt$ in $E$ \\
				\hline
				\setsf{cdl\_lteC e1 e2} & \setsf{e1 $<=$' e2} & expression $e_1 \le e_2$ in $E$ &
				\setsf{cdl\_box1C p rel} & \setsf{[[ p ]]' rel} & formula $[p]\Rel$\\
				\hline
				\setsf{cdl\_box2C p phi} & \setsf{[[ p ]] phi} & formula $[p]\phi$ &
				\setsf{cdl\_negC phi} & \setsf{$\sim$' phi} & formula $\neg \phi$ \\
				\hline
				\setsf{cdl\_andC phi1 phi2} & \setsf{phi1 $/\backslash$' phi2} & formula $\phi_1 \wedge \phi_2$ &
				\setsf{cdl\_forallC x phi} & \setsf{all x, e} & formula $\forall x. \phi$ \\
				\bottomrule
			\end{tabular}
		}%end scalebox
	}%end makebox
	\end{center}
	\captionsetup{font=footnotesize}
	\caption{\footnotesize{The definition of the syntax of SCDL formulae in Coq}}
	\label{table:The definition of the syntax of SCDL formulae in Coq}
\end{table}


Table~\ref{table:The definition of the syntax of SCDL formulae in Coq} shows the definition of the syntax of SCDL formulae in Coq. 
It is defined as the inductive type \setsf{CDL\_exp} (line 26). 
The other components of SCDL formulae, i.e., the CCSL clock relation $\RRel$, the clock-relation term $\Rel$ and the expression $E$ are defined as 
the inductive types \setsf{CRel} (line 2), \setsf{rel} (line 9) and \setsf{E\_exp} (line 14) respectively. 
The diagram in the below of Table~\ref{table:The definition of the syntax of SCDL formulae in Coq} gives 
the notations of the constructors of these types and their explanations in SCDL. 
For the same reason mentioned above, we also define the constructors for unnecessary expressions in types \setsf{E\_exp} (lines 21 - 23) and \setsf{CDL\_exp} (lines 35 - 44), 
and their explanations are omitted in the diagram of Table~\ref{table:The definition of the syntax of SCDL formulae in Coq}. 
%For the same reason discussed above, we add a small prime `\setsf{'}' in front of or at the back of some symbols  

In the type \setsf{rel}, term \setsf{rRelC r} expresses a clock relation in the expression $E$. 
They can be simply written as \setsf{r} in Coq, similar explanations can be made for term \setsf{EvarC v} and term \setsf{EnumC n} in the type \setsf{E\_exp}. 
For example, term \setsf{rRelC (c1 sub c2)} expresses the relation $c_1\subseteq c_2$ in the expression $E$, it can be simply written as \setsf{c1 sub c2} in Coq.  
The type \setsf{list} is defined in \Sect~\ref{section:Some Commands in Coq}. 

Note that in the Coq code, the constructors of the arithmetic operators (e.g., $+$, $\cdot$, etc) and relations (e.g., $\le$, $<$, etc) in the expression $E$ and the constructors of the logical terms (i.e., $tt$ and $\ff$) and connectives (e.g., $\neg$, $\wedge$, etc) in SCDL formulae are different from those in the expression $e$ and the condition $P$, though we use the same syntactic symbols 
to express them in Def.~\ref{definition: Synchronous Event Program} and \ref{definition: CDL Formula}.  
In Coq, their notations differ from each other according to the positions of the prime symbol `\setsf{'}'. For example, in $e$ the plus operator is expressed as `\setsf{'+}'  in Coq, while in $E$, the plus operator is expressed as `\setsf{+'}'.  

\begin{table}[htpb]
	\begin{center}
		\begin{minipage}[htp]{1.0\textwidth}
			\begin{tabularlstlisting}[multicols=2, frame=tlrb, numbers=left]
(* a small example *)
(* general variables x, f*)
Definition f : Var := (var 11).
Definition Y : Var := (var 12).

(* clock *)
Definition e : Var := (var 13).
Definition p : Var := (var 14).
Definition r : Var := (var 15).
Definition o : Var := (var 16).

(* program p2 *)
Definition P1 : P_exp := (x '= 2) '/\ (f '= 0).
Definition P2 : P_exp := (x '< 2) '/\ (f '= 0).

Definition a2 : Evt := { p ! 0 | f :=' 1 }.
Definition a3 : Evt := { p ! 0 | x :=' x '+ 1 }.

Definition p2 : SEP_exp := P1 ? a2 U P2 ? a3.
			\end{tabularlstlisting}
		\end{minipage}
	\end{center}

	\begin{center}
		\noindent\makebox[\textwidth]{
			\scalebox{0.8}{
				\begin{tabular}{| c | c || c | c || c | c |}
					\toprule
					Term in Coq& Meaning in SCDL & 
					Term in Coq & Meaning in SCDL&
					Term in Coq & Meaning in SCDL\\
					\hline
					\setsf{f} & variable $f$ &
					\setsf{Y} & variable $(c^n_r)'$ & 
					\setsf{e} & clock $c_e$ \\
					\hline
					\setsf{p} & clock $c_p$/signal $\sig_p$&
					\setsf{r} & clock $c_r$/signal $\sig_r$ &
					\setsf{o} & clock $c_o$signal $\sig_o$\\
					\bottomrule
				\end{tabular}
			}%end scalebox
		}%end makebox
	\end{center}
	\captionsetup{font=footnotesize}
	\caption{\footnotesize{The definition of program $p_2$ in Coq}}
	\label{table:The definition of program p2 in Coq}
\end{table}

\begin{example}
	We consider the formula $[p_2] c_r\prec c_o$ in the sequent of the node $\circled{13}$ of the deduction procedure of $I\to [\DF]c_r\prec c_o$ (Fig.~\ref{figure:The deduction of CDL2}). 
	The program $p_2$ can be defined in the Coq code shown in Table~\ref{table:The definition of program p2 in Coq}, 
	where the meaning of each variable term is explained in the diagram below. 
	As discussed above, 
	the name \setsf{x} is defined as $var 1$. 
	Note that as mentioned above, a clock and its corresponding signal can be expressed with the same name. 
	The program $p_2$ is defined as the term \setsf{p2} (line 19). 
	
		
	With the program \setsf{p2}, the formula $[p_2] c_r\prec c_o$ can be described as a \setsf{CDL\_exp} expression:
	\begin{center}\setsf{[[ p2 ]]' r $<<$ o}.\end{center}
	
\end{example}

\subsubsection{The Proof System of SCDL\ in Coq}
\label{section:The Proof System of SCDL in Coq}

The proof system of CDL proposed in \Sect~\ref{section: The Proof System of CDL} is based on the sequent of the form $\Gamma\Rightarrow \Delta$ (defined in \Sect~\ref{section:Sequent Calculus}). 
However, such an argumentation is not suitable for making deductions in Coq because it is highly non-deterministic: each time any formula in the sets $\Gamma$ and $\Delta$ can be chosen as 
a target formula according to which rule is chosen to be applied. 
To solve this problem we make two augmentations when we implement sequent in Coq: 
	\begin{enumerate}[label=(\arabic*)]
		\item We define the multi-sets $\Gamma$ and $\Delta$ as ordered lists, instead of sets. In this way we can determine which formula will be dealt with next, rather than 
		non-deterministically choosing one. 
		\item We introduce the notion of \emph{target place} in the sequent. A target place can either be empty or store a formula that should be focused in the current sequent. 
		To support this new feature we need to introduce new proof rules in the proof system of SCDL for removing the current formula from the place and adding the next formula to the place. 
	\end{enumerate}
Besides (1) and (2) above, in order to make the form of the proof rules in Coq as simple as possible, for each sequent we also keep the information about the current set of variable names and clock names, the set of all clocks and the set of all clocks that do not tick at the current instant. 

Based on the above discussion, 
formally,  a sequent can be defined in Coq as a structure:
$$\Gamma , \tplace_1 \Rightarrow \tplace_2, \Delta\ \doubleslash\ \Names, C, \ntC, $$
where $\Gamma , \tplace_1 \Rightarrow \tplace_2, \Delta$ is a sequent (defined in Def.~\ref{section:Sequent Calculus}) with two sets $\tplace_1$ and $\tplace_2$ called `target places' on both of its sides.
%$\tplace_1, \tplace_2$ are two target places on both sides of the sequent, 
$\tplace_1$ and $\tplace_2$ can contain at most one formula. 
%The sequent $\Gamma , \tplace_1 \Rightarrow \tplace_2, \Delta$ just means the same thing as 
$\Names, C, \ntC$ provide auxiliary information about a sequent, %which play a role in building the proof rule in Coq. 
they are separated from a sequent with a symbol $\doubleslash$. 
$\Names$ represents the current set of variable names and clock names, $C$ represents the set of all clocks and $\ntC$ represents the set of all clocks that do not tick at the current instant.
%All the sets $\Gamma, \Delta, V, C, \ntC$ can be implemented as lists in Coq. 
%They provide auxiliary information 

Appendix~\ref{section:A Part of Code for the Definition of the Sequent in Coq} lists a part of code for the definition of the proof system of SCDL in Coq. 
The sets $\Gamma$ and $\Delta$ are defined as two lists with the type \setsf{list Var} (i.e., the types \setsf{Gamma} and \setsf{Delta} at lines 3 - 4) in Coq. 
Target places are defined as the inductive type \setsf{place} (line 7). 
A target place can be either empty (expressed by the term \setsf{empty}) or can be a CDL formula \setsf{phi} (expressed by the term \setsf{exp phi}). 
	
In Coq, a sequent is defined as a predicate (line 15):
$$\mbox{\setsf{Seq : Gamma $\arw$ place $\arw$ place $\arw$ Delta $\arw$ (list Var) $->$ (list Var) $\arw$ (list Var) $\arw$ Prop}}. $$
Each sequent \setsf{Seq T p1 p2 D V C ntC} is a proposition of the type \setsf{Prop}, where 
\setsf{T}, \setsf{p1}, \setsf{p2}, \setsf{D}, \setsf{V}, \setsf{C}, \setsf{ntC} represent components $\Gamma$, $\tplace_1$, $\tplace_2$, $\Delta$, $\Names$, $C$, $\ntC$ respectively. 
As indicated in \Sect~\ref{section:Some Commands in Coq}, 
the sequent is defined in an inductive way by its constructors --- as the axioms that capture the proof rules of SCDL in Coq. 
In another word, we define a sequent according to whether it can be proved by these axioms in an inductive way. 
%The rules of the proof system are exactly expressed by the types of the constructors of \setsf{Seq}. 
Once we have defined the sequent, we finish constructing the proof system of SCDL. 

\ifx
By defining the sequent, we in fact define a proof system for SCDL, where a given term \setsf{Seq T p1 p2 D V C ntC} can be proved iff we can construct a proof by applying the rules of the proof system. 

All rules of the proof systems of SCDL are defined as 
\fi


In this paper, we only list the constructors for some rules in Appendix~\ref{section:A Part of Code for the Definition of the Sequent in Coq} (lines 18 - 183) as an example 
to explain how the proof system of SCDL is defined in Coq. 
%The constructors for some rules are listed in Appendix~\ref{section:A Part of Code for the Definition of the Sequent in Coq} (line 18 - 183). 
%Readers can find the constructors for other rules on \url{https://github.com/antitaboo/CDL}. 
Currently, we only implement all rules for one direction, 
i.e., the direction from the premises to the conclusion. 
Only these rules are applied for transforming a dynamic CDL formula into QF-AFOL formulae. 
Rules for the other direction only matter when concerning the relative completeness of the logic and 
we leave their implementations in our future work. 



Generally, all types of the constructors are of the form: 
$$\begin{aligned}\mbox{\setsf{forall ... }}&\mbox{(some parameters)\setsf{,}}\\
	&\mbox{\setsf{(Seq T1 p11 p12 D1 V1 C1 ntC1) $*$ ... $*$ (Seq Tn pn1 pn2 Dn Vn Cn ntCn)}}\\
	&\mbox{\setsf{$\arw$}}\\
	&\mbox{\setsf{Seq T p1 p2 D V C ntC}}.
\end{aligned}$$
where \setsf{$* \in \{/\backslash, \backslash / \}$}. 
It represents the proof rule
$\begin{aligned}\infer{\Gamma, \tplace_1\Rightarrow \tplace_2, \Delta}{\Gamma_1, \tplace_{11}\Rightarrow \tplace_{12}, \Delta_1 ... \Gamma_n, \tplace_{n1}\Rightarrow \tplace_{n2}, \Gamma_n}\end{aligned}$
when $*$ is $/\backslash$, and represents $n$ proof rules
$\begin{aligned}\infer{\Gamma, \tplace_1\Rightarrow \tplace_2,\Delta}{\Gamma_1, \tplace_{11}\Rightarrow \tplace_{12}, \Delta_1}, ..., 
  \infer{\Gamma, \tplace_1\Rightarrow \tplace_2,\Delta}{\Gamma_n, \tplace_{n1}\Rightarrow \tplace_{n2}, \Delta_n}
\end{aligned}$
when $*$ is $\backslash /$. 
We use the notation \begin{center}\setsf{$<|$ T , p1  $==>$  p2 , D  //  V , C , ntC $|>$}\end{center} to express the sequent 
\setsf{Seq T p1 p2 D V C ntC} in Coq (line 183).  

The constructors \setsf{r\_Test\_all\_rel\_int} (line 111), \setsf{r\_PiCho\_all\_int} (line 123), \setsf{r\_o\_int} (line 137), \setsf{r\_andR\_int} (line 152), \setsf{r\_impR\_int} (line 170) correspond to the proof rules \rul{P?[]}, \rul{\pi[\cup]}, \rul{o}, \rul{\wedge r}, \rul{\to r} respectively. 

As mentioned in the augmentation (2) above at the beginning of \Sect~\ref{section:The Proof System of SCDL in Coq}, we need to propose special rules for removing a formula from and adding a formula to a target place. 
The constructors \setsf{r\_placeR\_rmv\_int} (line 18) (resp. \setsf{r\_placeL\_rmv\_int} (line 29)) %are special for the sequent defined in Coq. 
%They 
is for removing a formula from the target place $\tplace_2$ (resp. $\tplace_1$) and adding it to the nail of the list $\Delta$ (resp. $\Gamma$). 
For example, the type of the constructor \setsf{r\_placeR\_rmv\_int} means that to prove \setsf{Seq T pls1 (exp phi) D V C ntC}, we need to prove 
\setsf{Seq T pls1 empty (addNail D phi) V C ntC}, where formula \setsf{phi} is removed from the target place (so that the target place becomes \setsf{empty}) and added to \setsf{D}. 
The function \setsf{addNail} adds the formula \setsf{phi} to the nail of the list \setsf{D}. 
Two other special constructors are \setsf{r\_placeR\_add\_int} and \setsf{r\_placeL\_add\_int} (not shown in Appendix~\ref{section:A Part of Code for the Definition of the Sequent in Coq}), they are for adding a formula from the head of the list $\Delta$ or $\Gamma$ to the target place
$\tplace_2$ or $\tplace_1$. 
%For more details about them, refer to ....	

The constructors \setsf{r\_Pi\_all\_int1} (line 43), \setsf{r\_Pi\_all\_int2} (line 56), \setsf{r\_Pi\_all\_int\_idle1} (line 79) and \setsf{r\_Pi\_all\_int\_idle2} (line 90) are for the single rule \rul{\pi[]} (similarly, there are constructors for the rule \rul{\phi[]}, which are not shown in Appendix~\ref{section:A Part of Code for the Definition of the Sequent in Coq}). 
Recall that in \rul{\pi[]}, the combinational event $\alpha$ is dealt with as a whole in one derivation. 
However in Coq, to implement this rule as one single constructor is not convenient.  
To make it as simple as possible we split the combinational event into its atomic events, 
and we build constructors to deal with the execution of a single atomic event. 
The constructors \setsf{r\_Pi\_all\_int1} and \setsf{r\_Pi\_all\_int2} deal with the executions of the assignments and signals respectively. 
When all events are dealt with in the combinational event, we need to build constructors for dealing with its end. 
The constructors \setsf{r\_Pi\_all\_int\_idle1} and \setsf{r\_Pi\_all\_int\_idle2} are defined for this purpose. 
The constructor \setsf{r\_Pi\_all\_int\_idle2} deals with all clocks that do not tick at the current instant (i.e. the set \setsf{ntC}):
according to \rul{\pi[]}, the value of their clock-related variables ($d^s_1,...,d^s_n$) should be set to $0$. 
The constructor \setsf{r\_Pi\_all\_int\_idle1} finally eliminates the combinational event once all clocks in \setsf{ntC} have been dealt with. 
In these 4 constructors, the function \setsf{NewId} is for generating new variable names, 
the functions of the notations \setsf{e [ E 'subs-E' u ]} and \setsf{T [ E 'subs-l' u ]} are for the substitutions of different expressions. 
We omit their details here. 
%Their code can be found in ....

\begin{figure}[htpb]
	\begin{center}
		\begin{minipage}[htp]{1.0\textwidth}
			\begin{tabularlstlisting}[multicols =2, frame=tlrb, numbers=left]
(* Gamma2 *)
Definition Gamma2 : Gamma := (Y >=' n(o)) :: (n(r) =' Y +' 1) :: 
	(s(r) =' 1) :: (x =' 1) :: (f =' 0) :: (s(e) =' 0) :: 
	(s(p) =' 0) :: (s(o) =' 0) :: nil. 

Theorem example : <| Gamma2 , empty ==> 
	(exp ([[ p2 ]]' r << o)) , nil //
	(x :: f :: Y :: e :: p :: r :: o :: nil), (* V *)
	(e :: p :: r :: o :: nil), (* C *)
	(e :: p :: r :: o :: nil) (* ntC *)
				  |>.
				  
Proof.
	apply r_PiCho_all_int. 
	apply r_andR_int. split.
	Focus 2.
	- apply r_Test_all_rel_int.
	  apply r_impR_int. 
	  apply r_placeL_rmv_int. 
	  apply r_Pi_all_int2;cbv.
	  apply r_Pi_all_int1;cbv.
	  apply r_Pi_all_int_idle2;apply r_Pi_all_int_idle2;apply r_Pi_all_int_idle2; cbv.
	  apply r_Pi_all_int_idle1; cbv.
	  apply r_placeR_rmv_int.
	  apply r_o_int. cbn.
	  intros H1 H2 H3. 
	  omega.
Admitted.
			\end{tabularlstlisting}
		\end{minipage}
	\\
	\vspace{0.2cm}
	\begin{minipage}[htp]{0.9\textwidth}
		\includegraphics[width=0.95\textwidth]{figures/result2}
	\end{minipage}
	\end{center}
	\captionsetup{font=footnotesize}
	\caption{\footnotesize{The proof of sequent $\Gamma_2 \Rightarrow [p_2]c_r\prec c_o$ in Coq}}
	\label{figure:The proof of sequent in Coq}
\end{figure}

\begin{example}
	We consider the derivation from the node $\circled{13}$ of the deduction procedure of $I\to [\DF]c_r\prec c_o$ (Fig.~\ref{figure:The deduction of CDL2}). 
	The problem for proving the sequent $\Gamma_2 \Rightarrow [p_2]c_r\prec c_o$ is described as a \emph{theorem} \setsf{example} (line 6) in the Coq code shown in Fig.~\ref{figure:The proof of sequent in Coq}, 
	where the program \setsf{p2} and the names \setsf{f}, \setsf{Y}, \setsf{e}, \setsf{p}, \setsf{r}, \setsf{o} have been shown in Table~\ref{table:The definition of program p2 in Coq}.
	
	Following the deduction procedure shown in Fig.~\ref{figure:The deduction of CDL2}, we conduct a proof in Coq by starting the  statement \setsf{Proof.} (line 13). 
	Here for simplicity we only perform the deduction of the branch from the node $\circled{13}$ to the node $\circled{12}$ in Fig.~\ref{figure:The deduction of CDL2}. 
	By applying the tactic \setsf{apply} to the constructors (as axioms in Coq) in the same order as their corresponding rules that are applied on this branch (lines 14 - 26), 
	we transform the formula \setsf{[[ p2 ]]' r $<<$ o} into a QF-AFOL formula shown in the below of Fig.~\ref{figure:The proof of sequent in Coq}. 
	This formula contains uninterpreted functions \setsf{H1}, \setsf{H2}, \setsf{H3} that map a name to a natural number in Coq.
	%a pure first-order logic formula shown in the below of Fig.~\ref{figure:The proof of sequent in Coq}. 
	%After applying the \setsf{intros} strategy to eliminate the quantifier `\setsf{forall}' (line 27), we obtain a QF-AFOL formula 
	%but with uninterpreted functions \setsf{st}, \setsf{fn}, \setsf{gn} that map a name to a natural number in Coq. 
	However, these uninterpreted functions can actually be eliminated since their parameters never appear alone in the formula. 
	So this formula is in fact a Presburger arithmetic formula. 
	

	At last, by applying the tactic \setsf{omega} (line 27), we solve the formula and prove the branch. 
	%--- a solver for quantifier-free problems in Presburger Arithmetic in Coq~\cite{series/txtcs/BertotC04}, 
	%we prove the branch. 
	
	
\end{example}




\section{Related Work}
\label{section: Related Works}
    Previous approaches~\cite{suryadevara13,Yin2011VMT,articleMallet,conf/lctrts/AndreM09-CCSL_Esterel,zhang14} for the verification of CCSL specifications were mainly based on
    model checking, where a CCSL specification was encoded as a target model, and reachability analysis was made on the product of the system model and the model of the CCSL specification.
    Different encoding principles were proposed according to different types of target models, such as timed automata~\cite{suryadevara13,Yin2011VMT,zhang14}, data flow graphs~\cite{articleMallet}, Esterel programs~\cite{conf/lctrts/AndreM09-CCSL_Esterel}, etc.
    When a CCSL specification is unbounded, a bound needs to be set to avoid the enumeration of an infinite number of states (e.g. in \cite{conf/lctrts/AndreM09-CCSL_Esterel}).
    Our approach is based on a method combining theorem proving and SMT checking, which provides a unified verification framework under which both bounded and unbounded CCSL specifications can be directly analyzed.

    Another aspect of formal analysis of CCSL is to find a schedule (or a set of schedules) of a given CCSL specification where no system models were involved~\cite{Andre09,conf/icfem/ZhangMZ16,ZHANG201842}.
    %CCSL there was used to describe system architectures or to coordinate system behaviour where no other system models were involved (see the examples in \cite{conf/models/BoulangerDHJMP11} and \cite{MALLET201578}).
    The earliest approach~\cite{Andre09} combined BDD-based boolean solving and the rewrite relations on clock expressions, while the recent method in \cite{ZHANG201842} was based on the rewriting logic of Maude.
    In \cite{conf/icfem/ZhangMZ16}, the search of a schedule was conducted by solving a logical formula that encodes CCSL specifications through an SMT-checking procedure.
    %Rather than understanding CCSL specification as a transition system in the approach of model checking, logic formula can encode both safe and unsafe CCSL and
    Compared with \cite{conf/icfem/ZhangMZ16}, the proposed CDL provides a natural way for capturing CCSL specifications and a modular way for transforming the CDL formula into QF-AFOL formulae, which are %more efficient for an SMT-checking procedure to solve.
	easier and more efficient for an SMT checker to solve. 
	
    Dynamic logic, first proposed by V.R. Pratt \cite{conf/focs/Pratt76-dynamicLogic}, is a formalism for modeling and reasoning about program specifications.
    The syntax and semantics of CDL are largely based on those of FODL~\cite{books/sp/Harel79} and those of its extension to concurrency~\cite{journals/jcss/Peleg87}.
    Process logic~\cite{journals/jcss/HarelKP82-processLogic} combines the features of both dynamic logic and temporal logic.
    In process logic, formulae of the form $[p]\Box\phi$ mean that all execution traces of $p$ satisfy the temporal formula $\Box\phi$.
    The semantics of SEPs and the formulae of the form $[p]\Rel$ are mainly inherited from the semantics of the formulae of the form $[p]\Box\phi$ in process logic.
    Differential Dynamic Temporal Logic \cite{books/daglib/0025392,conf/lfcs/Platzer07} (DDTL) is a dynamic logic for the specification and verification of hybrid systems.
    %where differential equation was embedded into the formula to express the dynamics of system behaviour.
    In DDTL, programs support a continuous time model with differential equations embedded into it to express the physical dynamics of hybrid systems.
    Compared with it, 
    the SEPs of CDL support a discrete time model with a synchronous execution mechanism to specify the behaviours of synchronous systems.
    The rules \rul{\pi[;]}, \rul{\pi[\cup]}, \rul{\pi[\lup]u} and \rul{\pi[\lup]i} in Table~\ref{table:Rules for path formulae} are largely inspired from the corresponding rules for formulae of the form $[p]\Box\phi$ in DDTL.

    There are many other variations of dynamic logic for reasoning about different systems, such as Java Card Dynamic Logic~\cite{series/lncs/4334-KeyApproach} for Java programs, Object-Oriented Dynamic Logic~\cite{Platzer06} for object-oriented programs, Differential Dynamic Logic~\cite{conf/tableaux/Platzer07} for hybrid systems, etc.
    To our knowledge, CDL is the first dynamic logic for synchronous systems.


\section{Conclusion and Future Work}
\label{section: Conclusion and Future Work}
In this paper, we propose a novel dynamic logic --- CDL --- for the verification of CCSL specifications in synchronous systems.
We define the syntax and semantics of CDL, and we build a proof system for CDL to semi-automatically transform a CDL formula into QF-AFOL formulae,
which can be efficiently checked through an SMT-checking procedure. We show how CCSL specifications can be expressed in CDL by encoding each clock definition as an SEP.
We analyze the soundness and completeness of CDL, and we give complete proofs for critical theorems and lemmas in Appendix~\ref{section:The Proof of Soundness and Relative Completeness of CDL}.
Finally we mechanize a part of CDL using Coq, and illustrate how CDL formulae can be proved in Coq with a small example. 
Throughout this paper we illustrate our viewpoint through a simple example, the digital filter system.


Future work will focus on two aspects:
\begin{enumerate}
\item
In this paper, the CDL we propose supports the parallel model of synchronous systems.
However, the proof system of CDL does not support the verification of parallel model in a modular way:
we verify a parallel program by reducing it into an equivalent sequential program.
The modular verification for parallel model is important for SEPs because unlike traditional imperative programs, parallel is a nature of synchronous systems.
Next we will focus on providing a rely-guarantee-style~\cite{conf/ifip/Jones83} compositional proof system for parallel SEPs.
An automatic (or semi-automatic) method could be proposed for generating suitable ``rely'' and ``guarantee'' predicates for each clock relation and clock definition.
%Since in CDL we mainly focus on CCSL properties, which only concerns the `logical constraints' between signals rather than the signal values,
Such a proof system could greatly enhance the applicability of CDL in synchronous systems.

\item
\ifx
In CDL we mainly consider specifying synchronous system with CCSL specifications.
Next we might focus on extending CDL into a more general specification language for synchronous systems.
It will allow expressing more temporal properties than CCSL specifications.
These properties will be more than the general temporal formula $[p]\Box \phi$ in the traditional temporal logic and should closely relates to `clock' and should be more adapted to the specification of synchronous models.
e.g. the logic will allow a formula $[p]\Box_c \phi$ to express that `all traces of program $p$ satisfy formula $\phi$ at each time when clock $c$ ticks'.
Such logic would require a more general proof calculus than the one proposed in this paper.
\fi
We will also consider a full mechanization of CDL in Coq. With it we can consider more practical applications in order to	 see more practical potentials of this logic.
\end{enumerate}


\section{Acknowledgements}
%We thank all the anonymous reviewers including those who reviewed the workshop version published in FTSCS 2018 for
%their valuable comments on this work.
This work has been partialy supported by the French government, through the EUR DS4H Investments in the Future project managed by the National Research Agency (ANR) with the reference number ANR-17-EURE-0004.

\clearpage
\section*{References}
%Despite a powerful proof engine that

%(mechanism in PVS...)

%(consider a dynamic logic for general purpose)
%\bibliographystyle{elsarticle-num}
%\bibliography{processAlgebraRefer160101}
\bibliographystyle{model1b-num-names}
%\bibliography{CCSL_Proof_200814}
\bibliography{CCSL_Proof_201112}

\clearpage
\appendix
\renewcommand*{\thesection}{\Alph{section}}
\section{The Proof of Soundness and Relative Completeness of CDL}
\label{section:The Proof of Soundness and Relative Completeness of CDL}
%\subsection{The Proof of Soundness and Relative Completeness of CDL}
\subsection{The Proof of Theorem~\ref{theorem: Soundness of scdl}}
\label{section:The Proof of Soundness}
We only give the proofs for some rules in Table~\ref{table:Rules for path formulae}, for the rest of the rules see an analysis in \Sect~\ref{subsection:Soundness}.
%some examples of proofs which are not trivial and are special for CDL. For the rest of rules see an analysis in Sect.~\ref{section: Soundness and Relative Completeness of CDL Proof System}.

\begin{proof}[Theorem~\ref{theorem: Soundness of scdl}]
\begin{enumerate}[label=\arabic*.]
\item For rules \rul{\pi[]}, \rul{\alpha[]}, \rul{\pi\la\ra} and \rul{\phi\la\ra}, 
we take rule \rul{\alpha[]} for example, others are similar.
By the definition of the rule: $\begin{aligned}\infer=[]{\Gamma\Rightarrow \Delta}{\Gamma'\Rightarrow \Delta'}\end{aligned}$ in \Sect~\ref{section:Sequent Calculus}, 
we need to prove the following two propositions:
\begin{enumerate}[label=(\roman*)]
\item If $\displaystyle\forall s\in S, s\mscdl (\bigwedge_{\varphi_1\in \Gamma}\varphi_1[V' / V]\wedge P_1)\to (P_2 \vee \bigvee_{\varphi_2\in \Delta}\varphi_2[V'/V])$, then $\displaystyle\forall s\in S, s\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1\to (P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2)$.
\item If $\displaystyle\forall s\in S, s\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1\to (P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2)$, then $\displaystyle\forall s\in S, s\mscdl (\bigwedge_{\varphi_1\in \Gamma}\varphi_1[V' / V]\wedge P_1)\to (P_2 \vee \bigvee_{\varphi_2\in \Delta}\varphi_2[V'/V])$. 
\end{enumerate}
where
$\displaystyle P_1 = (c^n=(c^n)'+1\wedge c^s=1\wedge x=e'[V'/V]\wedge ......\wedge \bigwedge_{1\le i\le n}d^s_i=0)$,
$P_2=\phi$,
$P_3=[(\sig^c!e|x:=e'|......)]\phi$. 
$\alpha$, $d_1,...,d_n$, $V$, $V'$ are defined as in rule \rul{\phi[]} of Table~\ref{table:Rules for non-path formulae}.
%Set $V', V$ is defined as in Table~\ref{table:Rules for non-path formulae}.
%\rmn{1} (\rmn{2}) corresponds to the situation when formula $P_3$ is on the right (left) side of the sequent in rule \rul{\alpha}.

For \rmn{1}, for any $s\in S$, if $\displaystyle s\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1$, we need to show that $\displaystyle s\mscdl P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2$.
We construct an $s'$ such that
\begin{equation}
\label{sd1eq1}
   \left\{\begin{array}{ll}
    s'(c^n) = s(c^n)+1, s'(c^s)= 1,\\
    s'(x) = \eval_s(e'),\\
    ......\\
    s'(d^s_1) = 0,..., s'(d^s_n) = 0,\\
    s'(z') = s(z), &\mbox{ for each new variable $z'\in V'$}\\
    s'(y) = s(y), &\mbox{ for other variable $y\notin V$}
    \end{array}\right.
\end{equation}
\ifx
\begin{equation}
\label{sd1eq1}
   \left\{\begin{array}{ll}
    s'(c^n)\ddef s(c^n)+1, s'(c^s)\ddef 1,\\
    s'(x):=s(e),\\
    s'(d^s_1):=0,..., s'(d^s_n):=0,\\
    ...\\
    s'(y):=s(y), &\mbox{ for other variable $y\notin V$}\\
    s'(x'):=s(x), &\mbox{ for each new variable $x'\in V'$}
    \end{array}\right.
\end{equation}
\fi
Since all variables in $V'$ are new variables in the contexts $\Gamma$ and $\Delta$, we can assume that for any $z'\in V'$,
$s(z') = s'(z')$ holds. Because if it does not, actually we can consider a new state $s''$, whose value differs from $s$ only on those variables in $V'$.
Obviously $\displaystyle s''\mcdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1$. If $\displaystyle s''\mcdl P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2$,
we also have $\displaystyle s\mcdl P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2$.

Since $\displaystyle s\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1$, from (\ref{sd1eq1}) we can get $\displaystyle s'\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1[V' /V]\wedge P_1$.
So $\displaystyle s'\mscdl P_2 \vee \bigvee_{\varphi_2\in \Delta}\varphi_2[V'/V]$ from the assumption of \rmn{1}.
The situation for $\displaystyle s'\mscdl \bigvee_{\varphi_2\in \Delta}\varphi_2[V'/ V]$ is obvious, because if so then $\displaystyle s\mscdl \bigvee_{\varphi_2\in \Delta}\varphi_2$.
If $s'\mscdl P_2$, since from (\ref{sd1eq1}) easy to see $ss'\in \val((\sig^c!e|x:=e'|......))$, according to the semantics of $P_3$ in Def.~\ref{definition: Semantics of SEP} we have $s\mscdl P_3$.

For \rmn{2}, for any $s\in S$, if $\displaystyle s\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1[V' / V]\wedge P_1$, we need to show that $\displaystyle s\mscdl P_2\vee\bigvee_{\varphi_2\in \Delta}\varphi_2[V'/ V]$.
To this end we construct an $s'$ such that
\begin{equation}
\label{sd1eq2}
\left\{\begin{array}{ll}
s'(c^n) = s((c^n)'), s'(c^s)= s((c^s)'),\\
s'(x) = s(x'),\\
......\\
s'(d^s_1) = s((d^s_1)'),..., s'(d^s_n) = s((d^s_n)'),\\
s'(z') = s(z'), &\mbox{ for each new variable $z'\in V'$}\\
s'(y) = s(y), &\mbox{ for other variable $y\notin V$}
\end{array}\right.
\end{equation}
where $(c^n)'$, $(c^s)'$, $x'$,......,$(d^s_1)'$,...,$(d^s_n)'$ are the new variables in $V'$ corresponding to $c^n$, $c^s$, $x$,......,$d^s_1$,...,$d^s_n$ in $V$. 
Since $\displaystyle \mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1[V' / V]$, from (\ref{sd1eq2}) we get $\displaystyle s'\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1$. 
So $\displaystyle s'\mscdl P_3\vee \bigvee_{\varphi_2\in \Delta}\varphi_2$ from the assumption of \rmn{2}. 
If $\displaystyle s'\mscdl \bigvee_{\varphi_2\in \Delta}\varphi_2$, then obviously $\displaystyle s\mscdl\bigvee_{\varphi_2\in \Delta}\varphi_2[V'/V]$ from (\ref{sd1eq2}).  
If $s'\mscdl P_3$, since $s\mscdl P_1$, from (\ref{sd1eq2}) easy to see that $s's\in \val(\alpha)$. 
According to the semantics of $P_3$ in Def.~\ref{definition: Semantics of SEP} we have $s\mscdl P_2$. 

\ifx
Thus we immediately get $s'\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1$ since $s\mscdl  \bigwedge_{\varphi_1\in \Gamma}\varphi_1[V'/ V]$.
Because $s\mscdl P_1\wedge P_2$, from (\ref{sd1eq2}) we know $ss'\in val((\sig^c!e|x:=e'))$.
Again according to the semantics of $P_3$ we have $s'\mscdl P_3$.
So $s'\mscdl \bigwedge_{\varphi_1\in \Gamma}\varphi_1\wedge P_3$. From the assumption of \rmn{2}, there is $s'\mscdl \bigvee_{\varphi_2\in \Delta}\varphi_2$.
From (\ref{sd1eq2}) we have $s\mscdl \bigvee_{\varphi_2\in \Delta}\varphi_2[V'/V]$.
\fi

\item %Rule \rul{P?}, \rul{\halt}, \rul{\pi\mu}, \rul{\mu}.
For rule \rul{P?[]}, we consider $A=\phi$ for example.
It is sufficient to prove that for all state $s\in S$, $s\mscdl P\to [p]\phi$ iff $s\mscdl [P?p]\phi$.
For the `if' direction,
%we need to show that if $s\mscdl P$ then $s\mscdl [p]\phi$.
since $s\mscdl [P?p]\phi$, based on the semantics of $[P?p]\phi$ given in Def.~\ref{definition: Semantics of CDL Formula}, we know for any finite trace $tr\in \val(P?p)$ starting from $s$, $tr_e\in \val(\phi)$ holds. But from Def.~\ref{definition: Semantics of SEP}, $tr\in \val(P?p)$ means if $tr_b\in \val(P)$, then $tr\in \val(p)$.
So if $s\mscdl P$, we have $s\mscdl [p]\phi$. For the `only if' direction, the condition when $s\not \mscdl P$ is trivial, since in this case there exists no trace $tr\in \val(P?p)$ starting from $s$, so $s\in \val([P?p]\phi)$ always holds. If $s\mscdl P$ and $s\mscdl [p]\phi$, we know that any trace $tr\in \val(p)$ starting from $s$ is a trace of $\val(P?p)$ too. So clearly $s\mscdl [P?p]\phi$.

According to Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}, a trace with length $1$ always satisfies a term $\Rel$, thus rule \rul{\pi\mu[]} is sound.

In rule \rul{\mu[]}, for any $s\in S$, since $\val(\mu)=S$, thus $s\in \val(\mu)$.
So we have $s\mscdl \phi$ iff $s\mscdl [\mu]\phi$.

\item %For ule \rul{\pi[;]}, \rul{\pi[\cup]}, \rul{\pi[*]u}, \rul{\pi[*]i}
The soundness of rule \rul{\pi[\cup]} is obvious, we omit its proof.

Rule \rul{\pi[\lup]u} holds because of  Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}, traces with length 1 always satisfy a relation $\Rel$, so
it is enough to consider traces with length $\ge 2$, which amounts to the traces of $p;p^\lup$.

The proofs of rule \rul{\pi[;]} and rule \rul{\pi[\lup]i} require Prop.~\ref{prop:Rel property} and Prop.~\ref{lemma:relationship between sepp and rsepp} given below.

For rule \rul{\pi[;]}, we prove for any $s\in S$, $s\mscdl [p;q]\Rel$ iff $s\mscdl [p]\Rel\wedge [p][q]\Rel$.
On the one hand, for any trace $tr\in \val(p;q)$ with $tr_b=s$, by the semantics of $p;q$ (Def.~\ref{definition: Semantics of SEP}) easy to see that there exists $tr_1\in \val(p)$, $tr_2\in \val(q)$ such that $tr=tr_1\circ tr_2$.
Because $s\mscdl [p]\Rel$ and $s\mscdl [p][q]\Rel$ hold, so $tr_1\mscdl \Rel$ and $tr_2\mscdl \Rel$ hold.
From Prop.~\ref{prop:Rel property} we know $tr\vDash_{ccsl} \Rel$. So $s\mscdl [p;q]\Rel$.
On the other hand, for any trace $tr\in \val(p)$ with $tr_b = s$ and trace $tr'\in \val(q)$ with $tr'_b=tr_e$, let $tr''=tr\circ tr'$, easy to see that $tr''\in \val(p;q)$.
Since $s\mscdl [p;q]\Rel$, there is $tr''\mscdl \Rel$.
Again from Prop.~\ref{prop:Rel property} we can get $tr\mscdl \Rel$ and $tr'\mscdl \Rel$ hold.
Therefore $s\mscdl [p]\Rel\wedge [p][q]\Rel$.

For rule \rul{\pi[\lup]i}, we prove for any $s\in S$, $s\mscdl [p^\lup]\Rel$ iff $s\mscdl [p^\lup][p]\Rel$.
On the one hand, for any trace $tr\in \val(p^\lup)$ with $tr_b = s$, we consider three situations. (1) If the length of $tr$ is 1, then obviously $tr\vDash_{ccsl} \Rel$ due to Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}.
(2) If there is a constant $n\ge 1$ such that $tr=tr_1\circ tr_2\circ ...\circ tr_n\in \val(p^n)$, where $tr_1,...,tr_{n-1}\in \val(p)$ is finite, $tr_n\in \val(p)$, since $s\mscdl [p^\lup][p]\Rel$,
for any trace $tr'\in \val(p^\lup)$ with $tr'_b=s$ and any trace $tr''$ with $tr''_b = tr'_e$, $tr''\vDash_{ccsl} \Rel$ holds.
Let $tr'=\mu$, $tr''=tr_1$, $tr'=tr_1$, $tr''=tr_2$, $tr' = tr_1\circ tr_2$, $tr''=tr_3$, ..., $tr'=tr_1\circ ...\circ tr_{n-1}$ and $tr''=tr_n$ respectively, then we can get
$tr_1\vDash_{ccsl} \Rel$, $tr_2\vDash_{ccsl} \Rel$, ..., $tr_n\vDash_{ccsl} \Rel$ respectively. From Prop.~\ref{prop:Rel property} $tr\vDash_{ccsl} \Rel$ is immediately obtained.
(3) If $tr = \underbrace{tr_1\circ tr_2\circ ...}_{\infty}$, where $tr_i\in \val(p)$ ($i\in \mbb{N}^+$) is finite, then according to Prop.~\ref{lemma:relationship between sepp and rsepp}, the proof can be attributed to situation (2).
In all three situations (1), (2), (3)above, we have $s\mscdl [p^\lup]\Rel$.
On the other hand, for any trace $tr\in \val(p^\lup)$ with $tr_b=s$, and trace $tr'\in \val(p)$ with $tr'=tr_e$, let $tr'' = tr\circ tr'$.
Because $tr'\in \val(p^\lup;p)$ and $s\mscdl [p^\lup]\Rel$, $tr''\vDash_{ccsl} \Rel$ holds.
From Prop.~\ref{prop:Rel property} there are $tr\vDash_{ccsl} \Rel$ and $tr'\vDash_{ccsl} \Rel$, so $s\mscdl [p^\lup][p]\Rel$.

\end{enumerate}
\end{proof}

\begin{proposition}[Temporal Property of $\Rel$]
\label{prop:Rel property}
Any clock relation $\Rel$ satisfies the following property: for any traces $tr$, $tr_1$ and $tr_2$ such that $tr=tr_1\circ tr_2$, where $tr_1$ is finite, there is
$$tr\vDash_{ccsl}\Rel\mbox{\quad iff\quad}tr_1\vDash_{ccsl}\Rel\mbox{ and }tr_2\vDash_{ccsl}\Rel.$$
\end{proposition}

\begin{proof}[Prop.~\ref{prop:Rel property}]
According to Def.~\ref{definition:Semantics of Clock Relations in Kripke frame},
$tr\vDash_{ccsl}\Rel$ iff for any $i\in \mbb{N}^+$, $tr(i)\mscdl \hbar(\Rel)$.
Thus for any $i\in \mbb{N}^+$, if $i\le |tr_1|$, then $tr_1(i)\mscdl \hbar(\Rel)$, if $i>|tr_1|$, then $tr_2(i)\mscdl \hbar(\Rel)$, which means $tr_1\vDash_{ccsl}\Rel$ and $tr_2\vDash_{ccsl}\Rel$ hold.
\end{proof}

\subsection{The Proof of Theorem~\ref{theorem: Completeness of scdl}}
\label{subsection: The Proof of Theorem completeness}
In the following proofs, we use $\phi^\flat$ to stress that $\phi$ is an AFOL formula.

\begin{proof}[The main body of \Theo~\ref{theorem: Completeness of scdl}]
For any formula $\phi$, by the soundness of the FOL rules (in Table~\ref{table: Rules for first order logic}), we can convert $\phi$ into a conjunctive normal form: $C_1\wedge ...\wedge C_n$. 
Each clause $C_i$ is a disjunction of literals: $C_i = l_{i,1}\vee...\vee l_{i,m_i}$, where $l_{i,j}$ ($1\le i\le n$, $1\le j\le m_i$) is an atomic CDL formula, or its negation.
By the FOL rules, it is sufficient to prove that for each clause $C_i$, $\ISCDL\mscdl C_i$ implies $\dscdlf C_i$.
We proceed by induction on the sum $n$, of the number of the appearances of $[p]$ and $\la p\ra$ and the number of quantifiers $\forall x$ and $\exists x$ prefixed to non-AFOL formulae
in $C_i$.

If $n=0$, there are no appearances of $[p]$ and $\la p\ra$ in $C_i$, so $C_i$ is an AFOL formula, by condition \rmn{1} of \Theo~\ref{theorem: Completeness of scdl}, we obtain $\dcdlf C_i$.

Suppose $n>0$, it is sufficient to consider the following cases:
$$C_i = \varphi_1 \vee \mathop{op} \varphi_2, C = \varphi\vee [p] \Rel, C = \varphi\vee \la p\ra \nneg \Rel$$
where $\mathop{op}\in \{[p],\la p\ra, \forall x, \exists x\}$.

If $C_i= \varphi_1 \vee \mathop{op} \varphi_2$, which is equivalent to $\neg \varphi_1\to \mathop{op} \varphi_2$, by condition \rmn{1}, there exist $\phi^\flat_1$ and $\phi^\flat_2$ such that
$\ISCDL\mscdl\phi^\flat_1\leftrightarrow \neg \varphi_1$ and $\ISCDL\mscdl \phi^\flat_2\leftrightarrow \varphi_2$. Then by the soundness of the FOL rules $\ISCDL\mscdl \phi^\flat_1\to \mathop{op} \phi^\flat_2$ holds.
By condition \rmn{2} we have \begin{equation}\label{eq:C1}\dscdlf\phi^\flat_1\to \mathop{op} \phi^\flat_2.\end{equation}
Since in $\phi^\flat_1\leftrightarrow \neg \varphi_1$ and $\phi^\flat_2\leftrightarrow \varphi_2$ the sum is strictly less than $n$, by inductive hypothesis we can get
\begin{equation}\label{eq:C2}\dscdlf\neg \varphi_1\to \phi^\flat_1\end{equation} and $\dscdlf\phi^\flat_2\to \varphi_2$ hold.
By condition \rmn{3} we know that \begin{equation}\label{eq:C3}\dscdlf \mathop{op} \phi^\flat_2\to \mathop{op} \varphi_2\end{equation} holds.
Based on (\ref{eq:C1}), (\ref{eq:C2}), (\ref{eq:C3}) and the FOL rules in Table~\ref{table: Rules for first order logic} we can conclude that $\dscdlf\neg \varphi_1\to \mathop{op} \varphi_2$.

If $C_i = \varphi\vee [p]\Rel$, we prove the completeness of the formula $\neg \varphi\to [p]\Rel$.
By condition \rmn{1} of \Theo~\ref{theorem: Completeness of scdl} there exists an AFOL formula $\phi^\flat_0$ such that $\ISCDL\mscdl \phi^\flat\leftrightarrow \neg \varphi$.
Note that in $\phi^\flat\leftrightarrow \neg \varphi$ the sum is strictly less than $n$, by inductive hypothesis we have $\dscdlf \neg \varphi\to \phi^\flat$.
By condition \rmn{4}, $\dscdlf\phi^\flat\to [p]\Rel$ holds. Thus we have $\dscdlf\neg\varphi\to [p]\Rel$.

Similarly for the case $C_i = \varphi \vee \la p\ra \nneg \Rel$.
\end{proof}

\ifx
The condition \rmn{1} of Theorem~\ref{theorem: Completeness of scdl} is restated as Lemma~\ref{lemma:Expressbility of CDL Formula} below.
To prove it we need to firstly build AFOL expressions for regular SEP programs (defined in Def.~\ref{}), and then for dynamic formulae $[p]\phi^\flat$. They are stated as Lemma~\ref{lemma: Construction of Ap} and Lemma~\ref{lemma: Expressibility of} respectively.
\fi

\ifx
%Before proving the expressibility of CDL formulae (Lemma~\ref{}), we first prove Lemma~\ref{lemma: Construction of Ap} and Lemma~\ref{}.
Different from the proof for FODL in \cite{books/sp/Harel79}, SEP contains operators for concurrent programming like `$\paral$', `$\varrho?p :: q$', and its loop operator $p^*$ can express an infinite loop.
So we first construct AFOL formulae (in Lemma~\ref{lemma: Construction of Ap}) for a variation of SEP, called `regular SEP'. It only contains regular constructors `$;$', `$\cup$' and finite loop `$\bullet$' that appear in FODL.
Based on Lemma~\ref{lemma: Construction of Ap}, we will show that any dynamic formula $[p]\phi^\flat$ can be expressed by an AFOL formula (in Lemma~\ref{lemma: Expressibility of}), because any dynamic formula in the form of $[p]Rel^0$ or $[p]\phi$ can be reduced to a dynamic formula $[p']Rel^0$ or $[p']\phi$ where $p'$ is a regular SEP.
%In the end, the expressibility of CDL formulae (Lemma~\ref{}) can be proved by induction on the syntax structure of CDL formulae.
\fi

Before giving the proofs of \Theo~\ref{theorem: Completeness of scdl} \rmn{1}, \rmn{2} and \rmn{3},
we define a finite fragment of SEP, called `\RSEPP'.

%The following definition defines a regular SEP.
\begin{definition}[\RSEPP]
\label{definition:Finite SEP}
The finite fragment of SEP, called `\RSEPP', is defined as follows:
$$p \ddef \mu\ |\ \alpha\ |\ \varrho\& P?\alpha\ |\ p;p\ |\ p\cup p\ |\ p^\sstar\ |\ \paral(p_1,...,p_n), $$
where $\mu$, $\alpha$, $\varrho$ and $P$ are defined as in Def.~\ref{definition: Synchronous Event Program}.

The semantics of \RSEPP s\ is defined the same as in Def.~\ref{definition: Semantics of SEP} and \ref{definition: Semantics for parallel SEP},
except for $p^\sstar$, whose semantics is given as below:
$$\val(p^\sstar)\dddef \bigcup_{n\ge 0} \val^n(p). $$

%$$
%val(p^\fstar)\ddef \bigcup_{n\ge 1}val^n(p).
%$$

\end{definition}

In CDL formulae, there is an important relationship between an SEP and its finite fragment.
We state it as the next proposition.
Intuitively, it says that for any specification of a program that a CDL formula can describe, it is enough to only consider the finite fragment of this program.

\begin{proposition}[Relation between \SEPP\ and \RSEPP\ in CDL]
\label{lemma:relationship between sepp and rsepp}
For any \SEPP\ $p$, we denote the \RSEPP\ program, which is formed by replacing all loop programs of the form $q^\lup$ in $p$ with program $q^\sstar$, as $\finite(p)$.
For any term $\Rel$ and CDL formula $\phi$, the following two relations hold:
$$\mcdl [\finite(p)]\Rel\leftrightarrow [p]\Rel \mbox{ and } \mcdl [\finite(p)]\phi\leftrightarrow [p]\phi.$$
\end{proposition}
The proof of Prop~\ref{lemma:relationship between sepp and rsepp} relies on the following Lemmas~\ref{lemma:relationship between p and finite(p) 1} and \ref{lemma:finite trace property}.

\begin{proof}[Prop.\ref{lemma:relationship between sepp and rsepp}]
We take $[p]\Rel$ as an example, $[p]\phi$ is similar.
On the one hand, if $\mscdl [p]\Rel$, for any trace $tr\in val(\finite(p))$, according to Lemma~\ref{lemma:relationship between p and finite(p) 1} \rmn{1} there is $tr\in val(p)$, so $tr\vDash_{ccsl}\Rel$.
On the other hand, if $\mscdl [\finite(p)]\Rel$, for any trace $tr\in val(p)$, we analyze two situations. (1) If $tr$ is finite, then according to Lemma~\ref{lemma:relationship between p and finite(p) 1} \rmn{2} we have $tr\in val(\finite(p))$, so $tr\vDash_{ccsl}\Rel$.
(2) If $tr$ is infinite, suppose $tr\not\vDash_{ccsl}\Rel$, then according to Def.~\ref{definition:Semantics of Clock Relations in Kripke frame}, there must exist a state $s$ in $tr$ such that
$s\mscdl \neg \hbar(\Rel)$. According to Lemma~\ref{lemma:finite trace property}, there exists a finite trace $tr'$ in $p$ containing $s$, so $tr'\not\vDash_{ccsl}\Rel$.
Since $tr'$ is also a trace of $\finite(p)$ (Lemma~\ref{lemma:relationship between p and finite(p) 1} \rmn{2}), but this contradicts the assumption $\mscdl [\finite(p)]\Rel$.
Thus $tr\vDash_{ccsl}\Rel$.
\end{proof}

The lemmas used in the proof of Prop.~\ref{lemma:relationship between sepp and rsepp} above is given below.
Lemma~\ref{lemma:relationship between p and finite(p) 1} says \RSEPP\ exactly captures all finite behaviour of SEP.
Lemma~\ref{lemma:finite trace property} reveals that for any SEP and one of its traces, all finite prefixed traces of this trace are traces of this SEP.

\begin{lemma}
\label{lemma:relationship between p and finite(p) 1}
The semantics of any \SEPP\ $p$ and the semantics of its corresponding finite fragment $\finite(p)$ satisfy the following propositions:
\begin{enumerate}[label=(\roman*)]
\item $val(\finite(p))\subseteq \val(p)$.
\item For any trace $tr\in \val(p)$, if $tr$ is finite, then $tr\in \val(\finite(p))$.
\end{enumerate}
\end{lemma}

\begin{proof}[Lemma~\ref{lemma:relationship between p and finite(p) 1}]
We proceed by induction on the structure of program $p$.
In sequential SEPs, the only non-trivial case is $p = q^\lup$.
For parallel programs of the form $p=\paral(p_1,...,p_n)$, we can first reduce it into an equivalent sequential program by applying the rewrite rules in Table~\ref{table:Rewriting rules for parallel SEP},
then we prove this sequential program by induction.

If $p=q^\lup$, by the definition of the function $\finite$, there is $\finite(p) = \finite(q)^\sstar$.
In proposition \rmn{1}, for any trace $tr$ of $\finite(q)^\sstar$, if $|tr|=1$ then obviously $tr\in \val(q^\lup)$ because $\val(\mu)\subseteq \val(q^\lup)$.
If $|tr|>1$, then there must exist an $n\ge 1$ such that $tr=tr_1\circ tr_2\circ ...\circ tr_n$,
where $tr_1,...,tr_n\in \val(\finite(q))$. By inductive hypothesis we know $tr_1\in \val(q)$, ..., $tr_n\in \val(q)$.
So by Def.~\ref{definition: Semantics of SEP} we obtain $tr\in \val(q^n)\subset \val(q^\lup)$.
In proposition\rmn{2}, for any finite trace $tr$ of $q^\lup$, if $|tr|=1$ obviously $tr\in \val(q^\lup)$.
If $|tr|>1$, there must be a number $n\ge 1$ such that $tr=tr_1\circ tr_2\circ ...\circ tr_n$, where $tr_1,...,tr_n\in \val(q)$ must be finite.
According to the inductive hypothesis there is $tr_1,...,tr_n\in \val(\finite(q))$, so $tr\in \val(\finite(q)^n)\subset \val(\finite(q))$.

\end{proof}

\begin{lemma}
\label{lemma:finite trace property}
Given an \SEPP\ $p$ and a trace $tr$ of $p$, for any state $s$ in $tr$, there exists a finite trace of $p$ that contains $s$.
\end{lemma}

\begin{proof}[Lemma~\ref{lemma:finite trace property}]
We proceed by induction on the structure of $p$.
Same as in the proof of Lemma~\ref{lemma:relationship between p and finite(p) 1}, the only non-trivial case is $p=q^\lup$.
We omit the case when $p$ is a parallel program since it can be reduced into a sequential one.


If $p=q^\lup$, let $tr$ be any trace of $p$. The case when $tr$ is finite is trivial. So we assume $tr$ is infinite.
According to the semantics of $q^\lup$, $tr$ can be one of the two forms as follows: (1) $tr=tr_1\circ tr_2\circ ...$, where $tr_i\in \val(q)$ is finite ($i\in \mbb{N}^+$);
(2) there exists a number $n\ge 1$ such that $tr=tr_1\circ ...\circ tr_n$, where $tr_1,...,tr_{n-1}$ is finite, $tr_n\in \val(q)$.
If a state $s$ is in one of the finite trace $tr_i$ ($i\in \mbb{N}^+$), we let $tr'=tr_1\circ ...\circ tr_i$. Obviously $tr'$ is a finite trace, and we have $tr'\in \val(q^i)\subset \val(q^\lup)$.
If a state $s$ is in trace $tr_n$ of form (2), then by inductive hypothesis there exists a finite trace $tr''\in \val(q)$ that contains $s$.
Now let $tr'=tr_1\circ ...\circ tr_{n-1}\circ tr''$. Obviously $tr'$ is finite, and more, we have $tr'\in \val(q^n)\subset \val(q^\lup)$.

\end{proof}

In order to prove \Theo~\ref{theorem: Completeness of scdl} \rmn{1}, we first show any \RSEPP\ is expressible in AFOL (Lemma~\ref{lemma: Construction of Ap}),
then based on the expressibility of \RSEPP s, we prove any formula $[p]\phi^\flat$ (where $p$ is a \RSEPP) is expressible (Lemma~\ref{lemma: Expressibility of}).
At last we obtain the proof of \Theo~\ref{theorem: Completeness of scdl} \rmn{1}.

The next lemma shows every \RSEPP\ (except for $\mu$) can be expressed as an AFOL formula.
The skip program $\mu$ is special, since in fact it has no behaviour.


\begin{lemma}[Construction of Formula $A_p(\vec v, \vec v')$]
\label{lemma: Construction of Ap}
For any \RSEPP\ $p$, if $p\neq \mu$, then we can construct an AFOL formula $A_p(\vec v, \vec v')$,
where $\vec v=\mcl{V}(p)$, $\vec v'$ is a vector of new variables corresponding to $\vec v$. It satisfies the following conditions:
\begin{enumerate}[label=(\roman*)]
\item For any state $s$ and vector $\vec x_0$, if $s\mscdl A_p(\vec v, \vec x_0)$, then there exists a trace $tr\in \val(p)$ such that $tr_b = s$ and $tr_e(\vec v)=\vec x_0$.
\item For any trace $tr\in \val(p)$, $tr_b\mscdl A_p(\vec v, \vec v')[tr_e(\vec v)/\vec v']$ holds.
\end{enumerate}
\end{lemma}

Given a state $s$ and a vector $\vec v = \la v_1,...,v_n\ra$, we define $s(\vec v) \dddef \la s(v_1),...,s(v_n)\ra$.

%$Var^D(p)$, $Var^\mcl{C}(p)$ return the set of general dynamic variables and the set of clock-related variables in $p$ respectively.

Before proving Lemma~\ref{lemma: Construction of Ap}, we need to introduce the concept of G\"{o}del encoding.
We use this concept to help us build AFOL formulae for finite loop program $p^*$, just like what has been done in \cite{journals/sigact/HarelKT01,books/daglib/0025392}.
%We will use this concept to help us build AFOL formulae for finite loop programs $p^*$,
%just as what it is done in \cite{journals/sigact/HarelKT01,books/daglib/0025392}.
Here we use a lemma to illustrate that some concepts we need in the proof of Lemma~\ref{lemma: Construction of Ap} can be described by formulae constructed by G\"{o}del encoding.
And we assume the existence of these formulae, without giving any hint about how to construct them.
The details of the construction is outside of the scope of this paper, interesting readers can refer to \cite{leary2015a} for more details.


%Here we just exhibit the necessary G\"{o}del encodings which have been proved to be constructible in other references (e.g. \cite{leary2015a}).
%Any more details about G\"{o}del encoding is out of the scope of this paper.

\begin{lemma}[G\"{o}del Encoding]
\label{lemma:Godel Encoding}
In \AFOL, there exist ways to encode a vector $(x_1,...,x_n)$ (where $x_1,...,x_n\in \mbb{Z}$) as a unique number $Z\in \mbb{Z}$, denoted as $Z =(x_1,...,x_n)^\mfr{G}$.
$Z$ is called the \emph{G\"{o}del number} of $(x_1,...,x_n)$. The ways of encoding are called \emph{G\"{o}del encodings}.

Let $Z=(x_1,...,x_n)^\mfr{G}$. In \AFOL, a formula $\IEl(Z, i, y)$ can be constructed through G\"{o}del encoding in order to judge:
whether the $i^{th}$ element of $(x_1,...,x_n)$ is $y$, i.e., $\IEl(Z, i, x)$ is true iff $(x_1,...,x_n)_i = y$.
A formula $\Len(Z, N)$ can be constructed through G\"{o}del encoding in order to judge:
whether the length of vector $(x_1,...,x_n)$ is $N$, i.e., $\Len(Z,N)$ is true iff $N=n$.

\end{lemma}

%The way to encode a proposition into a G\"{o}del number is not unique. Any discussion of this part is out of the scope of this paper.
Readers can refer to \cite{leary2015a} for an explicit definition of $\IEl$ and $\Len$ given above\footnote{where the corresponding names are ``$\mathit{IthElement}$'' and ``$\mathit{Length}$'' respectively.}.

\begin{proof}[Lemma~\ref{lemma: Construction of Ap}]
We proceed by induction on the structure of the \RSEPP\ $p$.
We only consider the cases when $p$ semantically equals to the following forms.
Programs in other forms can be first reduced into the following forms by laws in Prop.~\ref{proposition:equivalent relations} and rewrite rules in Table~\ref{table:Rewriting rules for parallel SEP}.

\begin{enumerate}[label=\arabic*.]
%\item We skip the case when $p\equiv \mu$.
\item If $p\equiv P?\alpha$ or $p\equiv \alpha$, we take $p\equiv P?\alpha$ as an example, $p\equiv \alpha$ is similar.
Without the lose of generality set $\alpha = (\sig^c!e|x:=e')$, then we define
$$\begin{aligned}A_{\alpha}(\vec v, \vec v') = & P\wedge (c^n)' = c^n + 1\wedge (c^s)'=1\wedge x'=e'\wedge \bigwedge_{1\le i\le n}(d^s_i)'=0,\end{aligned}$$
where $\vec v = \{c^n, c^s, d^s_1,...,d^s_n\}, 	\{d_1,...,d_n\} = \mcl{C} - \mcl{C}(\alpha)$.
$\vec v' = \{(c^n)', (c^s)', (d^s_1)',...,(d^s_n)'\}$ is the vector of new variables corresponding to $\vec v$.

For any state $s$ and vector $\vec x_0$,  if $s\mscdl A_\alpha(\vec v, \vec x_0)$, let
$$
   \left\{\begin{array}{ll}
    s'(\vec v) = \vec x_0, \\
    s'(z) = s(z), &\mbox{other variable }z
    \end{array}\right.
$$
then there is $\displaystyle s\mcdl P\wedge s'(c^n) = c^n+1\wedge s'(c^s)=1\wedge s'(x)=e'\wedge \bigwedge_{1\le i\le n}s'(d^s_i)=0$.
According to the semantics of $P?\alpha$ (Def.~\ref{definition: Semantics of SEP}), we can get $ss'\in \val(P?\alpha)$.

On the other hand, for any trace $uu'\in \val(P?\alpha)$, by the semantics of $P?\alpha$ we have:
\begin{enumerate}[label=(\arabic*)]
\item $u\in \val(P)$; 
\item $u'(c^n) = u(c^n)+1\wedge u'(c^s)=1$ and $u'(x) = \eval_u(e')$; 
\item $u'(d^n) = u(d^n)\wedge u'(d^s)=0$ for other $d\in \mcl{C}$ not in $\alpha$;
\item $u'(z) = u(z)$ for other variable $z$ not in $\alpha$. 
\end{enumerate}
Thus easy to get $u\mcdl A_\alpha(\vec v,\vec v')[u'(\vec v)/ \vec v']$.

\item If $p\equiv q\cup r$, let $$A_p(\vec v, \vec v') = A_q(\vec v, \vec v')\vee A_r(\vec v, \vec v'), $$
where $\vec v=\mcl{V}(q\cup r)$, $\vec v'$ is a vector of new variables corresponding to $\vec v$.
In the formula $A_q(\vec v, \vec v')$ (the same for $A_r(\vec v, \vec v')$), we can assume $\vec v = \mcl{V}(q\cup r) = \mcl{V}(q)$.
Because if $\mcl{V}(q)\subset \vec v$, we can actually build
a new formula as $\displaystyle A'_q(\vec v, \vec v') = A_q(\vec v_q, \vec v'_q)\wedge \bigwedge_{x\in \vec v-\vec v_q, x'\in \vec v-\vec v'_q} x = x'$,
where in $A_q(\vec v_q, \vec v'_q)$ we have $\vec v_q=\mcl{V}(q)$.
For some variable $x$ not appearing in $q$, in $A'_q(\vec v, \vec v')$ there is $x=x'$. $x'$ is a new variable corresponding to $x$.
Then we can consider $A_p(\vec v, \vec v') = A'_q(\vec v, \vec v')\vee A'_r(\vec v, \vec v')$.
If $q\equiv \mu$ (the same for $r\equiv \mu$), let $\displaystyle A_q(\vec v, \vec v') = \bigwedge_{x\in \vec v, x'\in \vec v'}x=x'$.
%where the new variable of $x$ in $\vec v'$ is $x'$.

For any state $s$ and vector $\vec x_0$, if $s\mscdl A_p(\vec v, \vec x_0)$, then according to the soundness of the FOL rules (see Table~\ref{table: Rules for first order logic}) there is
$s\mcdl A_q(\vec v, \vec x_{0})$ or $s\mcdl (A_r(\vec v, \vec x_0)$ holds.
Assume $s\mscdl A_q(\vec v, \vec x_{0})$, by inductive hypothesis there exists a trace $tr\in \val(q)$ such that $tr_b=s$ and $tr_e(\vec v)=\vec x_0$.
So by Def.~\ref{definition: Semantics of SEP} obviously $tr\in \val(q\cup r)$.

On the other hand, for any trace $tr\in \val(q\cup r)$, based on Def.~\ref{definition: Semantics of SEP} there is $tr\in \val(q)$ or $tr\in \val(r)$.
Assume $tr\in \val(q)$, by inductive hypothesis we know $tr_b\mcdl A_q(\vec v, \vec v')[tr_e(\vec v)/ \vec v']$.
So $tr_b\mcdl A_q(\vec v, \vec v')[tr_e(\vec v)/ \vec v']\vee A_r(\vec v, \vec v')[tr_e(\vec v)/ \vec v']$, i.e., $tr_b\mcdl A_p(\vec v, \vec v')[tr_e(\vec v)/ \vec v']$.

\item If $p\equiv q;r$ and $q\equiv \mu$, then define $A_p = A_r$, similarly for $r\equiv \mu$.
Now we assume $q\not\equiv \mu$ and $r\not\equiv \mu$.
Let $$A_p(\vec v, \vec v') = \exists \vec z.(A_q(\vec v,\vec v')[\vec z /\vec v']\wedge A_r(\vec v, \vec v')[\vec z/\vec v]),$$
where $\vec v=\mcl{V}(q\cup r)$, $\vec v'$ is the vector of new variables corresponding to $\vec v$.
$\vec z$ is the vector of new variables corresponding to $\vec v$ and $\vec v'$.
Like in the case $p\equiv q\cup r$ above,
In the formula $A_q(\vec v, \vec v')$ (the same for $A_r(\vec v, \vec v')$), we can assume $\vec v = \mcl{V}(q\cup r) = \mcl{V}(q)$.
Because if not so, let $\vec v_q = \mcl{V}(q)$, we can build a new formula
$\displaystyle A'_q(\vec v, \vec v') = A_q(\vec v_q, \vec v'_q)\wedge \bigwedge_{x\in \vec v-\vec v_q, x'\in \vec v'-\vec v'_q} x=x'$,
then we can consider $A_p(\vec v, \vec v') = \exists \vec z.(A'_q(\vec v,\vec v')[\vec z /\vec v']\wedge A'_r(\vec v, \vec v')[\vec z/\vec v])$ instead.
%where the new variable of $x$ in $\vec v'$ is $x'$.

For any state $s$ and vector $\vec x_0$,
if $s\mcdl A_p(\vec v, \vec x_0)$, then
there exists a vector $\vec z_0$ such that
\begin{equation}\label{eq:E0824 1}\ISCDL s\mcdl A_q(\vec v, \vec x_{0})[\vec z_0/\vec x_{0}]\mbox{ and }\ISCDL s\mcdl A_r(\vec v, \vec x_{0})[\vec z_0/\vec v].\end{equation}
From (\ref{eq:E0824 1}) and inductive hypothesis we know there exists a trace $tr\in \val(q)$ such that
\begin{equation}
\label{eq:E0826 1}
tr_b=s\mbox{ and }tr_e(\vec v) = \vec z_{0}.
\end{equation}
Let $s' = tr_e$. 
Because $\vec v = \mcl{V}(q)$, so for other variable $x\notin \vec v$ we always have $s'(x) = s(x).$
According to the semantics of $q$ and (\ref{eq:E0824 1}) there is
$s'\mcdl A_r(\vec v, \vec x_0)$.
By inductive hypothesis, there exists a trace $tr'\in \val(r)$ such that
\begin{equation}
\label{eq:E0826 2}
tr'_b=s'\mbox{ and }tr'_e(\vec v) = \vec x_0.
\end{equation}
From (\ref{eq:E0826 1}) and (\ref{eq:E0826 2}) there exists a trace $tr''=tr\circ tr' \in \val(q;r)$ that satisfies
$tr''_b=s$ and $tr''_e(\vec v) = \vec x_0$.

On the other hand, given a trace $tr\in \val(q;r)$, based on the semantics of \SEPP s\ (Def.~\ref{definition: Semantics of SEP}),
there exist traces $tr'\in \val(q)$ and $tr''\in \val(r)$ such that $tr=tr'\circ tr''.$
Let $s=tr'_b$, $s''=tr'_e=tr''_b$ and $s'=tr''_e$.
By inductive hypothesis, we have
\begin{equation}
\label{eq:A6}
\ISCDL s\mcdl A_q(\vec v, \vec v')[s''(\vec v)/\vec v']\mbox{ and }
\ISCDL s''\mcdl A_r(\vec v, \vec v')[s'(\vec v)/\vec v'].
\end{equation}
Let $\vec z_0=s''(\vec v)$,
from (\ref{eq:A6}), easy to see that
\begin{equation}
\label{eq:A8}
\ISCDL s\mcdl A_q(\vec v, \vec z_{0})\mbox { and }
\ISCDL s\mcdl A_r(\vec z_{0}, \vec v')[s'(\vec v)/\vec v'].
\end{equation}
By (\ref{eq:A8}) and the soundness of the FOL rules in Table~\ref{table: Rules for first order logic}, we get
$$s\mcdl \exists \vec z.(A_q(\vec v, \vec v')[\vec z/\vec v']\wedge A_r(\vec v, \vec v')[\vec z/\vec v][s'(\vec v)/\vec v']), $$
i.e., $\ISCDL s\mcdl A_p(\vec v, \vec v')[s'(\vec v)/\vec v']$.

\item If $p\equiv q^\sstar$ (and $q\not \equiv \mu$),
let
\begin{equation}\label{eq:A11}A_p(\vec v, \vec v') = \exists n>0. \Iter(n)\vee \Iter(0),
\end{equation}
where we define $\displaystyle \Iter(0) = \bigwedge_{x\in \vec v, x'\in \vec v'}x=x'$.
$\vec v=\mcl{V}(p)$, $\vec v'$ is the vector of new variables corresponding to $\vec v$.
%The corresponding new variable of $x$ in $\vec v'$ is $x'$.
$\Iter(n)$($n\ge 1$) is defined as an \AFOL\ formula based on the G\"{o}del encoding:
\begin{equation}
\label{eq:E0825 1}
\begin{aligned}
&\Iter(n) = \exists Z. \exists V_1 V_2. (\\
&\Len(Z, n+1) \wedge \IEl(Z,1,V_1)\wedge \IEl(Z,n+1,V_2)\wedge \Len(V_1, N)\wedge \Len(V_2, N)\wedge \\
&\ \ \bigwedge^N_{k=0}\IEl(V_1, k, \vec v_k)\wedge\bigwedge^N_{k=0}\IEl(V_2, k, \vec v'_k)\wedge \forall (1\le i\le n).\exists Y_1 Y_2. (\\
&\ \ \ \ \IEl(Z,i,Y_1)\wedge \IEl(Z,i+1,Y_2)\wedge \Len(Y_1,N)\wedge \Len(Y_2,N)\wedge \exists \vec X_1 \vec X_2. (\\
&\ \ \ \ \ \ \bigwedge^N_{k=1}\IEl(Y_1,k,\vec X_{1,k})\wedge \bigwedge^N_{k=1}\IEl(Y_2,k,\vec X_{2,k})\wedge A_q(\vec X_1,\vec X_2)\\
&\ \ \ \ \ \ )\\
&\ \ \ \ )\\
&),
\end{aligned}
\end{equation}
where $N=|\vec v|$, $Z$ is a G\"{o}del number, $V_1, V_2, Y_1, Y_2$ are variables, $\vec X_1$ and $\vec X_2$ are vectors of variables.
Formulae $\IEl$ and $\Len$ are defined in Lemma~\ref{lemma:Godel Encoding}.
$\Iter(0)$ expresses the behaviour of program $q^\sstar$ when it executes $0$ time (i.e., the behaviour of $\mu$).
Intuitively,
formula $\Iter(n)$ ($n\ge 1$) just captures the meaning of the formula $A_{q^n}(\vec v, \vec v')$:
$$A_{q^n}(\vec v, \vec v')=\exists \vec z_1\vec z_2...\vec z_{n-1}.(A_q(\vec v, \vec z_1)\wedge A_q(\vec z_1,\vec z_2)\wedge ...\wedge A_q(\vec z_{n-1}, \vec v')).$$
In $\Iter(n)$, $Z$ is the G\"{o}del number represents the vector $(W_1,...,W_{n+1})$ of length $n+1$, i.e., $Z=(W_1,...,W_{n+1})^\mfr{G}$.
$W_1,...,W_{n+1}$ are G\"{o}del numbers. $W_1$ and $W_{n+1}$ represent vectors $\vec v$ and $\vec v'$ in $A_{q^n}(\vec v, \vec v')$ respectively, i.e., $W_1=\vec {v}^\mfr{G}$ and $W_{n+1}=\vec {v'}^\mfr{G}$.
$W_2,...,W_n$ represent vectors $\vec z_1$, ..., $\vec z_{n-1}$ in $A_{q^n}(\vec v, \vec v')$ respectively, i.e.,
$W_2=\vec z^\mfr{G}_1$, $W_3=\vec z^\mfr{G}_2$, ..., $W_n = \vec z^\mfr{G}_{n-1}$.
Variables $V_1$ and $V_2$ represent the G\"{o}del number $W_1$ and $W_{n+1}$ respectively.
Variable $i$ traverses all elements in the vector $(W_1,...,W_{n+1})$.
For each value of $i$, variables $Y_1$ and $Y_2$ represent the G\"{o}del numbers $W_i$ and $W_{i+1}$ respectively.
The length of vectors $\vec X_1$ and $\vec X_2$ is $N$. They represent the element of the vector represented by the numbers $W_i$ and $W_{i+1}$ respectively.

If we take $n$ as a constant, then actually $A_{q^n}(\vec v,\vec v')$ is an \AFOL\ formula.
From (\ref{eq:E0825 1}), Lemma~\ref{lemma:Godel Encoding} and the soundness of the FOL rules (see Table~\ref{table: Rules for first order logic}),
it is not hard to prove (omitted here) $\Iter(n)$ is logical equivalent to $A_{q^n}(\vec v,\vec v')$, i.e.,
\begin{equation}
\label{eq:A12}
\ISCDL \mcdl \Iter(n)\leftrightarrow A_{q^n}(\vec v, \vec v')
\end{equation}

Now we prove conditions \rmn{1} and \rmn{2} of Lemma~\ref{lemma: Construction of Ap}.
For any state $s$, if $s\mcdl A_p(\vec v,\vec x_0)$, there are two cases:
(1) $s\mcdl \Iter(0)(\vec v, \vec x_0)$;
(2) $s\mcdl (\exists n .\Iter(n))(\vec v, \vec x_0)$.
In case (1), there is $\displaystyle s\mcdl \bigwedge_{x\in \vec v, y\in \vec x_0} x = y$,
i.e., $s(\vec v) = \vec x_0$.
Let $tr = s \in \val(\mu)\subseteq \val(p)$, obviously, $tr$ satisfies
$tr_b=s$ and $tr_e(\vec v) = \vec x_0$.
In case (2),
since $s\mcdl (\exists n .\Iter(n))(\vec v, \vec x_0)$,
there exists a number $n_0\ge 1$ such that
$\ISCDL s\mcdl \Iter(n_0)(\vec v, \vec x_0)$.
From (\ref{eq:A12}), we also have
$s\ISCDL \mcdl A_{q^{n_0}}(\vec v, \vec x_0)$, but this means
there exists vectors $\vec z_1$...$\vec z_{n-1}$ such that
\begin{equation}\label{eq:E0826 3}\ISCDL s\mcdl A_q(\vec v, \vec z_1)\wedge A_q(\vec z_1,\vec z_2)\wedge ...\wedge A_q(\vec z_{n-1}, \vec x_0).\end{equation}
Based on (\ref{eq:E0826 3}) and inductive hypothesis, below we construct a trace $tr\in \val(q^{n_0})$ that satisfies
$tr_b = s$ and $tr_e(\vec v) = \vec x_0$.
From (\ref{eq:E0826 3}) we know $s\mcdl A_q(\vec v, \vec z_1)$. By inductive hypothesis, there exists a trace $tr_1\in \val(q)$ such that
$tr_{1,b} = s$ and $tr_{1,e}(\vec v)=\vec z_1$.
Let $s_1 = tr_{1,e}$, according to the semantics of $q$ (Def.~\ref{definition: Semantics of SEP}), $s_1$ equals to $s$ except for those values in $\vec v$.
By $s\mcdl A_q(\vec z_1,\vec z_2)$ in (\ref{eq:E0826 3}), there is
$s_1\mcdl A_q(\vec v, \vec z_2)$.
Again by inductive hypothesis there exists a trace $tr_2\in \val(q)$ such that
$tr_{2,b}=s_1$ and $tr_{2,e}(\vec v) = \vec z_2$.
Let $s_2 = tr_{2,e}$,...,
continuing this process as what we just did for $s_1$, finally we see that there exist $s_1=tr_{1,e}$,...,$s_{n-1}=tr_{n-1,e}$ and $tr_1,...,tr_n\in \val(q)$ such that:
$$\begin{aligned}
&tr_{1,b}=s, tr_{1,e}(\vec v)=\vec z_1,\\
&tr_{2,b}=s_1, tr_{2,e}(\vec v)=\vec z_2,\\
&...,\\
&tr_{n-1,b}=s_{n-2}, tr_{n-1,e}(\vec v)=\vec z_{n-1},\\
&tr_{n,b}=s_{n-1}, tr_{n,e}(\vec v) = \vec x_0.
\end{aligned}$$
Let $tr = tr_1\circ tr_2\circ...\circ tr_n \in \val(q^{n_0})\subset \val(q^\sstar)$, then obviously $tr$ satisfies
$tr_b = s$ and $tr_e(\vec v) = \vec x_0$.


On the other hand, for any trace $tr\in \val(q^\sstar)$, according to the semantics of $q^\sstar$ in Def.~\ref{definition:Finite SEP}, there are two cases:
(1) $|tr|=1$, which means $tr\in \val(\mu)$;
(2) $tr\in \val(p;p^\sstar)$.
In case (1), let $s=tr$. 
It is easy to see that
$s\mcdl Iter(0)(\vec v, \vec v')[s(\vec v)/\vec v']$, i.e., $\displaystyle s\mcdl \bigwedge_{x\in \vec v, x'\in \vec v'}x=x'[s(\vec v)/\vec v']$ holds.
Thus we have $s\mcdl A_p(\vec v, \vec v')[s(\vec v)/\vec v']$.
In case (2), there exist trace $tr_1,...,tr_m\in \val(q)$ ($m\ge 1$) such that
$tr=tr_1\circ tr_2\circ...\circ tr_m$.
By inductive hypothesis, for each trace $tr_k$ ($1\le k\le m$), there is
$\ISCDL tr_{k,b}\mcdl A_q(\vec v, \vec v')[tr_{k,e}(\vec v)/\vec v']$.
Observe that $tr_{1,e}(\vec v)=tr_{2,b}(\vec v)$, by Def.~\ref{definition: Semantics of SEP} we see that $tr_{2,b}$ agrees with $tr_{1,b}$ on all values but those in $\vec v$.
So by $tr_{2,b}\mcdl A_q(\vec v, \vec v')[tr_{2,e}(\vec v)/\vec v']$ we have
$tr_{1,b}\mcdl A_q(tr_{1,e}(\vec v), \vec v')[\vec v_{2,e}(\vec v)/\vec v']$.
Note that $tr_{2,e}(\vec v)=tr_{3,b}(\vec v)$, similarly based on Def.~\ref{definition: Semantics of SEP} and $tr_{3,b}\mcdl A_q(\vec v, \vec v')[tr_{3,e}(\vec v)/\vec v']$ there is
$tr_{1,b}\mcdl A_q(tr_{2,e}(\vec v), \vec v')[tr_{3,e}(\vec v)/\vec v']$,
...,
continuing this procedure, finally, since $tr_{1,e}(\vec v)=tr_{2,b}(\vec v)$, ..., $tr_{m-1, e}(\vec v)=tr_{m, b}(\vec v)$, we have:
$$\begin{aligned}
&tr_{1,b}\mcdl A_q(\vec v, \vec v')[tr_{1,e}(\vec v)/\vec v'],\\
&tr_{1,b}\mcdl A_q(tr_{1,e}(\vec v), \vec v')[tr_{2,e}(\vec v)/\vec v'],\\
&...,\\
&tr_{1,b}\mcdl A_q(tr_{m-1,e}(\vec v), \vec v')[tr_{m,e}(\vec v)/\vec v'].
\end{aligned}$$
Hence
$\ISCDL tr_{1,b}\mcdl A_q(\vec v, tr_{1,e}(\vec v))\wedge A_q(tr_{1,e}(\vec v), tr_{2,e}(\vec v))\wedge...\wedge A_q(tr_{m-1,e}(\vec v), \vec v')[tr_{m,e}(\vec v)/\vec v']$.
Let $\vec z_1 = tr_{1,e}(\vec v)$, ..., $\vec z_{m-1} = tr_{m-1, e}(\vec v)$.
By the soundness of the FOL rules in Table~\ref{table: Rules for first order logic} there is
$tr_{1,b} \mcdl \exists \vec z_1...\vec z_{m-1}.(A_q(\vec v, \vec z_1)\wedge A_q(\vec z_1, \vec z_2)\wedge ...\wedge A_q(\vec z_{m-1}, \vec v)[tr_{m,e}(\vec v)/\vec v'])$.
From (\ref{eq:A12}) we obtain the result:
$tr_b\mcdl A_p(\vec v, \vec v')[tr_e(\vec v')/\vec v']$.
\end{enumerate}
\end{proof}

Note that in the proof of Lemma~\ref{lemma: Construction of Ap}, $\exists x>0. A_{q^n}(\vec v,\vec v')$ is not an \AFOL\ formula, because the variable $n$ appears in the subscript of `$\vec z_n$'.
This is also why we need G\"{o}del encoding to construct formula $\Iter(n)$.
%Here the way of constructing $Iter(n)$ follows \cite{books/daglib/0025392-LogicalAnalysis}.
%这也是我们通过哥德尔编码定义公式$Iter(n)$的根本原因.
%由此可知文献~\ref{}中对\FODL 逻辑中循环程序的\AFOL 公式的构造是有缺陷的(那里使用的正是公式$\exists x>0. A_{q^n}(\vec v,\vec v')$),
%正确的做法应该是文献~\ref{}, \ref{}中的做法,
%这里对$Iter(n)$的构造方法参考了文献~\cite{books/daglib/0025392-LogicalAnalysis}中的方法.

Based on Lemma~\ref{lemma: Construction of Ap}, we prove that all formulae of the form $[p]\phi^\flat$ with $p$ being a \RSEPP\ are expressible in AFOL.

\begin{lemma}[Expressibility of \mbox{$[p]\phi^\flat$}]
\label{lemma: Expressibility of}
For any CDL formula of the form $[p]\phi^\flat$ where $p$ is a \RSEPP,  there exists an \AFOL \ formula $\varphi^\flat$ such that
$$\mcdlf \varphi^\flat\leftrightarrow [p]\phi^\flat.$$
\end{lemma}

%The proof of Lemma~\ref{lemma: Expressibility of} is based on the condition \rmn{1}, \rmn{2} of Lemma~\ref{}
\begin{proof}[Lemma~\ref{lemma: Expressibility of}]
We construct $\varphi^\flat$ as:
$\varphi^\flat = \forall \vec x.(A_p(\vec v, \vec x)\to \phi^\flat[\vec x/\vec v])$,
where $A_p(\vec v, \vec x)$ is the formula constructed in Lemma~\ref{lemma: Construction of Ap}.
Now we prove
$$\mcdl \varphi^\flat\leftrightarrow [p]\phi^\flat.$$
This is equivalent to prove for any state $s$,
$\ISCDL s\mcdl \forall \vec x.(A_p(\vec v, \vec x)\to \phi^\flat[\vec x/\vec v])$ iff $\ISCDL s\mcdl [p]\phi^\flat$.

On the one hand, suppose for any state $s$, $\forall \vec x.(A_p(\vec v, \vec x)\to \phi^\flat[\vec x/\vec v])$ holds.
We need to prove that for any trace $tr\in \val(p)$ with $tr_b=s$, $tr_e\mcdl \phi^{\flat}$ holds.
Let $s'=tr_e$. By Lemma~\ref{lemma: Construction of Ap} \rmn{2} we have
$\ISCDL s\mcdl A_p(\vec v,\vec v')[s'(\vec v)/\vec v']$.
But this means $s \mcdl A_p(\vec v,\vec s'(\vec v))$.
Because $s\mcdl \forall \vec x.(A_p(\vec v, \vec x)\to \phi^\flat[\vec x/\vec v])$, so
$s\mcdl \phi^\flat[s'(\vec v)/\vec v]$ holds.
But this is to say $s'\mscdl \phi^\flat$,
because $tr$ is a trace of $p$ and according to Def.~\ref{definition: Semantics of SEP}, the evaluation of $s'$ on all variables of $\phi^\flat$ only differs from $s$
on set $\vec v$. %在公式$\phi^\flat$中所有变量下的赋值仅仅在变量集$\vec v$ 有差别.

On the other hand, suppose $\ISCDL s\mcdl [p]\phi^\flat$, we need to prove for any vector $\vec x_0$,
if $\ISCDL s\mcdl A_p(\vec v, \vec x_0)$, then $\ISCDL s\mcdl \phi^\flat[\vec x_0/\vec v]$.
From Lemma~\ref{lemma: Construction of Ap} \rmn{1} we know there exists a trace $tr\in \val(p)$ such that
$tr_b = s$ and $tr_e(\vec v)=\vec x_0$.
Let $s'=tr_e$.
Since $s\mcdl [p]\phi^\flat$, by Def.~\ref{definition: Semantics of CDL Formula} there is $s'\mcdl \phi$.
But based on the semantics of $p$, $s'$ differs from $s$ only on the set $\vec v$.
So we have $s\mcdl \phi[\vec x_0/\vec v]$.
\end{proof}

Based on Lemmas~\ref{lemma: Construction of Ap} and \ref{lemma: Expressibility of}, we now prove \Theo~\ref{theorem: Completeness of scdl} \rmn{1}.
%在引理~\ref{lemma: Construction of Ap}, \ref{lemma: Expressibility of pphi}的基础上, 我们给出定理~\ref{theorem: Completeness of scdl}\rmn{1}的证明.
According to Lemma~\ref{lemma:relationship between sepp and rsepp}, to prove the expressibility of a CDL formula that contains SEPs,
we only need to transform SEPs into their corresponding \RSEPP s in this formula through the function $\finite$, then prove the expressibility of this transformed formula.


\begin{proof}[\Theo~\ref{theorem: Completeness of scdl} \rmn{1}]
We proceed by induction on the structure of the formula $\phi$.
In sequential SEPs, the only non-trivial cases are $\phi=[p]\phi^\flat_1$ and $\phi=[p]\Rel$.
We consider both cases at the same time.
For any parallel SEP of the form $\paral(p_1,...,p_n)$, we can reduce it into an equivalent sequential SEP by the rewrite rules in Table~\ref{table:Rewriting rules for parallel SEP}.
%then proceed by the induction on this sequential SEP.
%对于形如$\paral(p_1,...,p_n)$的并行程序, 我们可先通过表~\ref{table:Rewriting rules for sequential SEP}中的重写规则, 将其转换为等价的顺序执行程序, 在对其结构进行归纳证明.

\begin{enumerate}[label=\arabic*.]
\item
If $p=\mu$, then according to the soundness of rules in Table~\ref{table:Rules for path formulae}, there is
$\mcdl tt\leftrightarrow [\mu]\Rel$.
According to the soundness of rule \rul{\pi\mu[]} in Table~\ref{table:Rules for non-path formulae}, we have
$\mcdl \phi^\flat_1\leftrightarrow [\mu]\phi^\flat_1$.

\item
If $p=\alpha$, according to the definition of $[p]\Rel$ in Def.~\ref{definition: Semantics of CDL Formula} we know $\mcdl [\alpha]\hbar(\Rel)\leftrightarrow [\alpha]\Rel$.
But $\hbar(\Rel)$ is an \AFOL\ formula, so from Lemma~\ref{lemma: Expressibility of} we know that $[\alpha]\hbar(\Rel)$ is expressible.

Because of Lemma~\ref{lemma: Expressibility of}, the case for $[\alpha]\phi^\flat_1$ is obvious.

\item
If $p=P?\alpha$, by the soundness of rule \rul{P?[]} in Table~\ref{table:Rules for path formulae} there is
$\mcdl P\to [\alpha]\Rel \leftrightarrow [P?\alpha]\Rel$.
By inductive hypothesis $[\alpha]\Rel$ is expressible, so $P\to [\alpha]\Rel$ is also expressible.

Similar for the case of $\phi=[P?\alpha]\phi^\flat_1$.

\item
If $p=q\cup r$, by the soundness of rule \rul{\pi[\cup]} in Table~\ref{table:Rules for path formulae} there is
$\ISCDL\mcdl [q]\Rel\wedge [r]Rel\leftrightarrow [q\cup r]\Rel$.
By inductive hypothesis, $[q]\Rel$ and $[r]\Rel$
are expressible, so $[q]\Rel\wedge [r]\Rel$ is also expressible.

Similar for the situation when $\phi=[q\cup r]\phi^\flat_1$.

\item
If $p=q;r$, then by the soundness of rule \rul{\pi[;]} in Table~\ref{table:Rules for path formulae} we can get
$\ISCDL\mcdl [q]\Rel\wedge [q][r]\Rel\leftrightarrow [q;r]\Rel$.
According to inductive hypothesis,
$[q]\Rel$ and $[r]\Rel$
are all expressible.
Let $\mcdl \varphi^\flat_1 \leftrightarrow [r]\Rel$,
by inductive hypothesis we see that $[q]\varphi^\flat_1$ is also expressible.
Thus $[q]\Rel\wedge [q][r]\Rel$ is expressible.

The case for $\phi=[q;r]\phi^\flat_1$ is similar.

\item
If $p=q^\lup$, we first consider the case when $\phi=[q^\lup]\phi^\flat_1$.
According to Prop.~\ref{lemma:relationship between sepp and rsepp}, we only need to consider if $[{\finite(q)}^\sstar]\phi^\flat_1$ is expressible.
However from Lemma~\ref{lemma: Expressibility of} we know $[{\finite(q)}^\sstar]\phi^\flat_1$ is expressible.

As for $[q^\lup]\Rel$, by the soundness of rule \rul{\pi[\lup]i} in Table~\ref{table:Rules for path formulae},
$\mcdl [q^\lup][q]\Rel\leftrightarrow [q^\lup]\Rel$ holds.
By inductive hypothesis, easy to see $[q]\Rel$ is expressible.
Let $\mcdl \varphi_1\leftrightarrow [q]\Rel$. $[q^\lup]\varphi_1$ belongs to case considered above.
%But we have already considered the case $[q^\lup]\varphi_1$ above.
%属于上文中考虑过的情况.

\end{enumerate}
\end{proof}

Based on Lemma~\ref{lemma: Construction of Ap} and \Theo~\ref{theorem: Completeness of scdl} \rmn{1}, now we prove \Theo~\ref{theorem: Completeness of scdl} \rmn{2}.
The main idea is based on \cite{journals/sigact/HarelKT01,books/sp/Harel79}: by making use of the expressibility of formula \CDLP \ and the soundness of proof system $\dcdlf$,
we make an induction on the structure of $p$.
%The main idea of the proof of Theo.~\ref{theorem: Completeness of scdl} \rmn{2} is from \cite{journals/sigact/HarelKT01,books/sp/Harel79}.
%利用\CDLP 公式的可表示性以及证明系统$\dcdlf$中规则的可靠性, 对程序$p$的结构进行归纳证明.

\begin{proof}[\Theo~\ref{theorem: Completeness of scdl} \rmn{2}]
We proceed by induction on the structure of $p$.
In $\varphi^\flat\to \mathop{op}\phi^\flat$, when $\mathop{op}$ is $\forall x$ or $\exists x$, the proof is obvious.
This is because $\varphi^\flat\to \mathop{op}\phi^\flat$ itself is an \AFOL\ formula, so there must be $\dcdlf\varphi^\flat\to \mathop{op}\phi^\flat$.

We first consider the case when $\mathop{op}$ is $[p]$.

\begin{enumerate}[label=\arabic*.]
\item If $p=\mu$, by the soundness of rule \rul{\mu[]} (see Table~\ref{table:Rules for path formulae}) and the FOL rules (see Table~\ref{table: Rules for first order logic}) there is
$\mcdl (\varphi^\flat \to \phi^\flat) \leftrightarrow \varphi^\flat\to [\mu]\phi^\flat$.
Since $\varphi^\flat\to \phi^\flat$ is an \AFOL \ formula, obviously
$\dcdlf \varphi^\flat\to \phi^\flat$.
By rule \rul{\mu[]} and the FOL rules we immediately obtain:
$\dcdlf \varphi^\flat\to [\mu]\phi^\flat$.

\item If $p=\alpha$, without the lose of generality let $\alpha=(\sig^c!e|x:=e')$.
Because $\mcdl \varphi^\flat\to [\alpha]\phi^\flat$, so by the soundness of rule \rul{\phi[]} and the FOL rules there is
$\mcdl \varphi^\flat[V'/ V]\wedge A\to \phi^\flat$,
where formula
$$\begin{aligned}
A = (c^n = (c^n)' + 1\wedge c^s=1\wedge x=e'[V'/V]\wedge \bigwedge_{1\le i\le n}(d^n_i=(d^n_i)'\wedge d^s_i=0)).
\end{aligned}$$
Since $\varphi^\flat[V'/V]\wedge A\to \phi^\flat$ is an \AFOL \ formula,
$\dcdlf \varphi^\flat[V'/V]\wedge A\to \phi^\flat$ holds.
By rule \rul{\phi[]} and the FOL rules we obtain
$\dcdlf \varphi^\flat\to [\alpha]\phi^\flat$.

\item If $p=P?\alpha$, according to the soundness of rule \rul{P?[]} and the FOL rules there is
$\mcdl \varphi^\flat \to (P\to [\alpha]\phi^\flat)\leftrightarrow \varphi^\flat \to [\alpha]\phi^\flat$.
So $\mcdl \varphi^\flat \to \neg P \vee \varphi^\flat \to [\alpha]\phi^\flat$.
Since $\varphi^\flat \to \neg P$ is an \AFOL \ formula, we have \begin{equation}\label{eq:E0827 7}\dcdlf \varphi^\flat \to \neg P.\end{equation}
By inductive hypothesis we have \begin{equation}\label{eq:E0827 8}\dcdlf \varphi^\flat \to [\alpha]\phi^\flat.\end{equation}
From (\ref{eq:E0827 7}) and (\ref{eq:E0827 8}), applying the FOL rules (see Table~\ref{table: Rules for first order logic}) we can get
$\dcdlf \varphi^\flat\to (P\to [\alpha]\phi^\flat)$.
By rule \rul{P?[]} and the FOL rules there is $\dcdlf \varphi^\flat \to [P?\alpha]\phi^\flat$.

\item If $p=q\cup r$, according to the soundness of rule \rul{[\cup]} and the FOL rules we know
$\mcdl \varphi^\flat\to ([q]\phi^\flat\wedge [r]\phi^\flat) \leftrightarrow \varphi^\flat \to [q\cup r]\phi^\flat$,
i.e., $\mcdl \varphi^\flat\to [q]\phi^\flat$ and $\mcdl \varphi^\flat\to [r]\phi^\flat$.
By inductive hypothesis, we have
$\dcdlf \varphi^\flat\to [q]\phi^\flat$ and $\dcdlf \varphi^\flat\to [r]\phi^\flat$ hold.
By rule \rul{[\cup]} and the FOL rules we conclude that $\dcdlf \varphi^\flat \to [q\cup r]\phi^\flat$.

\item If $p=q;r$, according to the soundness of rule \rul{[;]} and the FOL rules we can get
\begin{equation}\label{eq:E0827 9}\mcdl \varphi^\flat\to ([q][r]\phi^\flat) \leftrightarrow \varphi^\flat \to [q;r]\phi^\flat.\end{equation}
By \Theo~\ref{theorem: Completeness of scdl} \rmn{1}, there is an \AFOL\ formula $\varphi_1$ such that $\mcdl \varphi_1\leftrightarrow [r]\phi^\flat$.
So from (\ref{eq:E0827 9}) we have $\mcdl \varphi^\flat \to [q]\varphi_1$.
By inductive hypothesis we then have \begin{equation}\label{eq:E0827 12}\dcdlf \varphi_1\to [r]\phi^\flat,\ \dcdlf \varphi^\flat \to [q]\varphi_1.\end{equation}
Applying rule \rul{[]gen} to the left formula of (\ref{eq:E0827 12}), we obtain $\dcdlf [q]\varphi_1\to [q][r]\phi^\flat$.
Comparing it with the right formula of (\ref{eq:E0827 12}), we have $\dcdlf \varphi^\flat \to [q][r]\phi^\flat$.
At last, by applying rule \rul{[;]} and other FOL rules the result is obtained.

\item If $p=q^\lup$, by \Theo~\ref{theorem: Completeness of scdl} \rmn{1} there exists an \AFOL \ formula $\phi^\flat_0$ such that
\begin{equation}\label{eq:op3}\ISCDL\mscdl \phi^\flat_0\leftrightarrow [q^\lup]\phi^\flat.\end{equation}
Because $\mcdl \varphi^\flat\to [q^\lup]\phi^\flat$, we also have
 \begin{equation}\label{eq:op41}\mcdl \varphi^\flat \to \phi^\flat_0.\end{equation}
From (\ref{eq:op3}), by rule \rul{[\lup]u} and rule \rul{[;]}, it is easy to see
$$\ISCDL\mcdl \phi^\flat_0\leftrightarrow [q^\lup]\phi^\flat\leftrightarrow \phi^\flat\wedge [q;q^\lup]\phi^\flat\leftrightarrow \phi^\flat\wedge [q][q^\lup]\phi^\flat\leftrightarrow \phi^\flat\wedge [q]\phi^\flat_0.$$
From the serial logical equivalences above we can see that
\begin{equation}\label{eq:op42}\ISCDL\mcdl \phi^\flat_0\to [q]\phi^\flat_0 \mbox{ and }\ISCDL\mcdl \phi^\flat_0\to \phi^\flat.\end{equation}
By inductive hypothesis, (\ref{eq:op41}) and (\ref{eq:op42}) there are
\begin{equation}\label{eq:E0827 13}\dcdlf\varphi^\flat\to \phi^\flat_0,\ \dcdlf\phi^\flat_0\to [q]\phi^\flat_0 \mbox{ and }\dcdlf\phi^\flat_0\to \phi^\flat.\end{equation}
Based on (\ref{eq:E0827 13}), by applying rule \rul{[\lup]i} we get %(where $\phi^\flat_0$ is an invariant, $\varphi^\flat$作为上下文`$\Gamma$'的一部分),
$\dcdlf \varphi^\flat \to [q^\lup]\phi^\flat$.

\item
If $p=\paral(q_1,...,q_n)$, by applying the rewrite rules in Table~\ref{table:Rewriting rules for parallel SEP}, we can reduce $p$ into a sequential program $p'$, i.e., $p\red p'$.
By the soundness of rule \rul{r}, there is
$\mcdl \varphi^\flat\to [p']\phi^\flat \leftrightarrow \varphi^\flat \to [p]\phi^\flat$.
Since $p'$ is sequential, we can analyze it based on the cases given above. Using inductive hypothesis, finally we can get
$\dcdlf \varphi^\flat\to [p']\phi^\flat$.
By rule \rul{r} and other FOL rules there is
$\dcdlf \varphi^\flat \to [p]\phi^\flat$.
\end{enumerate}

For the case when $\mathop{op}$ is $\la p\ra$, the proof of the cases $p=\mu$, $p=\alpha$, $p=P?\alpha$, $p=q\cup r$, $p=q;r$ are similar. The difference is that in the proof we need to use
rules \rul{\phi\la\ra}, \rul{P?\la\ra}, \rul{\mu\la\ra}, \rul{\la;\ra}, \rul{\la\cup \ra}, \rul{\la\lup\ra u}, \rul{\la\ra gen} and \rul{\la \lup\ra i} (some of them are shown in Table~\ref{table:Rules for path formulae 2}), which are the \emph{dual rules} of
%corresponding to 
rules \rul{\phi[\alpha]}, \rul{P?}, \rul{\mu}, \rul{[;]}, \rul{[\cup]}, \rul{[\lup]u}, \rul{[]gen} and \rul{[\lup]i} respectively.
%表~\ref{table:Rules for non-path formulae} 中关于算子`$[]$' 的规则
%\rul{\phi}, \rul{P?}, \rul{\mu}, \rul{[;]}, \rul{[\cup]}, \rul{[\lup]u}, \rul{[]gen}, \rul{[\lup]i}的
%所对应的对偶规则:
%\rul{\sim\phi}, \rul{\sim P?}, \rul{\sim\mu}, \rul{\la;\ra}, \rul{\la\cup \ra}, \rul{\la\lup\ra u}, \rul{\la\ra gen}, \rul{\la \lup\ra i}
%来进行证明(其中一些对偶规则如表~\ref{table:Rules for non-path formulae 2}, \ref{table:Rules for path formulae 2}中所示).

We now prove the case $p=q^\lup$.
If $\ISCDL\mcdl \varphi^\flat\to \la q^\lup\ra\phi^\flat$, since $\mcdl \neg [q^\lup]\neg \phi^\flat \leftrightarrow \la q^\lup\ra \phi^\flat$, by Prop.~\ref{lemma:relationship between sepp and rsepp} there is
$\mcdl \neg [r^\sstar]\neg \phi^\flat \leftrightarrow\neg [q^\lup]\neg \phi^\flat \leftrightarrow \la q^\lup\ra \phi^\flat$,
where $\finite(q^\lup) = {r}^\sstar$, $r=\finite(q)$.
From Lemma~\ref{lemma: Expressibility of}, the formula $\la q^\lup\ra \phi^\flat$ can be expressed by an equivalent \AFOL\ formula
$\phi^\flat_0 = \neg \forall \vec x (A_{r^*}(\vec v, \vec x)\to \neg \phi^\flat[\vec x/\vec v])$.
Recall in Lemma~\ref{lemma: Construction of Ap}, let $A_{r^*}(\vec v, \vec v') = \exists n\ge 1$, then $\Iter(n)\vee \Iter(0) = \exists n.((n\ge 1\wedge \Iter(n))\vee \Iter(0))$.
Here we remove the part `$\exists n$', and let
$A_{r^\sstar}(\vec v, \vec v', n) = (n\ge 1\wedge \Iter(n))\vee \Iter(0)$.
In the formula $\phi^\flat_0$, we use $A_{r^\sstar}(\vec v, \vec v', n)$ to replace $A_{r^\sstar}$, and we obtain an \AFOL\ formula with $n$ as a free variable in it:
$\phi^\flat_0(n) = \neg \forall \vec x (A_{r^*}(\vec v, \vec x, n)\to \neg \phi^\flat[\vec x\sub \vec v])$.
Because $\mcdl \varphi^\flat \to \la q^\lup\ra \phi^\flat$, so there is
\begin{equation}\label{eq:E0827 14}\mcdl \varphi^\flat \to \exists n. \phi^\flat_0(n).\end{equation}
This is because $\exists n. \phi^\flat_0(n)$ and $\phi^\flat_0$ are in fact logical equivalent:
intuitively, we just `move' the quantifier $\exists n$ from $A_{r^\sstar}(\vec v, \vec v')$ to the front of the formula $\phi^\flat_0$.
Since $n$ only appears in $A_{r^\sstar}(\vec v, \vec v')$, the meaning of the formula does not change before and after the movement.
According to (\ref{eq:A12}) in Lemma~\ref{lemma: Construction of Ap}, Lemma~\ref{lemma: Expressibility of} and the soundness of the FOL rules (see Table~\ref{table: Rules for first order logic}),
it is not hard to prove that when $n\ge 0$, there is
\begin{equation}\label{eq:op51}\ISCDL\mcdl \phi^\flat_0(n)\leftrightarrow \la r^n\ra \phi^\flat.\end{equation}
By rule \rul{\la ;\ra} of Table~\ref{table:Rules for path formulae 2} we have for any $n>0$,
$\ISCDL\mcdl \phi^\flat_0(n)\leftrightarrow \la r^{n}\ra \phi^\flat\leftrightarrow \la r\ra \la r^{n-1}\ra \phi^\flat\leftrightarrow \la r\ra \phi^\flat_0(n-1)$.
Because $\mcdl \la r^\sstar\ra \phi^\flat \leftrightarrow \la q^\lup\ra \phi^\flat$, for any $n> 0$ there is
\begin{equation}\label{eq:E0827 15}\mcdl \phi^\flat_0(n)\to \la q\ra \phi^\flat(n-1).\end{equation}
In (\ref{eq:op51}) let $n=0$, by rule \rul{\mu\la\ra} of Table~\ref{table:Rules for path formulae 2} we get
\begin{equation}\label{eq:E0827 16}\mcdl \phi^\flat_0(0)\to \phi^\flat.\end{equation}
By inductive hypothesis, (\ref{eq:E0827 14}), (\ref{eq:E0827 15}) and (\ref{eq:E0827 16}), we obtain
$\dcdlf \varphi^\flat \to \exists n. \phi^\flat_0(n)$, $\dcdlf \phi^\flat_0(n)\to \la q\ra \phi^\flat(n-1)$ and $\dcdlf \phi^\flat_0(0)\to \phi^\flat$.
Applying rule \rul{\la\lup\ra i} %(where $\phi^\flat_0(n)$为不变量`$\varphi(x)$', 将$\varphi^\flat$看作上下文`$\Gamma$'的一部分),
and the FOL rules we get $\dcdlf \varphi^\flat\to [q^\lup]\phi^\flat$.
\end{proof}

     \begin{table}[htp]
     \begin{center}
              \noindent\makebox[\textwidth]{%
     \scalebox{1.0}{
     \begin{tabular}[htp]{|c c c c|}
     \hline
     & & &\\
     \multicolumn{2}{|c}{$\begin{aligned}\infer=[^{(P?\la\ra)}]
     {\hprel \sep \hpseq{\la P?\alpha\ra A}{h}}
     {\hprel \sep \hpseq{P\to \la\alpha\ra A}{h}}\end{aligned}
     $
     }
     &
     $\begin{aligned}\infer=[^{(\pi\mu\la\ra)}]
     {\hprel \sep \hpseq{\la\mu\ra\nneg \Rel}{h}}
     {\hprel \sep tt}\end{aligned}
     $
     &
     $\infer=[^{(\mu\la\ra)}]
     {\hprel \sep \hpseq{\la\mu\ra\phi}{h}}
     {\hprel \sep \phi}
     $
     \\
     \multicolumn{4}{|c|}{
     where $A\in \{\nneg \Rel, \phi\}$
     }\\
     \hline
     & & &\\
      $\infer=[^{(\pi\la ;\ra)}]
     {\hprel \sep \hpseq{\la p;q\ra\nneg \Rel}{h}}
     {\hprel \sep \hpseq{\la p\ra\nneg\Rel\vee \la p\ra\la q\ra\nneg\Rel}{h}}$
     &
     $\infer=[^{(\pi\la\cup\ra)}]
      {\hprel \sep \hpseq{\la p\cup q\ra\nneg\Rel}{h}}
      {\hprel \sep \hpseq{\la p\ra\nneg \Rel\vee \la q\ra\nneg\Rel}{h}}$
      &
      $\infer=[^{(\pi\la\lup\ra u)}]
      {\hprel \sep \hpseq{\la p^\lup\ra\nneg \Rel}{h}}
      {\hprel \sep \hpseq{\la p;p^\lup\ra\nneg\Rel}{h}}$
      &
      $\infer=[^{(\pi\la\lup\ra i)}]
     {\hprel \sep \hpseq{\la p^\lup\ra\nneg\Rel}{h}}
     {\hprel \sep \hpseq{\la p^\lup\ra\la p\ra\nneg\Rel}{h}}$\\
     \hline
     & & &\\
     $\infer=[^{(\la ;\ra)}]
      {\hprel\sep \hpseq{\la p;q\ra\phi}{h}}
      {\hprel\sep \hpseq{\la p\ra\la q\ra\phi}{h}}$
      &
      $\infer=[^{(\la\cup\ra)}]
      {\hprel\sep \hpseq{\la p\cup q\ra\phi}{h}}
      {\hprel\sep \hpseq{\la p\ra\phi\vee \la q\ra\phi}{h}}$
      &
      \multicolumn{2}{c|}{
      $\infer=[^{(\la\lup\ra u)}]
      {\hprel\sep \hpseq{\la p^\lup\ra\phi}{h}}
      {\hprel\sep \hpseq{\phi\vee \la p;p^\lup\ra\phi}{h}}$}\\
      %& \\
     \hline
      \end{tabular}
          }%end of scalebox
            }%end makebox
      \end{center}
      %\captionsetup{font=footnotesize}
      \caption{Other dual rules in CDL proof system}
      \label{table:Rules for path formulae 2}
\end{table}

As for the condition \rmn{3} of \Theo~\ref{theorem: Completeness of scdl}, when $op\in \{[p], \la p\ra\}$, the cases are in fact stated as rules \rul{[]gen} and \rul{\la \ra gen}.
We give the proof of \Theo~\ref{theorem: Completeness of scdl} for the case when $op\in \{\forall x, \exists x\}$ as follows.
%我们给出当$op\in \{\forall x, \exists x\}$时定理~\ref{theorem: Completeness of scdl}\rmn{4}的证明如下.

\begin{proof}[\Theo~\ref{theorem: Completeness of scdl} \rmn{3}]
We only consider the case `$\forall x$'. The case `$\exists x$' can be similarly obtained by using the dual rules of the rules used in the proof below.
%我们仅给出情况`$\forall x$'的证明, 情况`$\exists x$'的证明是类似的, 可通过应用证明情况`$\forall x$'时所用规则的对应对偶规则来实现.

Actually, using the FOL rules in Table~\ref{table: Rules for first order logic}, we can construct the following deduction:
\begin{center}
$\infer[^{(\to r)}]
    {\Gamma \Rightarrow \forall x\varphi\to \forall x\phi, \Delta}
    {\infer[^{(\forall r)}]
        {\Gamma, \forall x\varphi\Rightarrow \forall x\phi,\Delta}
        {\infer[^{(\forall l)}]
            {\Gamma, \forall x\varphi\Rightarrow \phi[x'/x],\Delta}
            {\infer[^{(\to l)}]
                {\Gamma, \forall x\varphi, \varphi[x'/x]\Rightarrow \phi[x'/x],\Delta}
                {\Gamma,\forall x\varphi\Rightarrow \varphi[x'/x]\to \phi[x'/x],\Delta}
            }
        }
    }
$
\end{center}
where $x'$ is a new variable w.r.t. $\Gamma$ and $\Delta$.
\end{proof}

The proof of \Theo~\ref{theorem: Completeness of scdl} \rmn{4} follows the proof of \Theo~\ref{theorem: Completeness of scdl} \rmn{2},
where the analysis of the most cases are similar.

\begin{proof}[\Theo~\ref{theorem: Completeness of scdl} \rmn{4}]
We proceed by induction on the structure of $p$.
Firstly, consider the completeness of the formula $\varphi^\flat\to [p]\Rel$.

\begin{enumerate}[label=\arabic*.]
\item The cases for $p=\mu$, $p=\alpha$, $p=P?\alpha$, $p=q\cup r$ and $p=\paral(q_1,...,q_n)$ are similar to the corresponding cases in the proof of \Theo~\ref{theorem: Completeness of scdl} \rmn{2} given above. The proof can be given in an inductive way by applying rules \rul{\pi\mu[]}, \rul{\pi[]}, \rul{P?[]} and \rul{\pi[\cup]}, the rewrite rules in Table~\ref{table:Rewriting rules for parallel SEP}, other FOL rules and the soundness of these rules. We omit it here.

\item If $p=q;r$, according to the soundness of rule \rul{\pi[;]} and the FOL rules we obtain
$\mcdl \varphi^\flat \to [q]\Rel\wedge [q][r]\Rel \leftrightarrow \varphi^\flat \to [q;r]\Rel$.
From \Theo~\ref{theorem: Completeness of scdl} \rmn{1} there exists an \AFOL \ formula $\varphi_1$ such that
\begin{equation}\label{eq:E0827 17}\mcdl \varphi_1\leftrightarrow [r]\Rel.\end{equation}
Because $\mcdl \varphi^\flat \to [q]\Rel$ and $\mcdl \varphi^\flat \to[q]\varphi_1$, by inductive hypothesis we know
\begin{equation}\label{eq:E0827 18}\dcdlf \varphi^\flat \to [q]\Rel\mbox{ and }\dcdlf \varphi^\flat \to[q]\varphi_1\end{equation}
holds. From (\ref{eq:E0827 17}), by inductive hypothesis we obtain
$\dcdlf \varphi_1\to [r]\Rel$.
Applying rule \rul{[]gen} to this formula we get
$\dcdlf [q]\varphi_1\to [q][r]\Rel$.
Then based on the right formula of (\ref{eq:E0827 18}) we have
\begin{equation}\label{eq:E0728 19}\dcdlf \varphi^\flat \to [q][r]\Rel.\end{equation}
With (\ref{eq:E0728 19}) and the left formula of (\ref{eq:E0827 18}) we can get
$\varphi^\flat \to ([q]\Rel\wedge [q][r]\Rel)$.
The result is obtained by applying rule \rul{\pi[;]}.

\item If $p=q^\lup$, based on the soundness of rule \rul{\pi[\lup]i}, there is
$\ISCDL\mcdl \varphi^\flat\to [q^\lup][q]\Rel$.
From \Theo~\ref{theorem: Completeness of scdl} \rmn{1} there exists an \AFOL \ formula $\phi^\flat_0$ such that
\begin{equation}\label{eq:rel1}\ISCDL\mcdl \phi^\flat_0\leftrightarrow [q]\Rel.\end{equation}
So $\ISCDL\mcdl \varphi^\flat\to [q^\lup]\phi^\flat_0$ also holds.
But this case has already been proved in \Theo~\ref{theorem: Completeness of scdl} \rmn{2}, we have
\begin{equation}\label{eq:rel2}\dcdlf \varphi^\flat\to [q^\lup]\phi^\flat_0.\end{equation}
According to (\ref{eq:rel1}), by inductive hypothesis we can get
$\dcdlf \phi^\flat_0\to [q]\Rel$.
Applying rule\rul{[]gen}, there is
\begin{equation}\label{eq:rel3}\dscdlf [q^\lup]\phi^\flat_0\to [q^\lup][q]\Rel.\end{equation}
From (\ref{eq:rel2}) and (\ref{eq:rel3}) the result is straightforward.
\end{enumerate}

For the completeness of the formula $\varphi^\flat\to \la p\ra\nneg\Rel$, its proof is similar to that of $\varphi^\flat\to \la p\ra\nneg\Rel$ given above.
Accordingly, in the proof of different cases we need to use the dual rules of rules \rul{\pi\mu[]}, \rul{\pi[]}, \rul{P?[]}, \rul{\pi[\cup]}, \rul{\pi[;]}, \rul{[]gen}, \rul{\pi[\lup]i},
\rul{\pi\mu\la\ra}, \rul{\pi\la\ra}, \rul{P?\la\ra}, \rul{\pi\la \cup \ra}, \rul{\pi\la ;\ra}, \rul{\la \ra gen} and \rul{\pi\la \lup\ra i}.
Some of them are listed in Table~\ref{table:Rules for path formulae 2}.
\end{proof}


\section{A Part of Code for the Definition of the Sequent in Coq}
\label{section:A Part of Code for the Definition of the Sequent in Coq}

\begin{tabularlstlisting}[numbers=left, stepnumber=1]
(* ========== CDL proof system ============*)
(* Gamma, Delta *)
Definition Gamma := list CDL_exp.
Definition Delta := list CDL_exp.

(* target place *)
Inductive place := 
	exp : CDL_exp -> place |
	empty : place.

(* ========== construction of the proof system ============ *)
Reserved Notation "<| T , p1  ==> p2 , D // V , C , ntC |> " (at level 75).

(* definition of sequent *)
Inductive Seq : Gamma -> place -> place -> Delta -> (list Var) -> (list Var) -> (list Var) -> Prop :=

	(* ********* rules special for the sequent ********** *)
	r_placeR_rmv_int : forall (T : Gamma) (pls1 : place) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var) 
		(phi : CDL_exp),
		(
			Seq T pls1 empty (addNail D phi) V C ntC (* put phi at the nail of D *)
		)
		->
		(
			Seq T pls1 (exp phi) D V C ntC
		)
	|

	r_placeL_rmv_int : forall (T : Gamma) (pls1 : place) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var) 
		(phi : CDL_exp),
		(
			Seq (addNail T phi) empty pls1 D V C ntC (* put phi at the nail of T *)
		)
		->
		(
			Seq T (exp phi) pls1 D V C ntC
		)
	|
	...

(* ************ rules for combinational events and formulae [p]rel ************ *)
(* Rule (\pi[]) *)
	r_Pi_all_int1 : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(x : Var) (e : e_exp) (A : Evt) (r : rel), 
		let n := NewId V in 
		(
			Seq ((x =' (e_2_E e) [(var n) subs-E &x]) :: (T [ (var n) subs-l &x ])) 
				empty (exp ([[ @ A ]]' r)) (D [ (var n) subs-l &x ]) (var n :: V) C ntC
		)
		->
		(
			Seq T empty (exp ([[ @ ((x :=' e) :: A) ]]' r)) D V C ntC
		)
	|

	r_Pi_all_int2 : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(c : Var) (e : e_exp) (A : Evt) (r : rel), 
		let n := NewId V in 
		let m := S n in
		(
			Seq (
					(n(c) =' (var n) +' 1) :: 
						(s(c) =' 1) ::
							((T [ (var n) subs-l &n(c) ]) [ (var m) subs-l &s(c) ])
				)
					empty 
						(exp ([[ @ A ]]' r)) 
							((D [ (var n) subs-l &n(c) ]) [ (var m) subs-l &s(c) ]) 
								(var m :: var n :: V) 
									C 
										(rmv ntC c) (* remove c from the set ntC *)
		)
		->
		(
			Seq T empty (exp ([[ @ ((c ! e) :: A) ]]' r)) D V C ntC
		)
	|
		
	r_Pi_all_int_idle1 : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var)
		(r : rel), 
		(
			Seq T empty (exp (hbar r)) D V C C (* when ntC = nil, reset it to C *) 
		)
		->
		(
			Seq T empty (exp ([[ @ idle ]]' r)) D V C nil
		)
	|
			
	r_Pi_all_int_idle2 : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (c : Var) (ntC' : list Var)
		(r : rel), 
		(
			let n := NewId V in 
			(
				Seq ((s(c) =' 0) :: (T [(var n) subs-l &s(c)]))
						empty
							(exp ([[ @ idle ]]' r))
								(D [(var n) subs-l &s(c)])
									((var n) :: V)
										C 
											ntC'
			)
		)
		->
		(
			Seq T empty (exp ([[ @ idle ]]' r)) D V C (c :: ntC')
		)
	|
	
	(* Rule P? *)
	r_Test_all_rel_int : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(P : P_exp) (A : Evt) (r : rel), 
		(
			Seq T empty (exp ((Pexp_2_CDLexp P) ->' [[ @ A ]]' r )) D V C ntC
		)
		->
		(
			Seq T empty (exp ([[ P ? A ]]' r)) D V C ntC
		)
	|
	
	(* Rule \pi[\cup] *)
	r_PiCho_all_int : forall (T: Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(p : SEP_exp) (q : SEP_exp) (r : rel),
		(
			Seq T empty (exp ([[ p ]]' r /\' [[ q ]]' r)) D V C ntC
		)
		->
		(
			Seq T empty (exp ([[ p U q ]]' r)) D V C ntC
		)
	|
	...
	
	(* ********** rules of FOL *********** *)
	(* Rule (o) *)
	r_o_int : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var),
		(
			let fof := (Seq_2_CDLexp T empty empty D) in 
			(
				forall (st : Var -> nat) (fn : Var -> nat) (gn : Var -> nat) , (CDLexp_2_Prop fof st fn gn)
				(* the Prop formula corresponding to the sequent: `Seq T empty empty D V' *)
			)
		)
		->
		(
			Seq T empty empty D V C ntC
		)
	|
	
	(* Rule (/\ r) *)
	r_andR_int : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(phi1 : CDL_exp) (phi2 : CDL_exp),
		(
			(
				Seq T empty (exp phi1) D V C ntC
			)
			/\
			(
				Seq T empty (exp phi2) D V C ntC
			)
		)
		->
		(
			Seq T empty (exp (phi1 /\' phi2)) D V C ntC
		)
	|
	
	(* Rule (-> r) *)
	r_impR_int : forall (T : Gamma) (D : Delta) (V : list Var) (C : list Var) (ntC : list Var)
		(phi1 : CDL_exp) (phi2 : CDL_exp),
		(
			Seq T (exp phi1) (exp phi2) D V C ntC
		)
		->
		(
			Seq T empty (exp (phi1 ->' phi2)) D V C ntC
		)
	|
	...
	
	(* define the notation at the end *)
where "<| T , p1  ==>  p2 , D  //  V , C , ntC |>" := (Seq T p1 p2 D V C ntC). 

	
\end{tabularlstlisting}

\end{document}
